<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ê°„ë‹¨RPG</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âš”ï¸</text></svg>">
  <style>
    :root {
      --primary-bg: #2c3e50;
      --secondary-bg: #34495e;
      --border-color: #7f8c8d;
      --text-color: #ecf0f1;
      --player-hp-color: #2ecc71;
      --monster-hp-color: #e74c3c;
      --xp-bar-color: #3498db;
      --button-bg: #3498db;
      --button-hover-bg: #2980b9;
      --button-disabled-bg: #95a5a6;
      --skill-learned-bg: #27ae60;
      --skill-learnable-bg: #f1c40f;
      --skill-locked-bg: #7f8c8d;
      --skill-maxed-bg: #e67e22;
      --disenchant-color: #9b59b6;
      --enchant-color: #e67e22;
      --rebirth-color: #e74c3c;
      --survival-color: #1abc9c;

      --rarity-common: #ecf0f1;
      --rarity-uncommon: #2ecc71;
      --rarity-rare: #3498db;
      --rarity-legendary: #f39c12;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: var(--primary-bg);
      color: var(--text-color);
      user-select: none;
    }

    #root {
      width: 100%;
      max-width: 400px;
      height: 100%;
      max-height: 700px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 0.8rem;
      box-sizing: border-box;
      background-color: var(--secondary-bg);
      border-radius: 12px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }

    .screen-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    .town-screen {
        justify-content: space-around;
    }

    .town-screen .player-card {
        margin: 0.8rem 0;
    }

    /* Difficulty & Class Selection */
    .difficulty-selection,
    .class-selection {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        width: 100%;
        margin-top: 1.2rem;
    }
    .difficulty-card,
    .class-card {
        background-color: rgba(0,0,0,0.2);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.8rem;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s;
        color: var(--text-color);
        font-family: inherit;
        text-align: left;
        width: 100%;
        box-sizing: border-box;
    }
    .difficulty-card:hover,
    .class-card:hover {
        background-color: var(--secondary-bg);
        transform: translateY(-3px);
    }
    .difficulty-card h2,
    .class-card h2 {
        margin: 0 0 0.4rem 0;
        color: var(--button-bg);
        font-size: 1.2rem;
    }
    .difficulty-card p,
    .class-card p {
        margin: 0;
        font-size: 0.75rem;
        line-height: 1.4;
    }


    h1 {
      margin-bottom: 0.8rem;
      font-size: 2rem;
    }

    .logo {
        font-size: 2.8rem;
        font-weight: 700;
        color: var(--skill-learnable-bg);
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px var(--rarity-legendary);
        margin-bottom: 1.5rem;
        letter-spacing: 2px;
    }

    p {
      line-height: 1.5;
    }

    #game-world {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }

    .character-card {
        background-color: rgba(0,0,0,0.2);
        padding: 0.8rem;
        border-radius: 8px;
        border: 1px solid var(--border-color);
    }

    .character-card h2 {
        margin: 0 0 0.4rem 0;
        font-size: 1.2rem;
        white-space: pre-wrap;
    }

    .player-header {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        gap: 0.4rem;
        margin-bottom: 0.4rem;
    }

    .player-header h2 {
        margin: 0;
        text-align: left;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .player-class {
        color: #bdc3c7;
        font-size: 0.8rem;
    }

    .dungeon-progress {
        text-align: center;
        font-weight: bold;
        color: var(--xp-bar-color);
        margin: 0 0 0.4rem 0 !important;
        padding-bottom: 0.4rem;
        border-bottom: 1px solid var(--border-color);
        font-size: 0.9rem;
    }

    .hp-bar-container, .xp-bar-container {
        width: 100%;
        height: 16px;
        background-color: #2c3e50;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid var(--border-color);
        margin-top: 0.4rem;
    }

    .hp-bar, .xp-bar {
        height: 100%;
        transition: width 0.3s ease-in-out;
    }

    .player-card .hp-bar {
        background-color: var(--player-hp-color);
    }

    .monster-card .hp-bar {
        background-color: var(--monster-hp-color);
    }

    .xp-bar {
        background-color: var(--xp-bar-color);
    }

    .character-card p {
        margin: 0.4rem 0 0 0;
        text-align: right;
        font-weight: bold;
        font-size: 0.75rem;
    }

    .gold-display {
        font-size: 0.9rem;
        font-weight: bold;
        margin-bottom: 0.8rem;
    }

    .gold-sp-display {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        font-size: 0.75rem;
        font-weight: bold;
    }
    .gold-sp-display p {
        margin: 0;
    }
    .gold-sp-display.top-display {
        width: 100%;
        flex-direction: row;
        justify-content: space-around;
        background: rgba(0,0,0,0.2);
        padding: 0.4rem;
        border-radius: 8px;
        margin-bottom: 0.8rem;
    }


    .player-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.4rem;
        justify-content: space-around;
        margin-top: 0.8rem;
        padding-top: 0.6rem;
        border-top: 1px solid var(--border-color);
        font-size: 0.8rem;
        font-weight: bold;
    }
    .player-equipment {
        grid-column: 1 / -1;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.4rem;
        margin-top: 0.4rem;
        padding-top: 0.4rem;
        border-top: 1px solid var(--border-color);
        font-size: 0.75rem;
        text-align: center;
    }

    .ultimate-skill-display {
        grid-column: 1 / -1;
        margin-top: 0.4rem;
        padding-top: 0.4rem;
        border-top: 1px solid var(--border-color);
        font-size: 0.75rem;
        text-align: center;
    }

    .player-buffs {
        grid-column: 1 / -1;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        margin-top: 0.4rem;
        justify-content: center;
    }
    .buff-icon {
        background-color: var(--button-bg);
        color: white;
        padding: 0.15rem 0.3rem;
        border-radius: 4px;
        font-size: 0.65rem;
        font-weight: bold;
    }

    .status-effects {
        display: flex;
        gap: 0.4rem;
        margin-top: 0.4rem;
        min-height: 18px;
    }
    .status-effect-icon {
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        padding: 0.1rem 0.3rem;
        border-radius: 4px;
        font-size: 0.65rem;
        font-weight: bold;
    }

    #message-log {
        width: 100%;
        height: 120px;
        background-color: rgba(0,0,0,0.3);
        border-radius: 8px;
        padding: 0.4rem 0.8rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column-reverse;
        box-sizing: border-box;
        border: 1px solid var(--border-color);
        margin: 0.8rem 0;
    }

    #message-log p {
        margin: 0.2rem 0;
        font-size: 0.75rem;
        border-bottom: 1px solid #4a637e;
        padding-bottom: 0.2rem;
    }
    #message-log p:first-child {
        border-bottom: none;
    }

    #action-buttons {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 0.4rem;
    }
    .town-actions {
        grid-template-columns: 1fr 1fr;
        gap: 0.6rem;
    }

    .town-actions .button {
        padding: 0.5rem;
        font-size: 0.75rem;
    }


    .button {
      padding: 0.65rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: white;
      background-color: var(--button-bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
      text-align: center;
      white-space: nowrap;
      position: relative;
    }

    .button:hover {
      background-color: var(--button-hover-bg);
    }

    .button:active {
      transform: scale(0.98);
    }

    .button:disabled {
        background-color: var(--button-disabled-bg);
        cursor: not-allowed;
        transform: none;
    }

    .button:disabled:hover {
        background-color: var(--button-disabled-bg);
    }

    .notification-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        background-color: var(--monster-hp-color);
        color: white;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7rem;
        font-weight: bold;
        box-shadow: 0 0 4px rgba(0,0,0,0.5);
    }


    /* Shop & etc. Styles */
    .shop-container, .skill-tree-screen, .rebirth-screen, .survival-shop-screen {
        justify-content: flex-start;
        padding-top: 0.8rem;
    }
    .shop-items, .skill-list, .rebirth-upgrades, .survival-items {
        width: 100%;
        margin-top: 0.8rem;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        overflow-y: auto;
        flex-grow: 1;
    }
    .shop-item, .rebirth-upgrade-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(0,0,0,0.2);
        padding: 0.6rem 0.8rem;
        border-radius: 8px;
    }
    .shop-item span, .rebirth-upgrade-info h3 {
        font-size: 0.8rem;
        font-weight: 500;
        margin: 0;
    }
    .shop-item .item-class {
        font-size: 0.65rem;
        color: var(--border-color);
        margin-left: 0.4rem;
    }

    .shop-item .button, .rebirth-upgrade-item .button {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
        min-width: 65px;
    }
    #back-to-town {
        margin-top: auto;
        width: 100%;
    }

    .shop-filters {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        margin-bottom: 0.8rem;
    }
    .filter-group {
        display: flex;
        gap: 0.4rem;
        background: rgba(0,0,0,0.2);
        padding: 0.4rem;
        border-radius: 8px;
    }
    .filter-btn {
        flex-grow: 1;
        padding: 0.3rem;
        font-size: 0.7rem;
        color: var(--text-color);
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s;
    }
    .filter-btn:hover {
        background-color: var(--primary-bg);
    }
    .filter-btn.active {
        background-color: var(--button-bg);
        border-color: var(--button-hover-bg);
        font-weight: bold;
        color: white;
    }

    /* Equipment Screen Styles */
    .equipment-screen {
        justify-content: flex-start;
    }
    .equipment-screen h1 {
        margin-bottom: 0.4rem;
        font-size: 1.5rem;
    }
    .equipment-screen h2 {
        margin-top: 1.2rem;
        margin-bottom: 0.4rem;
        font-size: 1.2rem;
    }
    .sell-mode-indicator {
        color: var(--monster-hp-color);
        font-size: 0.8rem;
    }

    .equipment-slots {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.8rem;
        width: 100%;
        margin: 0.8rem 0 0 0;
    }
    .slot-container h3 {
        margin: 0 0 0.4rem 0;
        font-size: 0.8rem;
    }
    .inventory-grid {
        width: 100%;
        flex-grow: 1;
        overflow-y: auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.4rem;
        padding: 0.4rem;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        border: 2px solid transparent;
        transition: border-color 0.3s;
        min-height: 120px;
    }
    .inventory-grid.sell-mode {
        border-color: var(--monster-hp-color);
    }
    .item-card {
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.6rem;
        cursor: pointer;
        transition: background-color 0.2s, box-shadow 0.2s;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
    }
    .item-card:hover {
        background-color: var(--primary-bg);
    }
    .item-card.sellable:hover {
        box-shadow: 0 0 8px var(--monster-hp-color);
    }
    .item-card.empty {
        display: flex;
        justify-content: center;
        align-items: center;
        color: var(--border-color);
        font-style: italic;
        cursor: default;
        font-size: 0.75rem;
        min-height: 80px;
    }
    .item-card.empty:hover {
        background-color: var(--secondary-bg);
    }
    .item-card.restricted {
        opacity: 0.6;
    }
    .restricted-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5);
        color: var(--monster-hp-color);
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: 0.8rem;
        border-radius: 8px;
        pointer-events: none;
    }
    .sell-overlay {
        position: absolute;
        bottom: 0; left: 0; right: 0;
        background: linear-gradient(to top, rgba(231, 76, 60, 0.9), transparent);
        color: white;
        text-align: center;
        font-weight: bold;
        font-size: 0.75rem;
        padding: 1rem 0 0.2rem 0;
        pointer-events: none;
    }
    .item-card .item-name {
        font-weight: bold;
        margin: 0;
        font-size: 0.8rem;
    }
    .item-card .item-class {
        font-size: 0.65rem;
        color: var(--border-color);
        font-style: italic;
        margin: 0;
    }
    .item-card .item-stats {
        font-size: 0.65rem;
        color: #bdc3c7;
        margin: 0;
    }
    .item-card .item-enchantment {
        font-size: 0.7rem;
        font-weight: bold;
        color: var(--enchant-color);
        margin-top: 0.2rem;
    }

    .equipment-screen-footer {
        width: 100%;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.8rem;
        margin-top: auto;
        padding-top: 0.8rem;
    }


    /* Blacksmith Screen Styles */
    .blacksmith-screen {
        justify-content: flex-start;
    }
    .blacksmith-screen h1 { margin-bottom: 0.4rem; }
    .blacksmith-tabs {
        display: flex;
        width: 100%;
        margin-bottom: 0.8rem;
    }
    .tab-button {
        flex: 1;
        padding: 0.6rem;
        font-size: 0.8rem;
        font-weight: bold;
        color: var(--text-color);
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: background-color 0.2s;
        border-bottom-width: 2px;
    }
    .tab-button:first-child {
        border-top-left-radius: 8px;
        border-right: none;
    }
    .tab-button:last-child {
        border-top-right-radius: 8px;
    }
    .tab-button.active {
        background-color: var(--primary-bg);
        border-bottom: 2px solid var(--button-bg);
    }

    #blacksmith-content {
        width: 100%;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
    }

    .enhancement-slots {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 0.8rem;
        width: 100%;
        margin-bottom: 0.8rem;
    }
    .enhancement-slot {
        text-align: center;
    }
    .enhancement-slot h3 {
        margin: 0 0 0.4rem;
        font-size: 0.9rem;
    }
    #enhancement-details {
        width: 100%;
        min-height: 120px;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        padding: 0.8rem;
        box-sizing: border-box;
    }
    #enhancement-details h3 {
        margin: 0 0 0.8rem;
        color: var(--xp-bar-color);
        font-size: 1.1rem;
    }
    .enhancement-info {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        margin-bottom: 0.8rem;
    }
    .info-row {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem;
    }
    .cost-display {
        font-weight: bold;
    }
    .next-stats {
        display: flex;
        gap: 0.4rem;
        font-weight: bold;
        color: var(--player-hp-color);
    }
    .penalty-info {
        font-size: 0.65rem;
        color: var(--monster-hp-color);
        margin: 0 0 0.8rem;
    }
    #enhance-button, #enchant-button {
        width: 100%;
    }
    .current-enchantment {
        font-size: 0.75rem;
        color: var(--enchant-color);
        margin-bottom: 0.4rem;
        font-style: italic;
    }
    .enchant-warning {
        font-size: 0.65rem;
        color: var(--skill-learnable-bg);
        margin: 0 0 0.8rem;
    }

    /* Disenchant Styles */
    .blacksmith-screen h2 { margin: 0 0 0.4rem 0; font-size: 1rem; }
    .inventory-grid.disenchant-mode {
        border-color: var(--disenchant-color);
    }
    .item-card.disenchantable:hover {
        box-shadow: 0 0 8px var(--disenchant-color);
    }
    .disenchant-overlay {
        position: absolute;
        bottom: 0; left: 0; right: 0;
        background: linear-gradient(to top, var(--disenchant-color), transparent);
        color: white;
        text-align: center;
        font-weight: bold;
        font-size: 0.75rem;
        padding: 1rem 0 0.2rem 0;
        pointer-events: none;
    }

    /* Skill Tree Styles */
    .skill-node {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(0,0,0,0.2);
        padding: 0.6rem 0.8rem;
        border-radius: 8px;
        border-left: 4px solid var(--skill-locked-bg);
    }
    .skill-node.learnable { border-color: var(--skill-learnable-bg); }
    .skill-node.learned { border-color: var(--skill-learned-bg); }
    .skill-node.maxed { border-color: var(--skill-maxed-bg); }

    .skill-node.locked {
        opacity: 0.6;
    }

    .skill-info {
        text-align: left;
        flex-grow: 1;
    }
    .skill-info h3 {
        margin: 0 0 0.2rem;
        font-size: 0.9rem;
    }
    .skill-info p {
        margin: 0 0 0.2rem;
        font-size: 0.75rem;
    }
    .skill-info small {
        font-size: 0.65rem;
        color: var(--border-color);
    }
    .learn-skill-btn {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
        min-width: 70px;
    }
    .skill-node.learnable .learn-skill-btn {
        background-color: var(--skill-learnable-bg);
        color: #2c3e50;
    }


    /* Quest Screen Styles */
    .quest-screen {
        justify-content: flex-start;
    }
    .quest-screen h1 {
        margin-bottom: 0;
    }
    .quest-list {
        width: 100%;
        flex-grow: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }
    .quest-item {
        display: flex;
        justify-content: space-between;
        align-items: stretch;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        padding: 0.8rem;
        gap: 0.8rem;
    }
    .quest-info {
        flex-grow: 1;
        text-align: left;
    }
    .quest-description {
        font-weight: bold;
        font-size: 0.9rem;
        margin: 0 0 0.4rem 0;
    }
    .quest-progress-bar-container {
        height: 10px;
        background-color: var(--primary-bg);
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 0.2rem;
    }
    .quest-progress-bar {
        height: 100%;
        background-color: var(--xp-bar-color);
        transition: width 0.3s;
    }
    .quest-progress-text {
        font-size: 0.65rem;
        text-align: right;
        margin: 0 0 0.4rem 0;
        color: var(--border-color);
    }
    .quest-reward {
        font-size: 0.75rem;
        margin: 0;
        font-weight: bold;
    }
    .quest-action {
        display: flex;
        align-items: center;
    }
    .quest-action .button {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
    }

    .quest-tabs {
        display: flex;
        width: 100%;
        margin: 0.8rem 0;
    }


    /* Rarity Colors */
    .rarity-common { color: var(--rarity-common); }
    .rarity-uncommon { color: var(--rarity-uncommon); }
    .rarity-rare { color: var(--rarity-rare); }
    .rarity-legendary { color: var(--rarity-legendary); }

    #message-log .rarity-uncommon, #message-log .rarity-rare, #message-log .rarity-legendary {
        font-weight: bold;
    }

    /* Reset Button */
    #reset-button {
        position: absolute;
        top: 10px;
        left: 10px;
        background: none;
        border: none;
        color: var(--border-color);
        cursor: pointer;
        font-size: 0.7rem;
        padding: 4px;
        z-index: 1000;
        text-decoration: none;
    }

    #reset-button:hover {
        color: var(--text-color);
        text-decoration: underline;
    }
    
    #creator-credit {
        position: fixed;
        top: 10px;
        right: 10px;
        font-size: 0.7rem;
        color: var(--border-color);
        z-index: 1000;
    }

    /* Rebirth screen styles */
    .rebirth-info {
        background: rgba(0,0,0,0.2);
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1rem;
        width: 100%;
        box-sizing: border-box;
    }
    .rebirth-info p {
        margin: 0.5rem 0;
        font-size: 0.9rem;
    }
    .rebirth-points {
        color: var(--rebirth-color);
        font-weight: bold;
    }
    .rebirth-upgrade-info p {
        font-size: 0.8rem;
        margin: 0;
    }

    /* Guide Button & Modal Styles */
    #guide-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 60px;
        height: 60px;
        background-color: var(--skill-learnable-bg);
        color: var(--primary-bg);
        border-radius: 50%;
        border: none;
        font-size: 2rem;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
        transition: transform 0.2s;
    }
    #guide-button:hover {
        transform: scale(1.1);
    }

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        z-index: 2000;
        padding: 1rem;
        box-sizing: border-box;
    }

    .modal-content {
        background-color: var(--primary-bg);
        padding: 1.5rem;
        border-radius: 12px;
        width: 100%;
        max-width: 500px;
        height: 90%;
        max-height: 700px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }

    .modal-content h2 {
        color: var(--xp-bar-color);
        text-align: center;
        margin-top: 0;
        margin-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.5rem;
    }

    .modal-body {
        overflow-y: auto;
        flex-grow: 1;
    }

    .modal-body h3 {
        color: var(--skill-learnable-bg);
        margin-top: 1rem;
        margin-bottom: 0.5rem;
    }

    .modal-body p, .modal-body li {
        font-size: 0.85rem;
        line-height: 1.6;
        color: var(--text-color);
    }
    .modal-body ul {
        padding-left: 1.2rem;
    }

    .modal-footer {
        margin-top: 1rem;
        text-align: center;
    }

    /* Dungeon Map Styles */
    .dungeon-map {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      margin-bottom: 0.8rem;
      padding: 0.4rem;
      background-color: rgba(0,0,0,0.2);
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
    }
    .map-node {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: var(--secondary-bg);
      border: 2px solid var(--border-color);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 10px;
      transition: all 0.3s;
    }
    .map-node.cleared {
      background-color: var(--button-disabled-bg);
      border-color: var(--secondary-bg);
    }
    .map-node.current {
      background-color: var(--player-hp-color);
      border-color: var(--text-color);
      transform: scale(1.2);
      box-shadow: 0 0 8px var(--player-hp-color);
    }
    .map-node.boss {
      background-color: var(--monster-hp-color);
      border-color: #ff7675;
      transform: scale(1.3);
    }
    .map-node.boss.current {
        transform: scale(1.5);
        box-shadow: 0 0 10px var(--monster-hp-color);
    }
    .map-connector {
      flex-grow: 1;
      height: 2px;
      background-color: var(--border-color);
      max-width: 15px;
    }
  </style>
</head>
<body>
  <div id="creator-credit">ì œì‘ì:í•œêµ­ì¸ì´ë¼ë©´</div>
  <div id="root"></div>
  <script type="module">
    /**
     * @license
     * SPDX-License-Identifier: Apache-2.0
     */

    const root = document.getElementById('root');
    if (!root) {
      throw new Error('Could not find root element');
    }

    // --- Game Constants ---
    const CRIT_MULTIPLIER = 1.5;
    const POTION_HEAL_PERCENT = 0.6;
    const BASE_POTION_COST = 20;
    const POTION_COST_PER_LEVEL = 5;
    const DEFEAT_GOLD_PENALTY = 0.1;
    const ESCAPE_GOLD_PENALTY = 0.05;
    const CLASS_CHANGE_COST = 10000;
    const REBIRTH_LEVEL_REQ = 30;

    const STATUS_EFFECT_DEFINITIONS = {
        poison: { name: 'ë…', icon: 'â˜ ï¸' },
        burn: { name: 'í™”ìƒ', icon: 'ğŸ”¥' },
        stun: { name: 'ê¸°ì ˆ', icon: 'ğŸ’«' },
        weaken: { name: 'ì•½í™”', icon: 'â†“' },
        vulnerable: { name: 'ì·¨ì•½', icon: 'ğŸ›¡ï¸ğŸ’¥' },
    };

    const CLASSES = {
        'ì „ì‚¬': { emoji: 'ğŸ›¡ï¸', baseHp: 150, baseAtk: 12, baseDef: 3, weapon: 'ê²€', crit: 0.1, evade: 0.05 },
        'ë§ˆë²•ì‚¬': { emoji: 'ğŸ”¥', baseHp: 110, baseAtk: 16, baseDef: 0, weapon: 'ì§€íŒ¡ì´', crit: 0.1, evade: 0.05 },
        'ë„ì ': { emoji: 'ğŸ’¨', baseHp: 115, baseAtk: 12, baseDef: 1, weapon: 'ë‹¨ê²€', crit: 0.25, evade: 0.18 },
    };

    const DIFFICULTY_SETTINGS = {
        'ì‰¬ì›€': { monsterHpMod: 0.75, monsterAtkMod: 0.75, startGold: 50, startPotions: 5, rewardMod: 0.8 },
        'ë³´í†µ': { monsterHpMod: 1.0, monsterAtkMod: 1.0, startGold: 20, startPotions: 2, rewardMod: 1.0 },
        'ì–´ë ¤ì›€': { monsterHpMod: 1.3, monsterAtkMod: 1.3, startGold: 0, startPotions: 1, rewardMod: 1.25 },
    };

    const ULTIMATE_SKILLS = {
        'ì „ì‚¬': {
            id: 'w_ultimate',
            name: 'ì² ì˜¹ì„±',
            cooldown: 5,
            description: level => `ê³µê²©ë ¥ì˜ 200% í”¼í•´ë¥¼ ì£¼ê³ , ${2+level}í„´ ë™ì•ˆ ë°©ì–´ë ¥ì´ ${30 + level * 5}% ì¦ê°€í•˜ëŠ” 'ì² ë²½' íš¨ê³¼ë¥¼ ì–»ìŠµë‹ˆë‹¤.`,
            effect: level => ({
                damageMultiplier: 2.0,
                buff: { stat: 'defense', value: 0.30 + level * 0.05, duration: 2 + level, isPercent: true },
                message: 'ğŸ›¡ï¸ ê°•ì² ì˜ ì˜ì§€! [ì² ì˜¹ì„±]ì„ ë°œë™í•˜ì—¬ ì ì—ê²Œ ì°¸ê²©ì„ ë‚ ë¦¬ê³ , ëª¸ì´ ê°•ì² ì²˜ëŸ¼ ë‹¨ë‹¨í•´ì¡Œë‹¤!'
            })
        },
        'ë§ˆë²•ì‚¬': {
            id: 'm_ultimate',
            name: 'ë©”í…Œì˜¤',
            cooldown: 5,
            description: level => `ê³µê²©ë ¥ì˜ ${250 + level*20}% í”¼í•´ë¥¼ ì…íˆê³ , 3í„´ê°„ í„´ë§ˆë‹¤ ${10 + level * 3}ì˜ í™”ìƒ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.`,
            effect: level => ({
                damageMultiplier: 2.5 + level * 0.2,
                statusEffect: { type: 'burn', chance: 1.0, duration: 3, potency: 10 + level * 3 },
                message: 'â˜„ï¸ í•˜ëŠ˜ì´ ë¶‰ê²Œ ë¬¼ë“ ë‹¤! ê±°ëŒ€í•œ [ë©”í…Œì˜¤]ê°€ ë–¨ì–´ì ¸ ì ì„ ë¶ˆíƒœìš°ê³  ì§€ë©´ì„ ë…¹ì¸ë‹¤!'
            })
        },
        'ë„ì ': {
            id: 'r_ultimate',
            name: 'ê·¸ë¦¼ì ìŠµê²©',
            cooldown: 5,
            description: level => `ê³µê²©ë ¥ì˜ ${150 + level*10}% í”¼í•´ë¥¼ 2ë²ˆ ì…íˆê³ , 3í„´ê°„ í„´ë§ˆë‹¤ ${8 + level * 2}ì˜ ë… í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.`,
            effect: level => ({
                damageMultiplier: 1.5 + level * 0.1, // This is per hit
                statusEffect: { type: 'poison', chance: 1.0, duration: 3, potency: 8 + level * 2 },
                message: 'ğŸ’¨ ì–´ë‘  ì†ì—ì„œ ë²ˆëœ©ì´ëŠ” ì¹¼ë‚ ! [ê·¸ë¦¼ì ìŠµê²©]ìœ¼ë¡œ ì ì˜ ë°°í›„ë¥¼ 2íšŒ ê°•íƒ€í•˜ê³  ë§¹ë…ì„ ì£¼ì…í–ˆë‹¤!'
            })
        }
    };

    const SKILL_DATA = {
        'ì „ì‚¬': {
            'w_hp_1': { id: 'w_hp_1', name: 'ê°•ê±´í•œ ìœ¡ì²´', description: level => `ìµœëŒ€ ìƒëª…ë ¥ì´ ë ˆë²¨ë‹¹ 15ì”© ì¦ê°€í•©ë‹ˆë‹¤. (ì´ +${level*15})`, cost: level => 100 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'maxHp', value: 15 * level }] },
            'w_atk_1': { id: 'w_atk_1', name: 'ë¬´ê¸° ì—°ë§ˆ', description: level => `ê³µê²©ë ¥ì´ ë ˆë²¨ë‹¹ 2ì”© ì¦ê°€í•©ë‹ˆë‹¤. (ì´ +${level*2})`, cost: level => 120 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'attackPower', value: 2 * level }] },
            'w_def_1': { id: 'w_def_1', name: 'ë°©ì–´êµ¬ ê°•í™”', description: level => `ë°©ì–´ë ¥ì´ ë ˆë²¨ë‹¹ 1ì”© ì¦ê°€í•©ë‹ˆë‹¤. (ì´ +${level*1})`, cost: level => 150 * (level + 1), requiredPlayerLevel: 3, prerequisites: [{id: 'w_hp_1', level: 1}], effects: level => [{ stat: 'defense', value: 1 * level }] },
            'w_ult_1': { id: 'w_ult_1', name: 'ì² ì˜¹ì„± ê°•í™”', description: level => `ì² ì˜¹ì„±ì˜ ë°©ì–´ë ¥ ì¦ê°€ íš¨ê³¼ê°€ ë ˆë²¨ë‹¹ 5%ì”© ì¶”ê°€ë©ë‹ˆë‹¤.`, cost: level => 500 * (level + 1), requiredPlayerLevel: 5, prerequisites: [{id: 'w_def_1', level: 2}], effects: level => [] }, // Special handling
        },
        'ë§ˆë²•ì‚¬': {
            'm_atk_1': { id: 'm_atk_1', name: 'ë¹„ì „ë ¥ ì¦í­', description: level => `ê³µê²©ë ¥ì´ ë ˆë²¨ë‹¹ 3ì”© ì¦ê°€í•©ë‹ˆë‹¤. (ì´ +${level*3})`, cost: level => 120 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'attackPower', value: 3 * level }] },
            'm_hp_1': { id: 'm_hp_1', name: 'ì›ì†Œ ë³´í˜¸ë§‰', description: level => `ìµœëŒ€ ìƒëª…ë ¥ì´ ë ˆë²¨ë‹¹ 10ì”© ì¦ê°€í•©ë‹ˆë‹¤. (ì´ +${level*10})`, cost: level => 100 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'maxHp', value: 10 * level }] },
            'm_burn_1': { id: 'm_burn_1', name: 'íƒ€ì˜¤ë¥´ëŠ” ë¶ˆê½ƒ', description: level => `ëª¨ë“  í™”ìƒ í”¼í•´ê°€ ë ˆë²¨ë‹¹ 10%ì”© ì¦ê°€í•©ë‹ˆë‹¤.`, cost: level => 300 * (level + 1), requiredPlayerLevel: 3, prerequisites: [{id: 'm_atk_1', level: 1}], effects: level => [] }, // Special handling
            'm_ult_1': { id: 'm_ult_1', name: 'ë©”í…Œì˜¤ ê°•í™”', description: level => `ë©”í…Œì˜¤ì˜ ê¸°ë³¸ í”¼í•´ëŸ‰ì´ ë ˆë²¨ë‹¹ 10%ì”© ì¦ê°€í•©ë‹ˆë‹¤.`, cost: level => 500 * (level + 1), requiredPlayerLevel: 5, prerequisites: [{id: 'm_burn_1', level: 1}], effects: level => [] }, // Special handling
        },
        'ë„ì ': {
            'r_crit_1': { id: 'r_crit_1', name: 'ê¸‰ì†Œ íŒŒì•…', description: level => `ì¹˜ëª…íƒ€ í™•ë¥ ì´ ë ˆë²¨ë‹¹ 1%ì”© ì¦ê°€í•©ë‹ˆë‹¤. (ì´ +${level}%)`, cost: level => 150 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'critChance', value: 0.01 * level }] },
            'r_evade_1': { id: 'r_evade_1', name: 'ë‚ ë µí•œ ëª¸ë†€ë¦¼', description: level => `íšŒí”¼ í™•ë¥ ì´ ë ˆë²¨ë‹¹ 1%ì”© ì¦ê°€í•©ë‹ˆë‹¤. (ì´ +${level}%)`, cost: level => 150 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'evadeChance', value: 0.01 * level }] },
            'r_atk_1': { id: 'r_atk_1', name: 'ë‹¨ê²€ ì—°ë§ˆ', description: level => `ê³µê²©ë ¥ì´ ë ˆë²¨ë‹¹ 2ì”© ì¦ê°€í•©ë‹ˆë‹¤. (ì´ +${level*2})`, cost: level => 120 * (level + 1), requiredPlayerLevel: 3, prerequisites: [{id: 'r_crit_1', level: 1}], effects: level => [{ stat: 'attackPower', value: 2 * level }] },
            'r_execute_1': { id: 'r_execute_1', name: 'ë§ˆë¬´ë¦¬ ì¼ê²©', maxLevel: 1, description: `ì²´ë ¥ì´ 25% ì´í•˜ì¸ ì ì—ê²Œ 20%ì˜ ì¶”ê°€ í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.`, cost: level => 1000, requiredPlayerLevel: 5, prerequisites: [{id: 'r_atk_1', level: 2}], effects: level => [] }, // Special handling
        },
    };

    const ITEM_DATABASE = [
        // Common
        { id: 101, name: "ë…¹ìŠ¨ ê²€", type: 'weapon', stats: { attackPower: 2 }, rarity: 'common', cost: 25, classRestriction: ['ì „ì‚¬'] },
        { id: 102, name: "í•´ì§„ ë¡œë¸Œ", type: 'armor', stats: { maxHp: 10 }, rarity: 'common', cost: 25, classRestriction: ['ë§ˆë²•ì‚¬'] },
        { id: 103, name: "ê°€ì£½ ê°‘ì˜·", type: 'armor', stats: { defense: 1, evadeChance: 0.01 }, rarity: 'common', cost: 25, classRestriction: ['ë„ì '] },
        { id: 104, name: "ë‚˜ë¬´ ì§€íŒ¡ì´", type: 'weapon', stats: { attackPower: 3 }, rarity: 'common', cost: 25, classRestriction: ['ë§ˆë²•ì‚¬'] },
        { id: 105, name: "ì‘ì€ ë‹¨ê²€", type: 'weapon', stats: { attackPower: 1, critChance: 0.02 }, rarity: 'common', cost: 25, classRestriction: ['ë„ì '] },
        { id: 106, name: "íŒê¸ˆ ì¡°ë¼", type: 'armor', stats: { defense: 2 }, rarity: 'common', cost: 25, classRestriction: ['ì „ì‚¬'] },

        // Uncommon
        { id: 201, name: "ê°•ì²  ê²€", type: 'weapon', stats: { attackPower: 5 }, rarity: 'uncommon', cost: 100, classRestriction: ['ì „ì‚¬'] },
        { id: 202, name: "ë§ˆë²•ì‚¬ì˜ ë¡œë¸Œ", type: 'armor', stats: { maxHp: 20, attackPower: 2 }, rarity: 'uncommon', cost: 100, classRestriction: ['ë§ˆë²•ì‚¬'] },
        { id: 203, name: "ê·¸ë¦¼ì ì‚¬ìŠ¬ ê°‘ì˜·", type: 'armor', stats: { defense: 2, maxHp: 10, evadeChance: 0.03 }, rarity: 'uncommon', cost: 100, classRestriction: ['ë„ì '] },
        { id: 204, name: "ë³´ì„ ë°•íŒ ì§€íŒ¡ì´", type: 'weapon', stats: { attackPower: 6 }, rarity: 'uncommon', cost: 100, classRestriction: ['ë§ˆë²•ì‚¬'] },
        { id: 205, name: "ì•”ì‚´ìì˜ ë‹¨ê²€", type: 'weapon', stats: { attackPower: 3, critChance: 0.05 }, rarity: 'uncommon', cost: 100, classRestriction: ['ë„ì '] },
        { id: 206, name: "ê°•ì²  ê°‘ì˜·", type: 'armor', stats: { defense: 4, maxHp: 25 }, rarity: 'uncommon', cost: 100, classRestriction: ['ì „ì‚¬'] },
        
        // Rare
        { id: 301, name: "ë£¬ ë¸”ë ˆì´ë“œ", type: 'weapon', stats: { attackPower: 8, critChance: 0.03 }, rarity: 'rare', cost: 300, classRestriction: ['ì „ì‚¬'] },
        { id: 302, name: "ëŒ€ë§ˆë²•ì‚¬ì˜ ë¡œë¸Œ", type: 'armor', stats: { maxHp: 30, attackPower: 5, defense: 1 }, rarity: 'rare', cost: 300, classRestriction: ['ë§ˆë²•ì‚¬'] },
        { id: 303, name: "ê¸°ì‚¬ì˜ ê°‘ì˜·", type: 'armor', stats: { defense: 5, maxHp: 40 }, rarity: 'rare', cost: 300, classRestriction: ['ì „ì‚¬'] },
        { id: 304, name: "í˜„ìì˜ ì§€íŒ¡ì´", type: 'weapon', stats: { attackPower: 10, maxHp: 20 }, rarity: 'rare', cost: 300, classRestriction: ['ë§ˆë²•ì‚¬'] },
        { id: 305, name: "ë…ì‚¬ì˜ ì†¡ê³³ë‹ˆ", type: 'weapon', stats: { attackPower: 7, critChance: 0.07 }, rarity: 'rare', cost: 300, classRestriction: ['ë„ì '] },
        { id: 306, name: "ë°¤ì˜ ì¥ë§‰ ê°‘ì˜·", type: 'armor', stats: { defense: 3, evadeChance: 0.05, maxHp: 20 }, rarity: 'rare', cost: 300, classRestriction: ['ë„ì '] },
        
        // Legendary
        { id: 401, name: "ìš©ì‚´ìì˜ ëŒ€ê²€", type: 'weapon', stats: { attackPower: 20, maxHp: 50 }, rarity: 'legendary', cost: 5000, classRestriction: ['ì „ì‚¬'] },
        { id: 402, name: "ì•„í¬ë©”ì´ì§€ì˜ ì§€íŒ¡ì´", type: 'weapon', stats: { attackPower: 25 }, rarity: 'legendary', cost: 5000, classRestriction: ['ë§ˆë²•ì‚¬'] },
        { id: 403, name: "ì›”ê´‘ì˜ ë‹¨ê²€", type: 'weapon', stats: { attackPower: 15, critChance: 0.10, evadeChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['ë„ì '] },
        { id: 404, name: "ìˆ˜í˜¸ì‹ ì˜ ê°‘ì£¼", type: 'armor', stats: { defense: 10, maxHp: 100 }, rarity: 'legendary', cost: 5000, classRestriction: ['ì „ì‚¬', 'ë„ì ', 'ë§ˆë²•ì‚¬'] },

        // Accessories
        { id: 501, name: "í˜ì˜ ë°˜ì§€", type: 'accessory', stats: { attackPower: 5 }, rarity: 'rare', cost: 300, classRestriction: ['ì „ì‚¬', 'ë§ˆë²•ì‚¬', 'ë„ì '] },
        { id: 502, name: "í™œë ¥ì˜ ë¶€ì ", type: 'accessory', stats: { maxHp: 50 }, rarity: 'rare', cost: 300, classRestriction: ['ì „ì‚¬', 'ë§ˆë²•ì‚¬', 'ë„ì '] },
        { id: 503, "name": "ìˆ˜í˜¸ì˜ ì§•í‘œ", type: 'accessory', stats: { defense: 5 }, rarity: 'rare', cost: 300, classRestriction: ['ì „ì‚¬', 'ë§ˆë²•ì‚¬', 'ë„ì '] },
        { id: 504, "name": "í•„ì‚´ì˜ ë°˜ì§€", type: 'accessory', stats: { critChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['ì „ì‚¬', 'ë§ˆë²•ì‚¬', 'ë„ì '] },
        { id: 505, "name": "ê·¸ë¦¼ì ë§í† ", type: 'accessory', stats: { evadeChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['ì „ì‚¬', 'ë§ˆë²•ì‚¬', 'ë„ì '] },
        { id: 506, "name": "í˜„ìì˜ ëŒ", type: 'accessory', stats: { attackPower: 8, maxHp: 80 }, rarity: 'legendary', cost: 5000, classRestriction: ['ì „ì‚¬', 'ë§ˆë²•ì‚¬', 'ë„ì '] },
    ];
    
    const ENCHANTMENT_POOL = {
        weapon: {
            common: [ { id: 'w_c_atk', description: 'ê³µê²©ë ¥ +3', effects: { attackPower: 3 } }, { id: 'w_c_crit', description: 'ì¹˜ëª…íƒ€ +1%', effects: { critChance: 0.01 } } ],
            uncommon: [ { id: 'w_u_atk', description: 'ê³µê²©ë ¥ +6', effects: { attackPower: 6 } }, { id: 'w_u_crit', description: 'ì¹˜ëª…íƒ€ +2%', effects: { critChance: 0.02 } } ],
            rare: [ { id: 'w_r_atk', description: 'ê³µê²©ë ¥ +10', effects: { attackPower: 10 } }, { id: 'w_r_crit', description: 'ì¹˜ëª…íƒ€ +4%', effects: { critChance: 0.04 } } ],
            legendary: [ { id: 'w_l_atk', description: 'ê³µê²©ë ¥ +25', effects: { attackPower: 25 } }, { id: 'w_l_crit', description: 'ì¹˜ëª…íƒ€ +8%', effects: { critChance: 0.08 } }, { id: 'w_l_all', description: 'ê³µê²©ë ¥ +10, ì¹˜ëª…íƒ€ +3%', effects: { attackPower: 10, critChance: 0.03 } } ]
        },
        armor: {
            common: [ { id: 'a_c_hp', description: 'ìµœëŒ€ HP +15', effects: { maxHp: 15 } }, { id: 'a_c_def', description: 'ë°©ì–´ë ¥ +2', effects: { defense: 2 } } ],
            uncommon: [ { id: 'a_u_hp', description: 'ìµœëŒ€ HP +30', effects: { maxHp: 30 } }, { id: 'a_u_def', description: 'ë°©ì–´ë ¥ +4', effects: { defense: 4 } }, { id: 'a_u_evade', description: 'íšŒí”¼ +1%', effects: { evadeChance: 0.01 } } ],
            rare: [ { id: 'a_r_hp', description: 'ìµœëŒ€ HP +50', effects: { maxHp: 50 } }, { id: 'a_r_def', description: 'ë°©ì–´ë ¥ +7', effects: { defense: 7 } }, { id: 'a_r_evade', description: 'íšŒí”¼ +2%', effects: { evadeChance: 0.02 } } ],
            legendary: [ { id: 'a_l_hp', description: 'ìµœëŒ€ HP +120', effects: { maxHp: 120 } }, { id: 'a_l_def', description: 'ë°©ì–´ë ¥ +15', effects: { defense: 15 } }, { id: 'a_l_evade', description: 'íšŒí”¼ +5%', effects: { evadeChance: 0.05 } } ]
        },
        accessory: {
            rare: [ { id: 'ac_r_atk', description: 'ê³µê²©ë ¥ +8', effects: { attackPower: 8 } }, { id: 'ac_r_hp', description: 'ìµœëŒ€ HP +40', effects: { maxHp: 40 } } ],
            legendary: [ { id: 'ac_l_crit', description: 'ì¹˜ëª…íƒ€ +3%', effects: { critChance: 0.03 } }, { id: 'ac_l_evade', description: 'íšŒí”¼ +3%', effects: { evadeChance: 0.03 } }, { id: 'ac_l_all', description: 'ê³µê²©ë ¥ +5, ë°©ì–´ë ¥ +5', effects: { attackPower: 5, defense: 5 } } ]
        }
    };

    const QUEST_POOL = [
        { type: 'KILL_MONSTERS', description: (n) => `ëª¬ìŠ¤í„° ${n}ë§ˆë¦¬ ì²˜ì¹˜`, targets: [10, 15, 20], reward: { gold: 150, stones: 3 } },
        { type: 'CLEAR_DUNGEON', description: (n) => `ë˜ì „ ${n}íšŒ í´ë¦¬ì–´`, targets: [1, 2], reward: { gold: 250, potions: 1 } },
        { type: 'ENHANCE_ATTEMPTS', description: (n) => `ì¥ë¹„ ê°•í™” ${n}íšŒ ì‹œë„`, targets: [3, 5], reward: { gold: 200, stones: 5 } },
        { type: 'USE_ULTIMATE', description: (n) => `íŠ¹ìˆ˜ ê¸°ìˆ  ${n}íšŒ ì‚¬ìš©`, targets: [5, 8], reward: { gold: 100, potions: 1 } },
        { type: 'EARN_GOLD', description: (n) => `ê³¨ë“œ ${n} íšë“`, targets: [500, 1000], reward: { gold: 100, stones: 2 } },
    ];
    
    const PERMANENT_QUESTS_DATA = [
      { id: 'reach_level_10', type: 'REACH_LEVEL', description: 'ë ˆë²¨ 10 ë‹¬ì„±', target: 10, reward: { gold: 1000, stones: 10 } },
      { id: 'reach_level_20', type: 'REACH_LEVEL', description: 'ë ˆë²¨ 20 ë‹¬ì„±', target: 20, reward: { gold: 5000, stones: 25 } },
      { id: 'defeat_dragon', type: 'DEFEAT_BOSS', description: 'ë“œë˜ê³¤ ì²˜ì¹˜', targetName: 'ë“œë˜ê³¤', target: 1, reward: { gold: 3000, potions: 5 } },
      { id: 'enhance_10', type: 'ENHANCE_SUCCESS', description: 'ì¥ë¹„ +10ê°• ì„±ê³µ', target: 10, reward: { gold: 2000, dust: 100 } },
      { id: 'collect_gold_50k', type: 'COLLECT_GOLD', description: 'ì´ 50,000ê³¨ë“œ ìˆ˜ì§‘', target: 50000, reward: { stones: 20, potions: 3 } },
      { id: 'first_rebirth', type: 'REBIRTH', description: 'ì²« í™˜ìƒ ë‹¬ì„±', target: 1, reward: { stones: 50, dust: 250 } },
    ];
    
    const REBIRTH_UPGRADES = {
        'gold_gain': { name: 'ê³¨ë“œ íšë“ëŸ‰ ì¦ê°€', description: level => `ê³¨ë“œ íšë“ëŸ‰ì´ ì˜êµ¬ì ìœ¼ë¡œ ${level * 5}% ì¦ê°€í•©ë‹ˆë‹¤.`, cost: level => (level + 1) },
        'xp_gain': { name: 'ê²½í—˜ì¹˜ íšë“ëŸ‰ ì¦ê°€', description: level => `ê²½í—˜ì¹˜ íšë“ëŸ‰ì´ ì˜êµ¬ì ìœ¼ë¡œ ${level * 5}% ì¦ê°€í•©ë‹ˆë‹¤.`, cost: level => (level + 1) },
        'base_atk': { name: 'ê¸°ë³¸ ê³µê²©ë ¥ ì¦ê°€', description: level => `ëª¨ë“  ì§ì—…ì˜ ê¸°ë³¸ ê³µê²©ë ¥ì´ ì˜êµ¬ì ìœ¼ë¡œ ${level * 2} ì¦ê°€í•©ë‹ˆë‹¤.`, cost: level => (level + 1) * 2 },
        'base_hp': { name: 'ê¸°ë³¸ ìƒëª…ë ¥ ì¦ê°€', description: level => `ëª¨ë“  ì§ì—…ì˜ ê¸°ë³¸ ìƒëª…ë ¥ì´ ì˜êµ¬ì ìœ¼ë¡œ ${level * 10} ì¦ê°€í•©ë‹ˆë‹¤.`, cost: level => (level + 1) * 2 },
        'ultimate_cooldown': { name: 'ê¶ê·¹ì˜ ê¸°ìˆ  ì—°ë§ˆ', maxLevel: 4, description: level => `ê¶ê·¹ê¸° ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ì´ ì˜êµ¬ì ìœ¼ë¡œ ${level * 5}% ê°ì†Œí•©ë‹ˆë‹¤. (í˜„ì¬: -${level*5}%)`, cost: level => (level + 1) * 3 }
    };


    let player;
    let monster;
    let messageLog;
    let currentScreen;
    let currentDifficulty;
    let dungeonLevel;
    let dungeonFloor;
    let isSellMode = false;
    let dailyQuests = [];
    let lastQuestDate = '';
    let shopFilterType = 'all';
    let shopFilterRarity = 'all';
    let blacksmithMode = 'enhance';
    let questScreenMode = 'daily';
    let guideElementsRendered = false;
    
    let survivalWave = 0;


    const monsterList = [
        { name: 'ìŠ¬ë¼ì„', emoji: 'ğŸ’§', baseHp: 20, baseAttack: 5, xp: 25, gold: 5, lootTable: [102, 105] },
        { name: 'ê³ ë¸”ë¦°', emoji: 'ğŸ‘º', baseHp: 30, baseAttack: 7, xp: 40, gold: 10, lootTable: [101, 103, 105], onHitEffect: {type: 'weaken', chance: 0.2, duration: 2, potency: 0.1} },
        { name: 'ì˜¤í¬', emoji: 'ğŸ‘¹', baseHp: 45, baseAttack: 11, xp: 60, gold: 15, lootTable: [101, 106, 201] },
        { name: 'ë…ê±°ë¯¸', emoji: 'ğŸ•·ï¸', baseHp: 55, baseAttack: 12, xp: 75, gold: 20, lootTable: [205, 203], onHitEffect: {type: 'poison', chance: 0.4, duration: 3, potency: 4} },
        { name: 'ìŠ¤ì¼ˆë ˆí†¤', emoji: 'ğŸ’€', baseHp: 65, baseAttack: 14, xp: 85, gold: 25, lootTable: [201, 206] },
    ];

    const bossList = [
        { name: 'ë™êµ´ íŠ¸ë¡¤', emoji: 'ğŸ—¿', baseHp: 100, baseAttack: 18, xp: 200, gold: 100, lootTable: [201, 206, 205], onHitEffect: {type: 'stun', chance: 0.2, duration: 1, potency: 0} },
        { name: 'ê±°ëŒ€ ê³¨ë ˜', emoji: 'ğŸ¤–', baseHp: 150, baseAttack: 23, xp: 300, gold: 150, lootTable: [202, 204, 303], onHitEffect: {type: 'vulnerable', chance: 0.5, duration: 2, potency: 0.25} },
        { name: 'í‘ê¸°ì‚¬', emoji: 'â™', baseHp: 200, baseAttack: 28, xp: 450, gold: 220, lootTable: [301, 303], onHitEffect: {type: 'weaken', chance: 0.4, duration: 3, potency: 0.2} },
        { name: 'ë“œë˜ê³¤', emoji: 'ğŸ²', baseHp: 270, baseAttack: 34, xp: 600, gold: 300, lootTable: [301, 302], onHitEffect: {type: 'burn', chance: 0.7, duration: 3, potency: 15} },
    ];

    function removeGuideElements() {
        document.getElementById('guide-button')?.remove();
        document.getElementById('guide-modal')?.remove();
        guideElementsRendered = false;
    }

    function renderGuideElements() {
        if (guideElementsRendered) return;

        const guideButton = document.createElement('button');
        guideButton.id = 'guide-button';
        guideButton.textContent = 'â“';
        guideButton.title = 'ì´ˆë³´ì ê°€ì´ë“œ';

        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'guide-modal';
        modalOverlay.className = 'modal-overlay';
        modalOverlay.innerHTML = `
            <div class="modal-content">
                <h2>ì´ˆë³´ì ê°€ì´ë“œ</h2>
                <div class="modal-body">
                    <h3>ê²Œì„ ëª©í‘œ</h3>
                    <p>ë˜ì „ì— ì…ì¥í•˜ì—¬ ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í•˜ê³ , ë” ì¢‹ì€ ì¥ë¹„ë¥¼ íšë“í•˜ì—¬ ìºë¦­í„°ë¥¼ ì„±ì¥ì‹œí‚¤ì„¸ìš”. ìµœì¢… ëª©í‘œëŠ” ë” ë†’ì€ ë ˆë²¨ì˜ ë˜ì „ì„ í´ë¦¬ì–´í•˜ê³ , í™˜ìƒì„ í†µí•´ ì˜êµ¬ì ìœ¼ë¡œ ê°•í•´ì§€ëŠ” ê²ƒì…ë‹ˆë‹¤.</p>
                    
                    <h3>ì „íˆ¬</h3>
                    <ul>
                        <li><strong>ê³µê²©:</strong> ê¸°ë³¸ ê³µê²©ìœ¼ë¡œ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.</li>
                        <li><strong>ë¬¼ì•½:</strong> ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤. ìƒì ì—ì„œ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li><strong>íŠ¹ìˆ˜ ê¸°ìˆ :</strong> ì§ì—…ë§ˆë‹¤ ê³ ìœ ì˜ ê°•ë ¥í•œ ê¸°ìˆ ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì‚¬ìš© í›„ì—ëŠ” ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ì´ ìˆìŠµë‹ˆë‹¤.</li>
                        <li><strong>ìƒíƒœ ì´ìƒ:</strong> ë…, í™”ìƒ, ê¸°ì ˆ ë“± ë‹¤ì–‘í•œ íš¨ê³¼ê°€ ì „íˆ¬ì— ì˜í–¥ì„ ì¤ë‹ˆë‹¤. ëª¬ìŠ¤í„°ì™€ í”Œë ˆì´ì–´ ëª¨ë‘ì—ê²Œ ì ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    </ul>

                    <h3>ì„±ì¥ê³¼ ì¥ë¹„</h3>
                    <ul>
                        <li><strong>ë ˆë²¨ì—…:</strong> ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í•˜ì—¬ ê²½í—˜ì¹˜(XP)ë¥¼ ì–»ê³  ë ˆë²¨ì„ ì˜¬ë¦½ë‹ˆë‹¤.</li>
                        <li><strong>ì¥ë¹„ ë“±ê¸‰:</strong> ì¼ë°˜(í°ìƒ‰) &lt; ê³ ê¸‰(ì´ˆë¡ìƒ‰) &lt; í¬ê·€(íŒŒë€ìƒ‰) &lt; ì „ì„¤(ì£¼í™©ìƒ‰) ìˆœìœ¼ë¡œ ê°•ë ¥í•©ë‹ˆë‹¤.</li>
                        <li><strong>ì¥ë¹„ ê´€ë¦¬:</strong> 'ì¥ë¹„' ë©”ë‰´ì—ì„œ ì•„ì´í…œì„ ì¥ì°©í•˜ê±°ë‚˜ íŒë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    </ul>

                    <h3>ëŒ€ì¥ê°„</h3>
                    <ul>
                        <li><strong>ê°•í™”:</strong> ê³¨ë“œì™€ ê°•í™”ì„ì„ ì‚¬ìš©í•˜ì—¬ ì¥ë¹„ì˜ ê¸°ë³¸ ëŠ¥ë ¥ì¹˜ë¥¼ ì˜¬ë¦½ë‹ˆë‹¤. ê°•í™” ë ˆë²¨ì´ ë†’ì„ìˆ˜ë¡ ì„±ê³µ í™•ë¥ ì´ ê°ì†Œí•˜ë©°, ì‹¤íŒ¨ ì‹œ íŒ¨ë„í‹°ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li><strong>ë¶„í•´:</strong> í•„ìš” ì—†ëŠ” ì¥ë¹„ë¥¼ ë¶„í•´í•˜ì—¬ ê°•í™”ì„ê³¼ ë§ˆë²• ë¶€ì—¬ ê°€ë£¨ë¥¼ ì–»ìŠµë‹ˆë‹¤.</li>
                        <li><strong>ë§ˆë²• ë¶€ì—¬:</strong> ë§ˆë²• ë¶€ì—¬ ê°€ë£¨ì™€ ê³¨ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì¥ë¹„ì— ë¬´ì‘ìœ„ ì¶”ê°€ ì˜µì…˜ì„ ë¶€ì—¬í•©ë‹ˆë‹¤.</li>
                    </ul>

                    <h3>ìŠ¤í‚¬ê³¼ í™˜ìƒ</h3>
                    <ul>
                        <li><strong>ìŠ¤í‚¬ íŠ¸ë¦¬:</strong> ê³¨ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì§ì—…ë³„ íŒ¨ì‹œë¸Œ ìŠ¤í‚¬ì„ ë°°ì›Œ ìºë¦­í„°ë¥¼ íŠ¹í™”ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li><strong>í™˜ìƒ:</strong> 30ë ˆë²¨ì— ë„ë‹¬í•˜ë©´ í™˜ìƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ë ˆë²¨, ê³¨ë“œ ë“±ì´ ì´ˆê¸°í™”ë˜ì§€ë§Œ, 'í™˜ìƒ í¬ì¸íŠ¸(RP)'ë¥¼ ì–»ì–´ ì˜êµ¬ì ì¸ ëŠ¥ë ¥ì¹˜ë¥¼ ì˜¬ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¥ë¹„ì™€ ì•„ì´í…œì€ ìœ ì§€ë©ë‹ˆë‹¤.</li>
                    </ul>

                    <h3>ê¸°íƒ€ ì½˜í…ì¸ </h3>
                    <ul>
                        <li><strong>í€˜ìŠ¤íŠ¸:</strong> ì¼ì¼/ì˜êµ¬ í€˜ìŠ¤íŠ¸ë¥¼ ì™„ë£Œí•˜ê³  ë³´ìƒì„ ë°›ìœ¼ì„¸ìš”.</li>
                        <li><strong>ì„œë°”ì´ë²Œ ë˜ì „:</strong> ëì—†ì´ ëª°ë ¤ì˜¤ëŠ” ëª¬ìŠ¤í„°ë¥¼ ìƒëŒ€ë¡œ ìµœëŒ€í•œ ì˜¤ë˜ ë²„í‹°ê³  ê³¨ë“œë¥¼ íšë“í•˜ì„¸ìš”. ë†’ì€ ì›¨ì´ë¸Œë¥¼ ë‹¬ì„±í• ìˆ˜ë¡ ë” ë§ì€ ê³¨ë“œë¥¼ ì–»ìŠµë‹ˆë‹¤.</li>
                    </ul>
                </div>
                <div class="modal-footer">
                    <button id="close-guide-button" class="button">ë‹«ê¸°</button>
                </div>
            </div>
        `;

        document.body.appendChild(guideButton);
        document.body.appendChild(modalOverlay);

        guideButton.addEventListener('click', () => {
            modalOverlay.style.display = 'flex';
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.style.display = 'none';
            }
        });
        
        document.getElementById('close-guide-button')?.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });
        
        guideElementsRendered = true;
    }


    function createStartScreen() {
      currentScreen = 'START';
      root.innerHTML = `
        <div class="screen-container">
          <h1 class="logo">âš”ï¸ ê°„ë‹¨RPG ğŸ›¡ï¸</h1>
          <p>ì§ì—…ì„ ì„ íƒí•˜ê³ , ì¥ë¹„ë¥¼ ê°•í™”í•˜ì—¬ ë˜ì „ì„ ì •ë³µí•˜ì„¸ìš”!</p>
          <button id="start-button" class="button">ê²Œì„ ì‹œì‘</button>
        </div>
      `;
      document.getElementById('start-button')?.addEventListener('click', createDifficultySelectionScreen);
      renderGuideElements();
    }

    function createItemInstance(itemId) {
        const itemData = ITEM_DATABASE.find(i => i.id === itemId);
        if (!itemData) return null;

        const newItem = JSON.parse(JSON.stringify(itemData));
        newItem.enhancementLevel = 0;
        newItem.enchantment = null;
        return newItem;
    }

    function createDifficultySelectionScreen() {
        currentScreen = 'DIFFICULTY_SELECTION';
        root.innerHTML = `
            <div class="screen-container">
                <h1>ë‚œì´ë„ ì„ íƒ</h1>
                <p>ëª¨í—˜ì˜ ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
                <div class="difficulty-selection">
                    <button class="difficulty-card" data-difficulty="ì‰¬ì›€">
                        <h2>ì‰¬ì›€</h2>
                        <p>ëª¬ìŠ¤í„°ê°€ ì•½í•´ì§€ê³ , ë” ë§ì€ ìì›ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤. í¸ì•ˆí•œ í”Œë ˆì´ì— ì í•©í•©ë‹ˆë‹¤.</p>
                    </button>
                    <button class="difficulty-card" data-difficulty="ë³´í†µ">
                        <h2>ë³´í†µ</h2>
                        <p>í‘œì¤€ì ì¸ RPG ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤.</p>
                    </button>
                    <button class="difficulty-card" data-difficulty="ì–´ë ¤ì›€">
                        <h2>ì–´ë ¤ì›€</h2>
                        <p>ëª¬ìŠ¤í„°ê°€ ë§¤ìš° ê°•ë ¥í•©ë‹ˆë‹¤. ë³´ìƒì´ í¬ì§€ë§Œ, ìƒë‹¹í•œ ë„ì „ì„ ìš”êµ¬í•©ë‹ˆë‹¤.</p>
                    </button>
                </div>
            </div>
        `;

        document.querySelectorAll('.difficulty-card').forEach(card => {
            card.addEventListener('click', (e) => {
                currentDifficulty = e.currentTarget.dataset.difficulty;
                createClassSelectionScreen();
            });
        });
        renderGuideElements();
    }

    function renderDifficultyChangeScreen() {
      currentScreen = 'DIFFICULTY_CHANGE';
      root.innerHTML = `
        <div class="screen-container">
          <h1>ë‚œì´ë„ ë³€ê²½</h1>
          <p>ë³€ê²½í•  ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”. ë‹¤ìŒ ë˜ì „ë¶€í„° ì ìš©ë©ë‹ˆë‹¤. (í˜„ì¬: ${currentDifficulty})</p>
          <div class="difficulty-selection">
            <button class="difficulty-card" data-difficulty="ì‰¬ì›€"><h2>ì‰¬ì›€</h2><p>í¸ì•ˆí•œ í”Œë ˆì´.</p></button>
            <button class="difficulty-card" data-difficulty="ë³´í†µ"><h2>ë³´í†µ</h2><p>í‘œì¤€ì ì¸ ê²½í—˜.</p></button>
            <button class="difficulty-card" data-difficulty="ì–´ë ¤ì›€"><h2>ì–´ë ¤ì›€</h2><p>ë” í° ë„ì „ê³¼ ë³´ìƒ.</p></button>
          </div>
          <button id="back-to-town" class="button" style="margin-top: 1rem; width: 100%;">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
        </div>
      `;
      document.querySelectorAll('.difficulty-card').forEach(card => {
        card.addEventListener('click', (e) => {
          const newDifficulty = e.currentTarget.dataset.difficulty;
          if (newDifficulty !== currentDifficulty) {
            currentDifficulty = newDifficulty;
            saveGameState();
            alert(`ë‚œì´ë„ê°€ ${newDifficulty}(ìœ¼)ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`);
          }
          renderTownScreen();
        });
      });
      document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }


    function createClassSelectionScreen() {
        currentScreen = 'CLASS_SELECTION';
        root.innerHTML = `
            <div class="screen-container">
                <h1>ì§ì—… ì„ íƒ</h1>
                <p>ëª¨í—˜ì„ í•¨ê»˜í•  ë‹¹ì‹ ì˜ ì§ì—…ì„ ì„ íƒí•˜ì„¸ìš”.</p>
                <div class="class-selection">
                    <button class="class-card" data-class="ì „ì‚¬">
                        <h2>ì „ì‚¬ ğŸ›¡ï¸</h2>
                        <p>ë†’ì€ ì²´ë ¥ê³¼ ë°©ì–´ë ¥. ì ì„ ì•½í™”ì‹œí‚¤ê³  ë²„í‹°ëŠ” ì „íˆ¬ë¥¼ ì´ëŒì–´ê°‘ë‹ˆë‹¤.</p>
                    </button>
                    <button class="class-card" data-class="ë§ˆë²•ì‚¬">
                        <h2>ë§ˆë²•ì‚¬ ğŸ”¥</h2>
                        <p>ê°•ë ¥í•œ ì›ì†Œ ë§ˆë²•ìœ¼ë¡œ ì ì„ ë¶ˆíƒœìš°ê±°ë‚˜ ì–¼ë¦½ë‹ˆë‹¤.</p>
                    </button>
                    <button class="class-card" data-class="ë„ì ">
                        <h2>ë„ì  ğŸ’¨</h2>
                        <p>ë§¹ë…ê³¼ ë†’ì€ íšŒí”¼ìœ¨ë¡œ ì ì„ ì„œì„œíˆ ë¬´ë„ˆëœ¨ë¦½ë‹ˆë‹¤.</p>
                    </button>
                </div>
            </div>
        `;

        document.querySelectorAll('.class-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const selectedClass = e.currentTarget.dataset.class;
                const playerName = prompt("ìš©ì‚¬ë‹˜ì˜ ì´ë¦„ì€ ë¬´ì—‡ì…ë‹ˆê¹Œ?", "ìš©ì‚¬") || "ìš©ì‚¬";
                 if (selectedClass) {
                    initializeGame(selectedClass, playerName);
                }
            });
        });
        renderGuideElements();
    }

    function createClassChangeScreen() {
        currentScreen = 'CLASS_SELECTION';
        root.innerHTML = `
            <div class="screen-container">
                <h1>ì§ì—… ë³€ê²½</h1>
                <p>ìƒˆë¡œìš´ ì§ì—…ì„ ì„ íƒí•˜ì„¸ìš”. ê¸°ì¡´ ì§ì—…ê³¼ ë‹¤ë¥¸ ì§ì—…ì„ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.</p>
                <div class="class-selection">
                    <button class="class-card" data-class="ì „ì‚¬" ${player.className === 'ì „ì‚¬' ? 'disabled' : ''}>
                        <h2>ì „ì‚¬ ğŸ›¡ï¸</h2>
                        <p>ë†’ì€ ì²´ë ¥ê³¼ ë°©ì–´ë ¥. ì ì„ ì•½í™”ì‹œí‚¤ê³  ë²„í‹°ëŠ” ì „íˆ¬ë¥¼ ì´ëŒì–´ê°‘ë‹ˆë‹¤.</p>
                    </button>
                    <button class="class-card" data-class="ë§ˆë²•ì‚¬" ${player.className === 'ë§ˆë²•ì‚¬' ? 'disabled' : ''}>
                        <h2>ë§ˆë²•ì‚¬ ğŸ”¥</h2>
                        <p>ê°•ë ¥í•œ ì›ì†Œ ë§ˆë²•ìœ¼ë¡œ ì ì„ ë¶ˆíƒœìš°ê±°ë‚˜ ì–¼ë¦½ë‹ˆë‹¤.</p>
                    </button>
                    <button class="class-card" data-class="ë„ì " ${player.className === 'ë„ì ' ? 'disabled' : ''}>
                        <h2>ë„ì  ğŸ’¨</h2>
                        <p>ë§¹ë…ê³¼ ë†’ì€ íšŒí”¼ìœ¨ë¡œ ì ì„ ì„œì„œíˆ ë¬´ë„ˆëœ¨ë¦½ë‹ˆë‹¤.</p>
                    </button>
                </div>
                <button id="back-to-town" class="button" style="margin-top: 1rem; width: 100%;">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
            </div>
        `;

        document.querySelectorAll('.class-card:not([disabled])').forEach(card => {
            card.addEventListener('click', (e) => {
                const newClass = e.currentTarget.dataset.class;
                if (newClass && player.gold >= CLASS_CHANGE_COST) {
                    player.gold -= CLASS_CHANGE_COST;
                    handleChangeClass(newClass);
                }
            });
        });
        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }

    function handleChangeClass(newClass) {
        const classData = CLASSES[newClass];
        
        player.className = newClass;
        player.weaponName = classData.weapon;
        
        player.ultimateSkillLevel = 1;
        player.ultimateSkillCooldown = 0;
        player.unlockedSkills = {};
        
        Object.keys(player.equipment).forEach(slot => {
            const item = player.equipment[slot];
            if (item && !item.classRestriction.includes(newClass)) {
                unequipItem(slot);
            }
        });
        
        recalculatePlayerStats();
        player.hp = player.maxHp;

        messageLog.unshift(`âœ¨ ì§ì—…ì„ ${newClass}(ìœ¼)ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤!`);
        renderTownScreen();
    }

    function initializeGame(chosenClass, playerName) {
      removeGuideElements();
      dungeonLevel = 1;

      const classData = CLASSES[chosenClass];
      const difficultySettings = DIFFICULTY_SETTINGS[currentDifficulty];
      
      const permanentQuests = JSON.parse(JSON.stringify(PERMANENT_QUESTS_DATA)).map(q => ({...q, progress: 0, isComplete: false, isClaimed: false }));
      const rebirthUpgrades = {};
      Object.keys(REBIRTH_UPGRADES).forEach(key => rebirthUpgrades[key] = 0);
      
      player = {
        name: playerName,
        className: chosenClass,
        weaponName: classData.weapon,
        level: 1,
        xp: 0,
        xpToNextLevel: 100,
        gold: difficultySettings.startGold,
        enhancementStones: 0,
        enchantmentDust: 0,
        survivalHighScore: 0,
        potions: difficultySettings.startPotions,
        ultimateSkillLevel: 1,
        ultimateSkillCooldown: 0,
        activeBuffs: [],
        statusEffects: [],
        equipment: { weapon: null, armor: null, accessory: null },
        inventory: [],
        unlockedSkills: {},
        permanentQuests,
        rebirths: 0,
        rebirthPoints: 0,
        rebirthUpgrades,
        baseStats: {},
        hp: 0, maxHp: 0, attackPower: 0, defense: 0, 
        critChance: 0, evadeChance: 0
      };
      recalculatePlayerStats();
      player.hp = player.maxHp;
      messageLog = ['ë§ˆì„ì— ë„ì°©í–ˆë‹¤. ëª¨í—˜ì„ ì¤€ë¹„í•˜ì.'];
      generateDailyQuests();
      saveGameState();
      renderTownScreen();
    }

    function recalculatePlayerStats() {
        const p = player;
        const classData = CLASSES[p.className];
        
        const tempStats = {
            maxHp: classData.baseHp,
            attackPower: classData.baseAtk,
            defense: classData.baseDef,
            critChance: classData.crit,
            evadeChance: classData.evade,
        };
        
        // Rebirth Upgrades
        tempStats.maxHp += (p.rebirthUpgrades.base_hp || 0) * 10;
        tempStats.attackPower += (p.rebirthUpgrades.base_atk || 0) * 2;
        
        p.baseStats = { ...tempStats }; // Save base stats after rebirth mods
        
        Object.values(p.equipment).forEach(item => {
            if (item) {
                Object.entries(item.stats).forEach(([stat, value]) => {
                    if (stat in tempStats) {
                        tempStats[stat] += value;
                    }
                });
                if (item.enchantment) {
                     Object.entries(item.enchantment.effects).forEach(([stat, value]) => {
                        if (stat in tempStats) {
                            tempStats[stat] += value;
                        }
                    });
                }
            }
        });

        const classSkills = SKILL_DATA[p.className];
        Object.entries(p.unlockedSkills).forEach(([skillId, level]) => {
            const skill = classSkills[skillId];
            if (skill) {
                skill.effects(level).forEach(effect => {
                    if (effect.stat in tempStats) {
                         tempStats[effect.stat] += effect.value;
                    }
                });
            }
        });

        p.maxHp = tempStats.maxHp;
        p.attackPower = tempStats.attackPower;
        p.defense = tempStats.defense;
        p.critChance = tempStats.critChance;
        p.evadeChance = tempStats.evadeChance;

        let buffAtkPercent = 0;
        let buffDefPercent = 0;
        p.activeBuffs.forEach(buff => {
            const b = buff.effect;
            if (!b) return;
            if (b.isPercent) {
                if (b.stat === 'attackPower') buffAtkPercent += b.value;
                if (b.stat === 'defense') {
                    let bonus = b.value;
                    if (p.unlockedSkills['w_ult_1']) {
                        bonus += p.unlockedSkills['w_ult_1'] * 0.05;
                    }
                    buffDefPercent += bonus;
                }
            } else {
                 p[b.stat] += b.value;
            }
        });
        
        p.attackPower = Math.floor(p.attackPower * (1 + buffAtkPercent));
        p.defense = Math.floor(p.defense * (1 + buffDefPercent));
        
        p.statusEffects.forEach(se => {
            if (se.type === 'weaken') p.attackPower = Math.floor(p.attackPower * (1 - se.potency));
            if (se.type === 'vulnerable') p.defense = Math.floor(p.defense * (1 - se.potency));
        });

        p.hp = Math.min(p.hp, p.maxHp);
    }

    function getFloorsForDungeon(level) {
        return 3 + Math.floor((level - 1) / 3);
    }

    function renderTownScreen() {
        removeGuideElements();
        currentScreen = 'TOWN';
        const canAffordClassChange = player.gold >= CLASS_CHANGE_COST;
        const hasClaimableQuests = dailyQuests.some(q => q.isComplete && !q.isClaimed) || player.permanentQuests.some(q => q.isComplete && !q.isClaimed);
        const canRebirth = player.level >= REBIRTH_LEVEL_REQ;

        root.innerHTML = `
            <div class="screen-container town-screen">
                <p>í˜„ì¬ ë„ì „í•  ë˜ì „: ${dungeonLevel} ë ˆë²¨ (í™˜ìƒ: ${player.rebirths}íšŒ) | ë‚œì´ë„: ${currentDifficulty}</p>
                ${createCharacterCard(player, true)}
                <div id="action-buttons" class="town-actions">
                    <button data-action="dungeon" class="button">ë˜ì „ ì…ì¥</button>
                    <button data-action="survival-dungeon" class="button">ì„œë°”ì´ë²Œ ë˜ì „</button>
                    <button data-action="quests" class="button quest-button">
                        í€˜ìŠ¤íŠ¸
                        ${hasClaimableQuests ? '<span class="notification-badge">!</span>' : ''}
                    </button>
                    <button data-action="shop" class="button">ìƒì </button>
                    <button data-action="equipment" class="button">ì¥ë¹„</button>
                    <button data-action="blacksmith" class="button">ëŒ€ì¥ê°„</button>
                    <button data-action="skill-tree" class="button">ìŠ¤í‚¬ íŠ¸ë¦¬</button>
                    <button data-action="class-change" class="button" ${!canAffordClassChange ? 'disabled' : ''}>ì§ì—… ë³€ê²½</button>
                    <button data-action="difficulty-change" class="button">ë‚œì´ë„ ë³€ê²½</button>
                    <button data-action="rebirth" class="button" style="color: ${canRebirth ? 'var(--rebirth-color)' : 'inherit'};" ${!canRebirth ? 'disabled' : ''}>í™˜ìƒ ${!canRebirth ? `(${player.level}/${REBIRTH_LEVEL_REQ})` : ''}</button>
                </div>
            </div>
        `;

        document.getElementById('action-buttons')?.addEventListener('click', (e) => {
            const target = e.target;
            const button = target.closest('button');
            if (!button || button.disabled) return;

            switch(button.dataset.action) {
                case 'dungeon': startDungeon(); break;
                case 'survival-dungeon': startSurvivalDungeon(); break;
                case 'shop': renderShopScreen(); break;
                case 'equipment': renderEquipmentScreen(); break;
                case 'blacksmith': renderBlacksmithScreen(); break;
                case 'skill-tree': renderSkillTreeScreen(); break;
                case 'quests': renderQuestScreen(); break;
                case 'rebirth': renderRebirthScreen(); break;
                case 'class-change':
                    if (confirm(`ì§ì—…ì„ ë³€ê²½í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ${CLASS_CHANGE_COST} ê³¨ë“œê°€ ì†Œëª¨ë˜ë©°, ëª¨ë“  ìŠ¤í‚¬ì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.`)) {
                        createClassChangeScreen();
                    }
                    break;
                case 'difficulty-change':
                    renderDifficultyChangeScreen();
                    break;
            }
        });
    }

    function startDungeon() {
        dungeonFloor = 1;
        messageLog = [`ë˜ì „ ${dungeonLevel} - ${dungeonFloor}ì¸µì— ì§„ì…í–ˆë‹¤.`];
        spawnMonster();
        renderDungeonScreen();
    }

    function spawnMonster() {
        const floors = getFloorsForDungeon(dungeonLevel);
        const isBossFloor = dungeonFloor === floors;
        let monsterData;

        if (isBossFloor) {
            monsterData = bossList[Math.min(dungeonLevel - 1, bossList.length - 1)];
        } else {
            const monsterPool = monsterList.slice(0, Math.min(monsterList.length, dungeonLevel + 1));
            const monsterIndex = Math.floor(Math.random() * monsterPool.length);
            monsterData = monsterPool[monsterIndex];
        }
        
        const difficulty = DIFFICULTY_SETTINGS[currentDifficulty];
        const levelModifier = Math.pow(1.15, dungeonLevel - 1);
        
        monster = {
            name: isBossFloor ? `ğŸ‘‘ ${monsterData.name}` : monsterData.name,
            emoji: monsterData.emoji,
            maxHp: Math.floor(monsterData.baseHp * levelModifier * difficulty.monsterHpMod),
            hp: Math.floor(monsterData.baseHp * levelModifier * difficulty.monsterHpMod),
            attackPower: Math.floor(monsterData.baseAttack * levelModifier * difficulty.monsterAtkMod),
            defense: 0,
            statusEffects: [],
        };
    }

    function getItemDisplayName(item) {
        if (!item) return 'ì—†ìŒ';
        return `${item.name}${item.enhancementLevel > 0 ? ` +${item.enhancementLevel}` : ''}`;
    }

    function createCharacterCard(character, isPlayer) {
        const hpPercentage = (character.hp / character.maxHp) * 100;

        const statusEffectsHtml = character.statusEffects.map(se => {
            const def = STATUS_EFFECT_DEFINITIONS[se.type];
            return `<span class="status-effect-icon" title="${def.name}: ${se.duration}í„´ ë‚¨ìŒ">${def.icon}(${se.duration})</span>`;
        }).join('');

        if (isPlayer && 'className' in character) {
            const p = character;
            const ultimateSkill = ULTIMATE_SKILLS[p.className];
            const xpPercentage = (p.xp / p.xpToNextLevel) * 100;
            const floors = getFloorsForDungeon(dungeonLevel);
            const dungeonInfo = currentScreen === 'DUNGEON'
                ? `<p class="dungeon-progress">ë˜ì „ ${dungeonLevel} - ${dungeonFloor}/${floors}ì¸µ</p>`
                : '';
            
            const buffsHtml = p.activeBuffs.map(buff => 
                `<span class="buff-icon" title="${buff.name}: ${buff.duration}í„´ ë‚¨ìŒ">${buff.name.substring(0,2)}(${buff.duration})</span>`
            ).join('');
            
            const equipmentHtml = `
                <div class="player-equipment">
                    <span>âš”ï¸ ${getItemDisplayName(p.equipment.weapon)}</span>
                    <span>ğŸ›¡ï¸ ${getItemDisplayName(p.equipment.armor)}</span>
                    <span>ğŸ’ ${getItemDisplayName(p.equipment.accessory)}</span>
                </div>
            `;
            const ultimateSkillHtml = currentScreen !== 'TOWN' ? '' : `
                 <div class="ultimate-skill-display">
                    <strong>íŠ¹ìˆ˜ ê¸°ìˆ :</strong> ${ultimateSkill.name}
                 </div>
            `;

            return `
                <div class="character-card player-card">
                    <div class="player-header">
                        <h2>${p.name} <span class="player-class">(${p.className} ${CLASSES[p.className].emoji} Lv.${p.level})</span></h2>
                        <div class="gold-sp-display">
                            <p>ğŸ’° Gold: ${p.gold}</p>
                            <p>ğŸ’ Stones: ${p.enhancementStones}</p>
                            <p>âœ¨ Dust: ${p.enchantmentDust}</p>
                        </div>
                    </div>
                     ${dungeonInfo}
                    <div class="hp-bar-container">
                        <div class="hp-bar" style="width: ${hpPercentage}%;"></div>
                    </div>
                    <p>HP: ${Math.floor(p.hp)} / ${Math.floor(p.maxHp)}</p>
                    <div class="status-effects">${statusEffectsHtml}</div>
                    <div class="xp-bar-container">
                        <div class="xp-bar" style="width: ${xpPercentage}%;"></div>
                    </div>
                    <p>XP: ${p.xp} / ${p.xpToNextLevel}</p>
                    <div class="player-stats">
                        <span>âš”ï¸ ATK: ${p.attackPower}</span>
                        <span>ğŸ›¡ï¸ DEF: ${p.defense}</span>
                        <span>ğŸ§ª ë¬¼ì•½: ${p.potions}</span>
                    </div>
                    ${equipmentHtml}
                     ${ultimateSkillHtml}
                    <div class="player-buffs">${buffsHtml}</div>
                </div>
            `;
        }

        return `
            <div class="character-card monster-card">
                <h2>${character.name} ${character.emoji || ''}</h2>
                <div class="hp-bar-container">
                    <div class="hp-bar" style="width: ${hpPercentage}%;"></div>
                </div>
                <p>HP: ${Math.floor(character.hp)} / ${Math.floor(character.maxHp)}</p>
                <div class="status-effects">${statusEffectsHtml}</div>
            </div>
        `;
    }

    function createDungeonMapHTML() {
        const totalFloors = getFloorsForDungeon(dungeonLevel);
        let mapHtml = '<div class="dungeon-map">';
        for (let i = 1; i <= totalFloors; i++) {
            const isBoss = i === totalFloors;
            const isCurrent = i === dungeonFloor;
            const isCleared = i < dungeonFloor;
            
            let nodeClass = 'map-node';
            if (isCleared) nodeClass += ' cleared';
            if (isCurrent) nodeClass += ' current';
            if (isBoss) nodeClass += ' boss';
            
            const emoji = isBoss ? 'ğŸ‘‘' : '';
            
            mapHtml += `<div class="${nodeClass}" title="Floor ${i}">${emoji}</div>`;
            if (i < totalFloors) {
                mapHtml += '<div class="map-connector"></div>';
            }
        }
        mapHtml += '</div>';
        return mapHtml;
    }

    function renderDungeonScreen(isBattleOver = false) {
        if (currentScreen !== 'TOWN' && currentScreen !== 'DUNGEON') return;
        currentScreen = 'DUNGEON';
        
        const ultimateSkill = ULTIMATE_SKILLS[player.className];
        const cooldown = player.ultimateSkillCooldown;
        const disabled = cooldown > 0 || isBattleOver;
        const skillButton = `<button data-action="ultimate" class="button skill-button" ${disabled ? 'disabled' : ''}>${ultimateSkill.name} ${disabled && !isBattleOver ? `(${cooldown})` : ''}</button>`;

        root.innerHTML = `
            <div id="game-world">
                ${createDungeonMapHTML()}
                ${createCharacterCard(monster, false)}
                ${createCharacterCard(player, true)}
            </div>
            <div id="message-log">
                ${messageLog.map(msg => `<p>${msg}</p>`).join('')}
            </div>
            <div id="action-buttons">
                <button data-action="attack" class="button" ${isBattleOver ? 'disabled' : ''}>ê³µê²©</button>
                <button data-action="potion" class="button" ${player.potions <= 0 || isBattleOver ? 'disabled' : ''}>ë¬¼ì•½ (${player.potions})</button>
                ${skillButton}
                <button data-action="escape" class="button" ${isBattleOver ? 'disabled' : ''}>íƒˆì¶œ</button>
            </div>
        `;

        const logContainer = document.getElementById('message-log');
        if (logContainer) logContainer.scrollTop = logContainer.scrollHeight;

        document.getElementById('action-buttons')?.addEventListener('click', handleDungeonAction);
    }

    function handleDungeonAction(event) {
        const target = event.target;
        const button = target.closest('button');
        if (!button || button.disabled) return;

        const action = button.dataset.action;
        switch (action) {
            case 'attack': handlePlayerTurn(handleAttack); break;
            case 'potion': handleUsePotion(); break;
            case 'ultimate': handlePlayerTurn(handleUseUltimateSkill); break;
            case 'escape': handleEscape(); break;
        }
    }
    
    function handleEscape() {
        const goldLost = Math.floor(player.gold * ESCAPE_GOLD_PENALTY);
        if (confirm(`ë˜ì „ì—ì„œ íƒˆì¶œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì†Œì§€ ê³¨ë“œì˜ 5% (${goldLost}G)ë¥¼ ìƒê²Œ ë©ë‹ˆë‹¤.`)) {
            player.gold -= goldLost;
            messageLog = [`ğŸ’° ${goldLost} ê³¨ë“œë¥¼ ìƒê³  ë˜ì „ì—ì„œ íƒˆì¶œí–ˆë‹¤.`];
            player.hp = player.maxHp;
            player.statusEffects = [];
            player.activeBuffs = [];
            recalculatePlayerStats();
            saveGameState();
            renderTownScreen();
        }
    }

    function handlePlayerTurn(action) {
        const isStunned = processStatusEffects(player);
        if (isStunned) {
            addMessage(`ğŸ’« ${player.name}ì€(ëŠ”) ê¸°ì ˆí•´ì„œ ì›€ì§ì¼ ìˆ˜ ì—†ë‹¤!`);
            handleMonsterTurn();
            return;
        }

        if (player.ultimateSkillCooldown > 0) {
            player.ultimateSkillCooldown--;
        }
        player.activeBuffs = player.activeBuffs.map(buff => ({ ...buff, duration: buff.duration - 1 })).filter(buff => buff.duration > 0);
        recalculatePlayerStats();

        action();

        if (monster.hp <= 0) {
            monsterDefeated();
        } else {
            handleMonsterTurn();
        }
    }

    function handleMonsterTurn() {
        const isStunned = processStatusEffects(monster);
        recalculatePlayerStats(); 
        if (isStunned) {
            addMessage(`ğŸ’« ${monster.name}ì€(ëŠ”) ê¸°ì ˆí•´ì„œ ì›€ì§ì¼ ìˆ˜ ì—†ë‹¤!`);
            renderDungeonScreen();
            return;
        }

        monsterAttack();
        
        if (player.hp <= 0) {
            handlePlayerDefeat();
        } else {
            renderDungeonScreen();
        }
    }

    function addMessage(message) {
        messageLog.unshift(message);
        if (messageLog.length > 5) messageLog.pop();
    }

    function handleAttack() {
        let playerDamage = Math.floor(player.attackPower + (Math.random() * 5 - 2));

        if (player.unlockedSkills['r_execute_1'] && monster.hp / monster.maxHp <= 0.25) {
            playerDamage = Math.floor(playerDamage * 1.2);
        }

        if (Math.random() < player.critChance) {
            playerDamage = Math.floor(playerDamage * CRIT_MULTIPLIER);
            addMessage(`ğŸ’¥ ì¹˜ëª…íƒ€! ${player.name}ì´(ê°€) ${monster.name}ì—ê²Œ ${playerDamage}ì˜ ë°ë¯¸ì§€ë¥¼ ì…í˜”ë‹¤!`);
        } else {
            addMessage(`âš”ï¸ ${player.name}ì´(ê°€) ${monster.name}ì—ê²Œ ${playerDamage}ì˜ ë°ë¯¸ì§€ë¥¼ ì…í˜”ë‹¤.`);
        }
        monster.hp = Math.max(0, monster.hp - playerDamage);
    }

    function handleUseUltimateSkill() {
        const skill = ULTIMATE_SKILLS[player.className];
        if (player.ultimateSkillCooldown > 0) return;
        
        updateQuestProgress('USE_ULTIMATE', 1);
        const effect = skill.effect(player.ultimateSkillLevel);
        
        addMessage(`âœ¨ ${effect.message}`);
        
        const reduction = (player.rebirthUpgrades.ultimate_cooldown || 0) * 0.05;
        const finalCooldown = Math.ceil(skill.cooldown * (1 - reduction));
        player.ultimateSkillCooldown = finalCooldown;

        const applyDamage = (multiplier) => {
            let damage = player.attackPower * multiplier;

            if (player.className === 'ë§ˆë²•ì‚¬' && player.unlockedSkills['m_ult_1']) {
                damage *= (1 + player.unlockedSkills['m_ult_1'] * 0.1);
            }

            if (Math.random() < player.critChance) {
                damage = Math.floor(damage * CRIT_MULTIPLIER);
                addMessage(`ğŸ’¥ ì¹˜ëª…íƒ€! ${Math.floor(damage)}ì˜ í”¼í•´!`);
            }
            monster.hp = Math.max(0, monster.hp - Math.floor(damage));
        };

        if (effect.damageMultiplier) {
            if (player.className === 'ë„ì ') {
                applyDamage(effect.damageMultiplier);
                if (monster.hp > 0) {
                    applyDamage(effect.damageMultiplier);
                }
            } else {
                applyDamage(effect.damageMultiplier);
            }
        }

        if (effect.buff) {
            player.activeBuffs.push({ skillId: skill.id, name: skill.name, duration: effect.buff.duration + 1, effect: effect.buff });
            recalculatePlayerStats();
        }
        
        if (effect.statusEffect && Math.random() < effect.statusEffect.chance) {
            applyStatusEffect(monster, { ...effect.statusEffect });
        }
    }

    function handleUsePotion() {
        if (player.potions <= 0) return;
        player.potions--;
        const healAmount = Math.floor(player.maxHp * POTION_HEAL_PERCENT);
        player.hp = Math.min(player.maxHp, player.hp + healAmount);
        addMessage(`ğŸ§ª ë¬¼ì•½ì„ ì‚¬ìš©í•´ HPë¥¼ ${healAmount}ë§Œí¼ íšŒë³µí–ˆë‹¤!`);
        renderDungeonScreen();
    }

    function monsterAttack() {
        if (Math.random() < player.evadeChance) {
            addMessage(`ğŸƒ ${player.name}ì´(ê°€) ê³µê²©ì„ íšŒí”¼í–ˆë‹¤!`);
            return;
        }
        
        let monsterDamage = Math.floor(monster.attackPower + (Math.random() * 4 - 2));
        if (Math.random() < 0.1) { 
            monsterDamage = Math.floor(monsterDamage * CRIT_MULTIPLIER);
            addMessage(`ğŸ’¢ ì¹˜ëª…íƒ€! ${monster.name}ì´(ê°€) ${monsterDamage}ì˜ ë°ë¯¸ì§€ë¥¼ ì…í˜”ë‹¤!`);
        }
        const finalDamage = Math.max(1, monsterDamage - player.defense);
        addMessage(`ğŸ›¡ï¸ ${monster.name}ì˜ ê³µê²©! ${player.name}ì€(ëŠ”) ${finalDamage}ì˜ í”¼í•´ë¥¼ ì…ì—ˆë‹¤.`);
        player.hp = Math.max(0, player.hp - finalDamage);

        const baseMonsterData = (monster.name.startsWith('ğŸ‘‘') ? bossList : monsterList).find(m => monster.name.includes(m.name));
        if (baseMonsterData?.onHitEffect) {
            const effect = baseMonsterData.onHitEffect;
            if (Math.random() < effect.chance) {
                applyStatusEffect(player, { 
                    type: effect.type, 
                    duration: effect.duration, 
                    potency: effect.potency 
                });
            }
        }
    }

    function generateLoot(monsterData, isBoss) {
        // Legendary Drop
        if (isBoss && dungeonLevel >= 4) {
            const legendaryDropChance = 0.01 + (dungeonLevel - 4) * 0.005; // 1% at level 4, increasing
            if (Math.random() < legendaryDropChance) {
                const legendaryItems = ITEM_DATABASE.filter(i => i.rarity === 'legendary' && (i.type === 'weapon' || i.type === 'armor'));
                if (legendaryItems.length > 0) {
                    const droppedLegendary = legendaryItems[Math.floor(Math.random() * legendaryItems.length)];
                    return createItemInstance(droppedLegendary.id);
                }
            }
        }
    
        const dropChance = isBoss ? 0.5 : 0.15;
        if (Math.random() > dropChance) return null;

        const possibleLootIds = monsterData.lootTable.filter((id) => {
            const item = ITEM_DATABASE.find(i => i.id === id);
            if (!item) return false;
            return dungeonLevel >= (item.rarity === 'rare' ? 3 : (item.rarity === 'uncommon' ? 2 : 1));
        });

        if (possibleLootIds.length === 0) return null;

        const lootId = possibleLootIds[Math.floor(Math.random() * possibleLootIds.length)];
        return createItemInstance(lootId);
    }

    function monsterDefeated() {
        addMessage(`ğŸ‰ ${monster.name}ì„(ë¥¼) ë¬¼ë¦¬ì³¤ë‹¤!`);
        updateQuestProgress('KILL_MONSTERS', 1);

        const floors = getFloorsForDungeon(dungeonLevel);
        const isBossFloor = dungeonFloor === floors;
        const baseMonsterData = (isBossFloor ? bossList : monsterList).find(m => monster.name.includes(m.name));
        if (!baseMonsterData) return;
        
        if (isBossFloor) {
            updatePermanentQuestProgress('DEFEAT_BOSS', baseMonsterData.name);
        }
        
        const difficulty = DIFFICULTY_SETTINGS[currentDifficulty];
        const xpGainBonus = 1 + (player.rebirthUpgrades.xp_gain || 0) * 0.05;
        const goldGainBonus = 1 + (player.rebirthUpgrades.gold_gain || 0) * 0.05;

        const xpGained = Math.floor(baseMonsterData.xp * (1 + (dungeonLevel - 1) * 0.15) * difficulty.rewardMod * xpGainBonus);
        const goldGained = Math.floor((baseMonsterData.gold + Math.random() * baseMonsterData.gold * dungeonLevel) * difficulty.rewardMod * goldGainBonus);

        player.xp += xpGained;
        player.gold += goldGained;
        updateQuestProgress('EARN_GOLD', goldGained);
        updatePermanentQuestProgress('COLLECT_GOLD', goldGained);
        addMessage(`ğŸŒŸ ê²½í—˜ì¹˜ ${xpGained}ì„(ë¥¼) íšë“í–ˆë‹¤!`);
        addMessage(`ğŸ’° ê³¨ë“œ ${goldGained}ì„(ë¥¼) íšë“í–ˆë‹¤!`);

        const droppedItem = generateLoot(baseMonsterData, isBossFloor);
        if (droppedItem) {
            player.inventory.push(droppedItem);
            addMessage(`ğŸ’ ì „ë¦¬í’ˆ íšë“: <span class="rarity-${droppedItem.rarity}">${droppedItem.name}</span>!`);
        }
        
        while (player.xp >= player.xpToNextLevel) {
            player.xp -= player.xpToNextLevel; 
            levelUp();
        }

        saveGameState();

        if (isBossFloor) {
            renderDungeonClearScreen();
        } else {
            renderDungeonScreen(true); // Re-render with buttons disabled
            setTimeout(continueDungeon, 1200);
        }
    }

    function levelUp() {
        player.level++;
        player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
        addMessage(`âœ¨ ë ˆë²¨ì—…! ë ˆë²¨ ${player.level}ì´ ë˜ì—ˆë‹¤!`);
        updatePermanentQuestProgress('REACH_LEVEL', player.level);
        
        const previousMaxHp = player.maxHp;
        recalculatePlayerStats();
        const hpGain = player.maxHp - previousMaxHp;
        player.hp += hpGain;
        player.hp = Math.min(player.hp, player.maxHp);
        saveGameState();
    }

    function continueDungeon() {
        dungeonFloor++;
        messageLog = [`ë˜ì „ ${dungeonLevel} - ${dungeonFloor}ì¸µìœ¼ë¡œ ì´ë™í–ˆë‹¤.`];
        spawnMonster();
        renderDungeonScreen();
    }

    function renderDungeonClearScreen() {
        addMessage(`ğŸ† ë˜ì „ ${dungeonLevel} í´ë¦¬ì–´! ë§ˆì„ë¡œ ê·€í™˜í•©ë‹ˆë‹¤.`);
        updateQuestProgress('CLEAR_DUNGEON', 1);
        dungeonLevel++;
        saveGameState();

        root.innerHTML = `
            <div class="screen-container">
                <h1>ë˜ì „ í´ë¦¬ì–´!</h1>
                <p>ê°•ë ¥í•œ ë³´ìŠ¤ë¥¼ ë¬¼ë¦¬ì³¤ìŠµë‹ˆë‹¤!</p>
                 <div id="action-buttons" class="town-actions">
                    <button id="return-town-button" class="button">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
                </div>
            </div>
        `;
        document.getElementById('return-town-button')?.addEventListener('click', () => {
            player.hp = player.maxHp;
            player.statusEffects = [];
            player.activeBuffs = [];
            recalculatePlayerStats();
            renderTownScreen();
        });
    }

    function getCurrentPotionCost() {
        return BASE_POTION_COST + (dungeonLevel - 1) * POTION_COST_PER_LEVEL;
    }

    function renderShopScreen() {
        currentScreen = 'SHOP';
        const itemsForSale = ITEM_DATABASE.filter(item => item.type === 'weapon' || item.type === 'armor' || item.type === 'accessory');
        
        const filteredItems = itemsForSale.filter(item => {
            const typeMatch = shopFilterType === 'all' || item.type === shopFilterType;
            const rarityMatch = shopFilterRarity === 'all' || item.rarity === shopFilterRarity;
            return typeMatch && rarityMatch;
        }).sort((a, b) => {
            const rarityOrder = { 'legendary': 4, 'rare': 3, 'uncommon': 2, 'common': 1 };
            if ((rarityOrder[b.rarity] || 0) !== (rarityOrder[a.rarity] || 0)) {
                return (rarityOrder[b.rarity] || 0) - (rarityOrder[a.rarity] || 0);
            }
            return b.cost - a.cost;
        });

        const currentPotionCost = getCurrentPotionCost();

        const itemsHtml = filteredItems.map(item => `
            <div class="shop-item">
                <div>
                    <span class="rarity-${item.rarity}">${item.name}</span>
                    <span class="item-class">(${item.type === 'accessory' ? 'ì¥ì‹ êµ¬' : item.classRestriction.join(', ')})</span>
                </div>
                <button class="button buy-item-btn" data-item-id="${item.id}" ${player.gold < item.cost ? 'disabled' : ''}>${item.cost} G</button>
            </div>
        `).join('');
        
        const filtersHtml = `
            <div class="shop-filters">
                <div class="filter-group">
                    <button class="filter-btn ${shopFilterType === 'all' ? 'active' : ''}" data-filter-type="type" data-filter-value="all">ì „ì²´</button>
                    <button class="filter-btn ${shopFilterType === 'weapon' ? 'active' : ''}" data-filter-type="type" data-filter-value="weapon">ë¬´ê¸°</button>
                    <button class="filter-btn ${shopFilterType === 'armor' ? 'active' : ''}" data-filter-type="type" data-filter-value="armor">ë°©ì–´êµ¬</button>
                    <button class="filter-btn ${shopFilterType === 'accessory' ? 'active' : ''}" data-filter-type="type" data-filter-value="accessory">ì¥ì‹ êµ¬</button>
                </div>
                <div class="filter-group">
                    <button class="filter-btn ${shopFilterRarity === 'all' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="all">ì „ì²´</button>
                    <button class="filter-btn ${shopFilterRarity === 'common' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="common">ì¼ë°˜</button>
                    <button class="filter-btn ${shopFilterRarity === 'uncommon' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="uncommon">ê³ ê¸‰</button>
                    <button class="filter-btn ${shopFilterRarity === 'rare' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="rare">í¬ê·€</button>
                    <button class="filter-btn ${shopFilterRarity === 'legendary' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="legendary">ì „ì„¤</button>
                </div>
            </div>
        `;

        root.innerHTML = `
            <div class="screen-container shop-container">
                <h1>ìƒì </h1>
                 <div class="gold-sp-display top-display">
                    <p>ğŸ’° Gold: ${player.gold}</p>
                    <p>ğŸ’ Stones: ${player.enhancementStones}</p>
                    <p>âœ¨ Dust: ${player.enchantmentDust || 0}</p>
                </div>
                ${filtersHtml}
                <div class="shop-items">
                    <div class="shop-item">
                        <span>ğŸ§ª íšŒë³µ ë¬¼ì•½ êµ¬ë§¤</span>
                        <button class="button" id="buy-potion" ${player.gold < currentPotionCost ? 'disabled' : ''}>${currentPotionCost} G</button>
                    </div>
                    ${itemsHtml}
                    ${filteredItems.length === 0 ? '<p>í‘œì‹œí•  ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</p>' : ''}
                </div>
                <button id="back-to-town" class="button">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
            </div>
        `;

        document.getElementById('buy-potion')?.addEventListener('click', () => {
            const cost = getCurrentPotionCost();
            if (player.gold >= cost) {
                player.gold -= cost;
                player.potions++;
                saveGameState();
                renderShopScreen();
            }
        });

        document.querySelectorAll('.buy-item-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const itemId = parseInt(e.currentTarget.dataset.itemId || '0');
                const itemData = ITEM_DATABASE.find(i => i.id === itemId);
                if (itemData && player.gold >= itemData.cost) {
                    const item = createItemInstance(itemId);
                    player.gold -= itemData.cost;
                    player.inventory.push(item);
                    addMessage(`ğŸ›’ ìƒì ì—ì„œ <span class="rarity-${item.rarity}">${item.name}</span>ì„(ë¥¼) êµ¬ë§¤í–ˆë‹¤.`);
                    saveGameState();
                    renderShopScreen();
                }
            });
        });

        document.querySelectorAll('.filter-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.currentTarget;
                const filterType = target.dataset.filterType;
                const filterValue = target.dataset.filterValue;

                if (filterType === 'type') {
                    shopFilterType = filterValue;
                } else if (filterType === 'rarity') {
                    shopFilterRarity = filterValue;
                }
                renderShopScreen();
            });
        });

        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }

    function handlePlayerDefeat() {
        const goldLost = Math.floor(player.gold * DEFEAT_GOLD_PENALTY);
        player.gold -= goldLost;
        messageLog = [`ê³¨ë“œ ${goldLost}ë¥¼ ìƒì—ˆë‹¤...`, 'ì •ì‹ ì„ ì°¨ë ¤ë³´ë‹ˆ ë§ˆì„ì´ì—ˆë‹¤.', `ë˜ì „ ${dungeonFloor}ì¸µì—ì„œ ì“°ëŸ¬ì¡Œë‹¤.`];
        
        player.activeBuffs = [];
        player.statusEffects = [];
        recalculatePlayerStats();
        player.hp = player.maxHp;
        saveGameState();
        renderTownScreen();
    }

    function getSellPrice(item) {
        return Math.floor(item.cost * 0.4 + item.cost * item.enhancementLevel * 0.1);
    }

    function handleSellItemClick(event) {
        const card = event.currentTarget;
        const inventoryIndexStr = card.dataset.inventoryIndex;
        if (inventoryIndexStr === undefined) return;

        const index = parseInt(inventoryIndexStr);
        const item = player.inventory[index];

        if (!item) return;

        const sellPrice = getSellPrice(item);
        const isValuable = item.rarity === 'rare' || item.rarity === 'legendary' || item.enhancementLevel >= 5;
        
        const confirmationMessage = `ì •ë§ë¡œ '${getItemDisplayName(item)}'ì„(ë¥¼) ${sellPrice}Gì— íŒë§¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;

        if (!isValuable || confirm(confirmationMessage)) {
            player.gold += sellPrice;
            updateQuestProgress('EARN_GOLD', sellPrice);
            updatePermanentQuestProgress('COLLECT_GOLD', sellPrice);
            const soldItemName = getItemDisplayName(item);
            player.inventory.splice(index, 1);
            addMessage(`ğŸ’° ${soldItemName}ì„(ë¥¼) íŒë§¤í•˜ì—¬ ${sellPrice}Gë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤.`);
            saveGameState();
            renderEquipmentScreen(); 
        }
    }


    function renderEquipmentScreen() {
        currentScreen = 'EQUIPMENT';

        const createItemCard = (item, slot, index) => {
            if (!item) {
                return `<div class="item-card empty" data-slot="${slot}">ë¹„ì–´ìˆìŒ</div>`;
            }
            const isRestricted = !item.classRestriction.includes(player.className);
            const statsHtml = Object.entries(item.stats).map(([stat, value]) => {
                let statName = '';
                switch(stat) {
                    case 'maxHp': statName = 'HP'; break;
                    case 'attackPower': statName = 'ATK'; break;
                    case 'defense': statName = 'DEF'; break;
                    case 'critChance': statName = 'ì¹˜ëª…íƒ€'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                    case 'evadeChance': statName = 'íšŒí”¼'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                }
                return `${statName} +${value}`;
            }).join(', ');
            
            const sellOverlayHtml = isSellMode && item && slot === 'inventory' 
                ? `<div class="sell-overlay">íŒë§¤: ${getSellPrice(item)} G</div>` 
                : '';

            const enchantmentHtml = item.enchantment ? `<p class="item-enchantment">âœ¨ ${item.enchantment.description}</p>` : '';

            return `
                <div class="item-card rarity-${item.rarity} ${isRestricted ? 'restricted' : ''} ${isSellMode && slot === 'inventory' ? 'sellable' : ''}" data-slot="${slot}" data-item-id="${item.id}" ${index !== undefined ? `data-inventory-index="${index}"` : ''}>
                    <p class="item-name">${getItemDisplayName(item)}</p>
                    <p class="item-class">(${item.classRestriction.join(', ')})</p>
                    <p class="item-stats">${statsHtml}</p>
                    ${enchantmentHtml}
                    ${isRestricted ? `<div class="restricted-overlay">ì¥ì°©ë¶ˆê°€</div>` : ''}
                    ${sellOverlayHtml}
                </div>
            `;
        };

        const inventoryHtml = player.inventory.map((item, index) => createItemCard(item, 'inventory', index)).join('');

        root.innerHTML = `
            <div class="screen-container equipment-screen">
                <h1>ì¥ë¹„</h1>
                <div class="gold-sp-display top-display">
                    <p>ğŸ’° Gold: ${player.gold}</p>
                    <p>ğŸ’ Stones: ${player.enhancementStones}</p>
                    <p>âœ¨ Dust: ${player.enchantmentDust || 0}</p>
                </div>
                <div class="equipment-slots">
                    <div class="slot-container">
                        <h3>ë¬´ê¸°</h3>
                        ${createItemCard(player.equipment.weapon, 'weapon')}
                    </div>
                    <div class="slot-container">
                        <h3>ë°©ì–´êµ¬</h3>
                        ${createItemCard(player.equipment.armor, 'armor')}
                    </div>
                    <div class="slot-container">
                        <h3>ì¥ì‹ êµ¬</h3>
                        ${createItemCard(player.equipment.accessory, 'accessory')}
                    </div>
                </div>
                <h2>ì¸ë²¤í† ë¦¬ ${isSellMode ? '<span class="sell-mode-indicator">(íŒë§¤ ëª¨ë“œ)</span>' : ''}</h2>
                <div class="inventory-grid ${isSellMode ? 'sell-mode' : ''}">
                    ${inventoryHtml || '<p>ì¸ë²¤í† ë¦¬ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.</p>'}
                </div>
                <div class="equipment-screen-footer">
                    <button id="sell-toggle-button" class="button">${isSellMode ? 'íŒë§¤ ì¢…ë£Œ' : 'ì¥ë¹„ íŒë§¤'}</button>
                    <button id="back-to-town-equip" class="button">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
                </div>
            </div>
        `;
        
        document.querySelectorAll('.item-card').forEach(card => {
            const slot = card.dataset.slot;
            if (isSellMode && slot === 'inventory' && !card.classList.contains('empty')) {
                 card.addEventListener('click', handleSellItemClick);
            } else if (!isSellMode) {
                card.addEventListener('click', handleItemClick);
            }
        });

        document.getElementById('sell-toggle-button')?.addEventListener('click', () => {
            isSellMode = !isSellMode;
            renderEquipmentScreen();
        });

        document.getElementById('back-to-town-equip')?.addEventListener('click', () => {
            isSellMode = false;
            renderTownScreen();
        });
    }

    function handleItemClick(event) {
        const card = event.currentTarget;
        const slot = card.dataset.slot;
        const inventoryIndexStr = card.dataset.inventoryIndex;

        if (slot === 'inventory') {
            const index = parseInt(inventoryIndexStr || '0');
            const item = player.inventory[index];
            if (item) equipItem(item, index);
        } else if (slot) {
            unequipItem(slot);
        }
    }

    function equipItem(item, inventoryIndex) {
        if (item.classRestriction && !item.classRestriction.includes(player.className)) {
            alert("ì´ ì§ì—…ì€ ì°©ìš©í•  ìˆ˜ ì—†ëŠ” ì¥ë¹„ì…ë‹ˆë‹¤.");
            return;
        }
        const currentItem = player.equipment[item.type];
        if (currentItem) {
            player.inventory.push(currentItem);
        }
        player.equipment[item.type] = item;
        player.inventory.splice(inventoryIndex, 1);
        
        const previousMaxHp = player.maxHp;
        recalculatePlayerStats();
        const hpGain = player.maxHp - previousMaxHp;
        player.hp += hpGain;
        player.hp = Math.min(player.hp, player.maxHp);
        
        saveGameState();
        renderEquipmentScreen();
    }

    function unequipItem(slot) {
        const item = player.equipment[slot];
        if (item) {
            player.inventory.push(item);
            player.equipment[slot] = null;
            
            const previousMaxHp = player.maxHp;
            recalculatePlayerStats();
            const hpLoss = previousMaxHp - player.maxHp;
            player.hp -= hpLoss;
            if(player.hp > player.maxHp) player.hp = player.maxHp;
            if(player.hp <= 0) player.hp = 1;

            saveGameState();
            renderEquipmentScreen();
        }
    }

    function applyStatusEffect(target, newEffect) {
        const existingEffect = target.statusEffects.find(se => se.type === newEffect.type);
        if (existingEffect) {
            existingEffect.duration = Math.max(existingEffect.duration, newEffect.duration);
            existingEffect.potency = Math.max(existingEffect.potency, newEffect.potency);
        } else {
            target.statusEffects.push(newEffect);
        }
        const def = STATUS_EFFECT_DEFINITIONS[newEffect.type];
        addMessage(`${def.icon} ${target.name}ì´(ê°€) [${def.name}] íš¨ê³¼ë¥¼ ë°›ì•˜ë‹¤!`);
    }

    function processStatusEffects(character) {
        let isStunned = false;
        let totalDamage = 0;

        character.statusEffects = character.statusEffects.filter(se => {
            const def = STATUS_EFFECT_DEFINITIONS[se.type];
            if (se.type === 'stun') {
                isStunned = true;
            }
            if (se.type === 'poison') {
                let poisonDamage = se.potency;
                totalDamage += poisonDamage;
                addMessage(`${def.icon} [${def.name}] íš¨ê³¼ë¡œ ${character.name}ì´(ê°€) ${poisonDamage}ì˜ í”¼í•´ë¥¼ ì…ì—ˆë‹¤!`);
            }
            if (se.type === 'burn') {
                let burnDamage = se.potency;
                 if (character === monster && player.unlockedSkills['m_burn_1']) {
                    burnDamage *= (1 + player.unlockedSkills['m_burn_1'] * 0.1);
                }
                totalDamage += burnDamage;
                addMessage(`${def.icon} [${def.name}] íš¨ê³¼ë¡œ ${character.name}ì´(ê°€) ${Math.floor(burnDamage)}ì˜ í”¼í•´ë¥¼ ì…ì—ˆë‹¤!`);
            }
            
            se.duration--;
            return se.duration > 0;
        });

        if (totalDamage > 0) {
            character.hp = Math.max(0, character.hp - totalDamage);
        }
        
        recalculatePlayerStats(); 
        return isStunned;
    }

    function getEnhancementCost(item) {
        let rarityMultiplier = 1;
        if (item.rarity === 'uncommon') rarityMultiplier = 1.5;
        if (item.rarity === 'rare') rarityMultiplier = 2.5;
        if (item.rarity === 'legendary') rarityMultiplier = 5;
        return Math.floor(50 * Math.pow(1.4, item.enhancementLevel) * rarityMultiplier);
    }

    function getEnhancementStoneCost(item) {
        let rarityMultiplier = 1;
        if (item.rarity === 'uncommon') rarityMultiplier = 2;
        if (item.rarity === 'rare') rarityMultiplier = 3;
        if (item.rarity === 'legendary') rarityMultiplier = 5;
        return Math.ceil( (2 + item.enhancementLevel) * rarityMultiplier / 2);
    }

    function getSuccessChance(level) {
        if (level < 3) return 1.0;
        if (level < 5) return 0.9;
        if (level < 7) return 0.7;
        if (level < 9) return 0.5;
        if (level < 12) return 0.3;
        return 0.15;
    }

    function getStatIncrease(item) {
        let rarityMultiplier = 1;
        if (item.rarity === 'uncommon') rarityMultiplier = 1.2;
        if (item.rarity === 'rare') rarityMultiplier = 1.5;
        if (item.rarity === 'legendary') rarityMultiplier = 2.5;
        if (item.type === 'weapon') {
            return { attackPower: Math.ceil(2 * rarityMultiplier) };
        } else if (item.type === 'armor') {
            return { defense: Math.ceil(1 * rarityMultiplier), maxHp: Math.ceil(5 * rarityMultiplier) };
        } else if (item.type === 'accessory') {
            const increases = {};
            if (item.stats.attackPower) increases.attackPower = Math.ceil(1 * rarityMultiplier);
            if (item.stats.maxHp) increases.maxHp = Math.ceil(10 * rarityMultiplier);
            if (item.stats.defense) increases.defense = Math.ceil(1 * rarityMultiplier);
            return increases;
        }
        return {};
    }

    function renderBlacksmithScreen() {
        currentScreen = 'BLACKSMITH';

        const renderEnhanceContent = () => {
            return `
                <div class="enhancement-slots">
                    <div class="enhancement-slot" data-slot="weapon">
                        <h3>ë¬´ê¸°</h3>
                        ${player.equipment.weapon ? createItemCardForBlacksmith(player.equipment.weapon) : '<div class="item-card empty">ì—†ìŒ</div>'}
                    </div>
                    <div class="enhancement-slot" data-slot="armor">
                        <h3>ë°©ì–´êµ¬</h3>
                        ${player.equipment.armor ? createItemCardForBlacksmith(player.equipment.armor) : '<div class="item-card empty">ì—†ìŒ</div>'}
                    </div>
                     <div class="enhancement-slot" data-slot="accessory">
                        <h3>ì¥ì‹ êµ¬</h3>
                        ${player.equipment.accessory ? createItemCardForBlacksmith(player.equipment.accessory) : '<div class="item-card empty">ì—†ìŒ</div>'}
                    </div>
                </div>
                <div id="enhancement-details">
                    <p>ê°•í™”í•  ì¥ë¹„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
                </div>
            `;
        };

        const renderDisenchantContent = () => {
            const inventoryHtml = player.inventory.map((item, index) => createItemCardForDisenchant(item, index)).join('');
            return `
                <h2>ë¶„í•´í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”</h2>
                <div class="inventory-grid disenchant-mode">
                    ${inventoryHtml || '<p>ì¸ë²¤í† ë¦¬ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.</p>'}
                </div>
            `;
        };

        const renderEnchantContent = () => {
            return `
                <div class="enhancement-slots">
                    <div class="enhancement-slot" data-slot="weapon">
                        <h3>ë¬´ê¸°</h3>
                        ${player.equipment.weapon ? createItemCardForBlacksmith(player.equipment.weapon) : '<div class="item-card empty">ì—†ìŒ</div>'}
                    </div>
                    <div class="enhancement-slot" data-slot="armor">
                        <h3>ë°©ì–´êµ¬</h3>
                        ${player.equipment.armor ? createItemCardForBlacksmith(player.equipment.armor) : '<div class="item-card empty">ì—†ìŒ</div>'}
                    </div>
                    <div class="enhancement-slot" data-slot="accessory">
                        <h3>ì¥ì‹ êµ¬</h3>
                        ${player.equipment.accessory ? createItemCardForBlacksmith(player.equipment.accessory) : '<div class="item-card empty">ì—†ìŒ</div>'}
                    </div>
                </div>
                <div id="enhancement-details">
                    <p>ë§ˆë²• ë¶€ì—¬í•  ì¥ë¹„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
                </div>
            `;
        }

        root.innerHTML = `
            <div class="screen-container blacksmith-screen">
                <h1>ëŒ€ì¥ê°„</h1>
                <div class="gold-sp-display top-display">
                    <p>ğŸ’° Gold: ${player.gold}</p>
                    <p>ğŸ’ Stones: ${player.enhancementStones}</p>
                    <p>âœ¨ Dust: ${player.enchantmentDust || 0}</p>
                </div>
                <div class="blacksmith-tabs">
                    <button id="tab-enhance" class="tab-button ${blacksmithMode === 'enhance' ? 'active' : ''}">ê°•í™”</button>
                    <button id="tab-disenchant" class="tab-button ${blacksmithMode === 'disenchant' ? 'active' : ''}">ë¶„í•´</button>
                    <button id="tab-enchant" class="tab-button ${blacksmithMode === 'enchant' ? 'active' : ''}">ë§ˆë²• ë¶€ì—¬</button>
                </div>
                <div id="blacksmith-content">
                    ${blacksmithMode === 'enhance' ? renderEnhanceContent() : (blacksmithMode === 'disenchant' ? renderDisenchantContent() : renderEnchantContent())}
                </div>
                <button id="back-to-town" class="button">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
            </div>
        `;

        document.getElementById('tab-enhance')?.addEventListener('click', () => { blacksmithMode = 'enhance'; renderBlacksmithScreen(); });
        document.getElementById('tab-disenchant')?.addEventListener('click', () => { blacksmithMode = 'disenchant'; renderBlacksmithScreen(); });
        document.getElementById('tab-enchant')?.addEventListener('click', () => { blacksmithMode = 'enchant'; renderBlacksmithScreen(); });

        if (blacksmithMode === 'enhance' || blacksmithMode === 'enchant') {
            document.querySelectorAll('.enhancement-slot').forEach(slot => {
                slot.addEventListener('click', () => {
                    const slotType = slot.getAttribute('data-slot');
                    if (blacksmithMode === 'enhance') {
                        renderEnhancementDetails(slotType);
                    } else {
                        renderEnchantDetails(slotType);
                    }
                });
            });
        } else {
            document.querySelectorAll('.item-card.disenchantable').forEach(card => {
                card.addEventListener('click', handleDisenchantItemClick);
            });
        }

        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }


    function createItemCardForBlacksmith(item) {
        const statsHtml = Object.entries(item.stats).map(([stat, value]) => {
            let statName = '';
            switch(stat) {
                case 'maxHp': statName = 'HP'; break;
                case 'attackPower': statName = 'ATK'; break;
                case 'defense': statName = 'DEF'; break;
                case 'critChance': statName = 'ì¹˜ëª…íƒ€'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                case 'evadeChance': statName = 'íšŒí”¼'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
            }
            return `${statName} +${value}`;
        }).join(', ');

        const enchantmentHtml = item.enchantment ? `<p class="item-enchantment">âœ¨ ${item.enchantment.description}</p>` : '';

        return `
            <div class="item-card rarity-${item.rarity}">
                <p class="item-name">${getItemDisplayName(item)}</p>
                <p class="item-class">(${item.classRestriction ? item.classRestriction.join(', ') : 'ëª¨ë“  ì§ì—…'})</p>
                <p class="item-stats">${statsHtml}</p>
                ${enchantmentHtml}
            </div>
        `;
    }

    function renderEnhancementDetails(slot) {
        const detailsContainer = document.getElementById('enhancement-details');
        if (!detailsContainer) return;
        
        const item = player.equipment[slot];
        if (!item) {
            detailsContainer.innerHTML = `<p>ê°•í™”í•  ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤.</p>`;
            return;
        }

        const goldCost = getEnhancementCost(item);
        const stoneCost = getEnhancementStoneCost(item);
        const successChance = getSuccessChance(item.enhancementLevel);
        const statIncrease = getStatIncrease(item);

        const nextStatsHtml = Object.entries(statIncrease).map(([stat, value]) => {
            let statName = '';
            switch(stat) {
                case 'maxHp': statName = 'ìµœëŒ€ HP'; break;
                case 'attackPower': statName = 'ê³µê²©ë ¥'; break;
                case 'defense': statName = 'ë°©ì–´ë ¥'; break;
            }
            return `<span>${statName} +${value}</span>`;
        }).join('');

        const penaltyInfo = item.enhancementLevel >= 5
            ? `<p class="penalty-info">ì‹¤íŒ¨ ì‹œ 30% í™•ë¥ ë¡œ ê°•í™” ë‹¨ê³„ê°€ í•˜ë½í•©ë‹ˆë‹¤. í•˜ë½í•˜ì§€ ì•Šìœ¼ë©´ ë¹„ìš©ì˜ 50%ë¥¼ ëŒë ¤ë°›ìŠµë‹ˆë‹¤.</p>`
            : `<p class="penalty-info">ì‹¤íŒ¨ ì‹œ ê°•í™” ë¹„ìš©ë§Œ ì†Œëª¨ë©ë‹ˆë‹¤.</p>`;

        detailsContainer.innerHTML = `
            <h3>${getItemDisplayName(item)} â†’ +${item.enhancementLevel + 1}</h3>
            <div class="enhancement-info">
                <div class="info-row">
                    <span>ë‹¤ìŒ ë ˆë²¨ íš¨ê³¼:</span>
                    <div class="next-stats">${nextStatsHtml}</div>
                </div>
                <div class="info-row">
                    <span>ê°•í™” ë¹„ìš©:</span>
                    <span class="cost-display">${goldCost} G / ${stoneCost} ğŸ’</span>
                </div>
                <div class="info-row">
                    <span>ì„±ê³µ í™•ë¥ :</span>
                    <span>${(successChance * 100).toFixed(0)}%</span>
                </div>
            </div>
            ${penaltyInfo}
            <button id="enhance-button" class="button" ${player.gold < goldCost || player.enhancementStones < stoneCost ? 'disabled' : ''}>ê°•í™”</button>
        `;

        document.getElementById('enhance-button')?.addEventListener('click', () => handleEnhance(slot));
    }

    function handleEnhance(slot) {
        const item = player.equipment[slot];
        if (!item) return;

        const goldCost = getEnhancementCost(item);
        const stoneCost = getEnhancementStoneCost(item);
        if (player.gold < goldCost || player.enhancementStones < stoneCost) return;

        player.gold -= goldCost;
        player.enhancementStones -= stoneCost;
        updateQuestProgress('ENHANCE_ATTEMPTS', 1);

        const successChance = getSuccessChance(item.enhancementLevel);

        if (Math.random() < successChance) {
            item.enhancementLevel++;
            updatePermanentQuestProgress('ENHANCE_SUCCESS', item.enhancementLevel);
            const statIncrease = getStatIncrease(item);
            Object.entries(statIncrease).forEach(([stat, value]) => {
                const key = stat;
                if (item.stats[key] !== undefined) {
                    item.stats[key] += value;
                } else {
                    item.stats[key] = value;
                }
            });
            alert('âœ¨ ê°•í™” ì„±ê³µ!');
        } else {
            if (item.enhancementLevel >= 5 && Math.random() < 0.3) {
                const statIncrease = getStatIncrease({ ...item, enhancementLevel: item.enhancementLevel - 1});
                 Object.entries(statIncrease).forEach(([stat, value]) => {
                    const key = stat;
                    if (item.stats[key]) {
                        item.stats[key] -= value;
                    }
                });
                item.enhancementLevel--;
                alert('ğŸ“‰ ê°•í™” ì‹¤íŒ¨... ê°•í™” ë‹¨ê³„ê°€ í•˜ë½í–ˆìŠµë‹ˆë‹¤.');
            } else if (item.enhancementLevel >= 5) {
                const refund = Math.floor(goldCost / 2);
                player.gold += refund;
                alert(`ğŸ”¥ ê°•í™” ì‹¤íŒ¨... í•˜ì§€ë§Œ ë¹„ìš©ì˜ 50% (${refund}G)ë¥¼ ëŒë ¤ë°›ì•˜ìŠµë‹ˆë‹¤.`);
            } else {
                alert('ğŸ”¥ ê°•í™” ì‹¤íŒ¨...');
            }
        }
        
        const previousMaxHp = player.maxHp;
        recalculatePlayerStats();
        const hpChange = player.maxHp - previousMaxHp;
        player.hp += hpChange;
        player.hp = Math.min(player.hp, player.maxHp);
        if (player.hp <= 0) player.hp = 1;

        saveGameState();
        renderBlacksmithScreen();
        renderEnhancementDetails(slot);
    }

    function getDisenchantYield(item) {
        let rarityBonusStones = 1, rarityBonusDust = 1;
        if (item.rarity === 'uncommon') {
            rarityBonusStones = 3;
            rarityBonusDust = 5;
        } else if (item.rarity === 'rare') {
            rarityBonusStones = 7;
            rarityBonusDust = 15;
        } else if (item.rarity === 'legendary') {
            rarityBonusStones = 20;
            rarityBonusDust = 50;
        }
        const levelBonusStones = Math.floor(rarityBonusStones * item.enhancementLevel * 0.75);
        const levelBonusDust = Math.floor(rarityBonusDust * item.enhancementLevel * 0.5);

        return {
            stones: rarityBonusStones + levelBonusStones,
            dust: rarityBonusDust + levelBonusDust,
        };
    }

    function handleDisenchantItemClick(event) {
        const card = event.currentTarget;
        const inventoryIndexStr = card.dataset.inventoryIndex;
        if (inventoryIndexStr === undefined) return;

        const index = parseInt(inventoryIndexStr);
        const item = player.inventory[index];
        if (!item) return;

        const { stones, dust } = getDisenchantYield(item);
        const confirmationMessage = `ì •ë§ë¡œ '${getItemDisplayName(item)}'ì„(ë¥¼) ë¶„í•´í•˜ì—¬ ê°•í™”ì„ ğŸ’${stones}ê°œì™€ ë§ˆë²• ë¶€ì—¬ ê°€ë£¨ âœ¨${dust}ê°œë¥¼ ì–»ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ? ì´ í–‰ë™ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`;

        if (confirm(confirmationMessage)) {
            player.enhancementStones += stones;
            player.enchantmentDust += dust;
            const disenchantedItemName = getItemDisplayName(item);
            player.inventory.splice(index, 1);
            addMessage(`ğŸ”® ${disenchantedItemName}ì„(ë¥¼) ë¶„í•´í•˜ì—¬ ğŸ’${stones}ê°œì™€ âœ¨${dust}ê°œë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤.`);
            saveGameState();
            renderBlacksmithScreen();
        }
    }

    function createItemCardForDisenchant(item, index) {
        const statsHtml = Object.entries(item.stats).map(([stat, value]) => {
            let statName = '';
            switch(stat) {
                case 'maxHp': statName = 'HP'; break;
                case 'attackPower': statName = 'ATK'; break;
                case 'defense': statName = 'DEF'; break;
                case 'critChance': statName = 'ì¹˜ëª…íƒ€'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                case 'evadeChance': statName = 'íšŒí”¼'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
            }
            return `${statName} +${value}`;
        }).join(', ');

        const { stones, dust } = getDisenchantYield(item);
        const disenchantOverlayHtml = `<div class="disenchant-overlay">ë¶„í•´ ì‹œ: ğŸ’ ${stones} / âœ¨ ${dust}</div>`;
        const enchantmentHtml = item.enchantment ? `<p class="item-enchantment">âœ¨ ${item.enchantment.description}</p>` : '';

        return `
            <div class="item-card rarity-${item.rarity} disenchantable" data-inventory-index="${index}">
                <p class="item-name">${getItemDisplayName(item)}</p>
                <p class="item-class">(${item.classRestriction ? item.classRestriction.join(', ') : 'ëª¨ë“  ì§ì—…'})</p>
                <p class="item-stats">${statsHtml}</p>
                ${enchantmentHtml}
                ${disenchantOverlayHtml}
            </div>
        `;
    };

    function getEnchantmentCost(item) {
        let gold = 100, dust = 10;
        if (item.rarity === 'uncommon') { gold = 300; dust = 30; } 
        else if (item.rarity === 'rare') { gold = 800; dust = 75; }
        else if (item.rarity === 'legendary') { gold = 2500; dust = 200; }
        return { gold, dust };
    }

    function renderEnchantDetails(slot) {
        const detailsContainer = document.getElementById('enhancement-details');
        if (!detailsContainer) return;

        const item = player.equipment[slot];
        if (!item) {
            detailsContainer.innerHTML = `<p>ë§ˆë²• ë¶€ì—¬í•  ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤.</p>`;
            return;
        }
        
        if (!ENCHANTMENT_POOL[item.type]) {
             detailsContainer.innerHTML = `<p>ì´ ì¢…ë¥˜ì˜ ì•„ì´í…œì€ ë§ˆë²• ë¶€ì—¬ë¥¼ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>`;
             return;
        }

        const { gold, dust } = getEnchantmentCost(item);
        
        const currentEnchantmentHtml = item.enchantment 
            ? `<p class="current-enchantment">í˜„ì¬ íš¨ê³¼: ${item.enchantment.description}</p><p class="enchant-warning">ë§ˆë²• ë¶€ì—¬ ì‹œ í˜„ì¬ íš¨ê³¼ê°€ ìƒˆë¡œìš´ ë¬´ì‘ìœ„ íš¨ê³¼ë¡œ ë³€ê²½ë©ë‹ˆë‹¤.</p>`
            : '<p>í˜„ì¬ ë¶€ì—¬ëœ ë§ˆë²• íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';

        detailsContainer.innerHTML = `
            <h3>${getItemDisplayName(item)}</h3>
            ${currentEnchantmentHtml}
            <div class="enhancement-info">
                <div class="info-row">
                    <span>ë§ˆë²• ë¶€ì—¬ ë¹„ìš©:</span>
                    <span class="cost-display">${gold} G / ${dust} âœ¨</span>
                </div>
            </div>
            <button id="enchant-button" class="button" ${player.gold < gold || player.enchantmentDust < dust ? 'disabled' : ''}>ë§ˆë²• ë¶€ì—¬</button>
        `;
        document.getElementById('enchant-button')?.addEventListener('click', () => handleEnchant(slot));
    }

    function handleEnchant(slot) {
        const item = player.equipment[slot];
        if (!item || !ENCHANTMENT_POOL[item.type]) return;

        const { gold, dust } = getEnchantmentCost(item);
        if (player.gold < gold || player.enchantmentDust < dust) return;

        const confirmMsg = item.enchantment 
            ? 'ì´ë¯¸ ë§ˆë²• ë¶€ì—¬ê°€ ëœ ì•„ì´í…œì…ë‹ˆë‹¤. ìƒˆë¡œìš´ íš¨ê³¼ë¡œ ë®ì–´ì“°ì‹œê² ìŠµë‹ˆê¹Œ?'
            : 'ì´ ì¥ë¹„ì— ë§ˆë²•ì„ ë¶€ì—¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?';

        if (confirm(confirmMsg)) {
            player.gold -= gold;
            player.enchantmentDust -= dust;

            const pool = ENCHANTMENT_POOL[item.type][item.rarity];
            const newEnchantment = pool[Math.floor(Math.random() * pool.length)];
            item.enchantment = newEnchantment;

            alert(`âœ¨ ë§ˆë²• ë¶€ì—¬ ì„±ê³µ! [${newEnchantment.description}] íš¨ê³¼ë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤.`);

            const previousMaxHp = player.maxHp;
            recalculatePlayerStats();
            const hpChange = player.maxHp - previousMaxHp;
            player.hp += hpChange;
            player.hp = Math.min(player.hp, player.maxHp);
            if (player.hp <= 0) player.hp = 1;

            saveGameState();
            renderBlacksmithScreen();
            renderEnchantDetails(slot);
        }
    }

    function isSkillLearnable(skill) {
        const currentLevel = player.unlockedSkills[skill.id] || 0;
        if (skill.maxLevel && currentLevel >= skill.maxLevel) return false;
        if (player.level < skill.requiredPlayerLevel) return false;

        for (const prereq of skill.prerequisites) {
            if ((player.unlockedSkills[prereq.id] || 0) < prereq.level) {
                return false;
            }
        }
        return true;
    }

    function handleLearnSkill(skillId) {
        const classSkills = SKILL_DATA[player.className];
        const skill = classSkills[skillId];
        if (!skill || !isSkillLearnable(skill)) return;
        
        const currentLevel = player.unlockedSkills[skill.id] || 0;
        const cost = skill.cost(currentLevel);

        if (player.gold >= cost) {
            if (confirm(`${skill.name} ${currentLevel + 1} ë ˆë²¨ì„ ${cost} Gì— ë°°ìš°ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                player.gold -= cost;
                player.unlockedSkills[skill.id] = currentLevel + 1;
                recalculatePlayerStats();
                saveGameState();
                renderSkillTreeScreen();
            }
        } else {
            alert("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
        }
    }

    function renderSkillTreeScreen() {
        currentScreen = 'SKILL_TREE';
        const classSkills = SKILL_DATA[player.className];

        const skillsHtml = Object.values(classSkills).map(skill => {
            const currentLevel = player.unlockedSkills[skill.id] || 0;
            const canLearn = isSkillLearnable(skill);
            const cost = skill.cost(currentLevel);
            
            let statusClass = 'locked';
            let buttonText = 'ì ê¹€';
            if (canLearn) {
                statusClass = 'learnable';
                buttonText = `${cost} G`;
            }
            if (currentLevel > 0) {
                statusClass = 'learned';
            }
            
            const hasMaxLevel = 'maxLevel' in skill;
            const levelDisplay = hasMaxLevel ? `[${currentLevel}/${skill.maxLevel}]` : `[Lv. ${currentLevel}]`;

            if (hasMaxLevel && currentLevel >= skill.maxLevel) {
                statusClass = 'maxed';
                buttonText = 'ìµœëŒ€ ë ˆë²¨';
            }

            const prereqText = skill.prerequisites.map(p => `${classSkills[p.id].name} ${p.level}ë ˆë²¨`).join(', ');

            return `
                <div class="skill-node ${statusClass}">
                    <div class="skill-info">
                        <h3>${skill.name} ${levelDisplay}</h3>
                        <p>${skill.description(currentLevel)}</p>
                        <small>ìš”êµ¬ ë ˆë²¨: ${skill.requiredPlayerLevel}${prereqText ? `, ì„ í–‰: ${prereqText}` : ''}</small>
                    </div>
                    <button class="button learn-skill-btn" data-skill-id="${skill.id}" ${!canLearn || player.gold < cost ? 'disabled' : ''}>${buttonText}</button>
                </div>
            `;
        }).join('');

        root.innerHTML = `
            <div class="screen-container skill-tree-screen">
                <h1>ìŠ¤í‚¬ íŠ¸ë¦¬</h1>
                <div class="gold-sp-display top-display">
                    <p>ğŸ’° Gold: ${player.gold}</p>
                    <p>í”Œë ˆì´ì–´ ë ˆë²¨: ${player.level}</p>
                </div>
                <div class="skill-list">
                    ${skillsHtml}
                </div>
                <button id="back-to-town" class="button">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
            </div>
        `;

        document.querySelectorAll('.learn-skill-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const skillId = e.currentTarget.dataset.skillId;
                if (skillId) handleLearnSkill(skillId);
            });
        });

        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }

    function getTodayDateString() {
        const today = new Date();
        return `${today.getFullYear()}-${today.getMonth() + 1}-${today.getDate()}`;
    }

    function generateDailyQuests() {
        const newQuests = [];
        const availableQuestTypes = [...QUEST_POOL];
        
        for (let i = 0; i < 3; i++) {
            if (availableQuestTypes.length === 0) break;
            
            const questIndex = Math.floor(Math.random() * availableQuestTypes.length);
            const questTemplate = availableQuestTypes.splice(questIndex, 1)[0];
            
            const target = questTemplate.targets[Math.floor(Math.random() * questTemplate.targets.length)];

            newQuests.push({
                id: `${questTemplate.type}_${Date.now()}_${i}`,
                type: questTemplate.type,
                description: questTemplate.description(target),
                target: target,
                progress: 0,
                reward: questTemplate.reward,
                isComplete: false,
                isClaimed: false,
            });
        }
        dailyQuests = newQuests;
        lastQuestDate = getTodayDateString();
    }

    function checkAndGenerateQuests() {
        const today = getTodayDateString();
        if (lastQuestDate !== today) {
            generateDailyQuests();
            saveGameState();
        }
    }

    function updateQuestProgress(type, amount) {
        dailyQuests.forEach(quest => {
            if (quest.type === type && !quest.isComplete && !quest.isClaimed) {
                quest.progress = Math.min(quest.target, quest.progress + amount);
                if (quest.progress >= quest.target) {
                    quest.isComplete = true;
                }
            }
        });
        saveGameState();
    }
    
    function updatePermanentQuestProgress(type, value) {
        if (!player.permanentQuests) return;
        player.permanentQuests.forEach(quest => {
            if (quest.type === type && !quest.isComplete) {
                if (type === 'REACH_LEVEL' || type === 'ENHANCE_SUCCESS' || type === 'REBIRTH') {
                    quest.progress = Math.max(quest.progress, value);
                } else if (type === 'DEFEAT_BOSS') {
                    if (value === quest.targetName) {
                        quest.progress++;
                    }
                } else if (type === 'COLLECT_GOLD') {
                    quest.progress += value;
                }
                
                if (quest.progress >= quest.target) {
                    quest.isComplete = true;
                }
            }
        });
    }

    function handleClaimQuestReward(questId) {
        let quest = dailyQuests.find(q => q.id === questId);
        let isDaily = true;
        if (!quest) {
            quest = player.permanentQuests.find(q => q.id === questId);
            isDaily = false;
        }

        if (quest && quest.isComplete && !quest.isClaimed) {
            quest.isClaimed = true;
            if (quest.reward.gold) {
              player.gold += quest.reward.gold;
              if (!isDaily) updatePermanentQuestProgress('COLLECT_GOLD', quest.reward.gold); // Achievements giving gold should count
            }
            if (quest.reward.stones) player.enhancementStones += quest.reward.stones;
            if (quest.reward.potions) player.potions += quest.reward.potions;
            if (quest.reward.dust) player.enchantmentDust += quest.reward.dust;
            saveGameState();
            renderQuestScreen();
        }
    }

    function renderQuestScreen() {
        currentScreen = 'QUESTS';

        const renderList = (quests) => quests.map(quest => {
            const progressPercent = Math.min(100, (quest.progress / quest.target) * 100);
            const rewardText = Object.entries(quest.reward)
                .map(([type, value]) => {
                    if (type === 'gold') return `ğŸ’° ${value}`;
                    if (type === 'stones') return `ğŸ’ ${value}`;
                    if (type === 'potions') return `ğŸ§ª ${value}`;
                    if (type === 'dust') return `âœ¨ ${value}`;
                    return '';
                })
                .join(' / ');
            
            let buttonHtml = '';
            if (quest.isClaimed) {
                buttonHtml = `<button class="button" disabled>ì™„ë£Œ</button>`;
            } else if (quest.isComplete) {
                buttonHtml = `<button class="button claim-quest-btn" data-quest-id="${quest.id}">ë³´ìƒ ë°›ê¸°</button>`;
            } else {
                buttonHtml = `<button class="button" disabled>ì§„í–‰ ì¤‘</button>`;
            }

            return `
                <div class="quest-item">
                    <div class="quest-info">
                        <p class="quest-description">${quest.description}</p>
                        <div class="quest-progress-bar-container">
                            <div class="quest-progress-bar" style="width: ${progressPercent}%;"></div>
                        </div>
                        <p class="quest-progress-text">${quest.progress} / ${quest.target}</p>
                        <p class="quest-reward">ë³´ìƒ: ${rewardText}</p>
                    </div>
                    <div class="quest-action">
                        ${buttonHtml}
                    </div>
                </div>
            `;
        }).join('');
        
        const questsHtml = questScreenMode === 'daily' ? renderList(dailyQuests) : renderList(player.permanentQuests);

        root.innerHTML = `
            <div class="screen-container quest-screen">
                <h1>í€˜ìŠ¤íŠ¸</h1>
                 <div class="quest-tabs">
                    <button id="tab-daily" class="tab-button ${questScreenMode === 'daily' ? 'active' : ''}">ì¼ì¼</button>
                    <button id="tab-permanent" class="tab-button ${questScreenMode === 'permanent' ? 'active' : ''}">ì˜êµ¬</button>
                </div>
                <div class="quest-list">
                    ${questsHtml.length > 0 ? questsHtml : '<p>ì™„ë£Œí•  í€˜ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>'}
                </div>
                <button id="back-to-town" class="button">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
            </div>
        `;

        document.getElementById('tab-daily')?.addEventListener('click', () => { questScreenMode = 'daily'; renderQuestScreen(); });
        document.getElementById('tab-permanent')?.addEventListener('click', () => { questScreenMode = 'permanent'; renderQuestScreen(); });

        document.querySelectorAll('.claim-quest-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const questId = e.currentTarget.dataset.questId;
                if(questId) handleClaimQuestReward(questId);
            });
        });

        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }
    
    // --- Survival Mode ---
    function startSurvivalDungeon() {
        currentScreen = 'SURVIVAL';
        survivalWave = 1;
        player.hp = player.maxHp;
        player.statusEffects = [];
        player.activeBuffs = [];
        player.ultimateSkillCooldown = 0;
        recalculatePlayerStats();
        messageLog = ['ì„œë°”ì´ë²Œ ë˜ì „ì— ì§„ì…í–ˆë‹¤.'];
        spawnSurvivalMonster();
        renderSurvivalDungeonScreen();
    }

    function spawnSurvivalMonster() {
        const isBossWave = survivalWave % 5 === 0;
        let monsterData;

        if (isBossWave) {
            const bossIndex = Math.min(Math.floor(survivalWave / 5) - 1, bossList.length - 1);
            monsterData = bossList[bossIndex];
        } else {
            const monsterIndex = Math.floor(Math.random() * monsterList.length);
            monsterData = monsterList[monsterIndex];
        }

        const waveModifier = 1 + (survivalWave - 1) * 0.1;

        monster = {
            name: `${monsterData.name} (Wave ${survivalWave})`,
            emoji: monsterData.emoji,
            maxHp: Math.floor(monsterData.baseHp * waveModifier),
            hp: Math.floor(monsterData.baseHp * waveModifier),
            attackPower: Math.floor(monsterData.baseAttack * waveModifier),
            defense: 0,
            statusEffects: [],
        };
    }
    
    function renderSurvivalDungeonScreen() {
        const ultimateSkill = ULTIMATE_SKILLS[player.className];
        const cooldown = player.ultimateSkillCooldown;
        const disabled = cooldown > 0;
        const skillButton = `<button data-action="ultimate" class="button skill-button" ${disabled ? 'disabled' : ''}>${ultimateSkill.name} ${disabled ? `(${cooldown})` : ''}</button>`;

        root.innerHTML = `
            <div id="game-world">
                ${createCharacterCard(monster, false)}
                ${createCharacterCard(player, true)}
            </div>
            <div id="message-log">${messageLog.map(msg => `<p>${msg}</p>`).join('')}</div>
            <div id="action-buttons">
                <button data-action="attack" class="button">ê³µê²©</button>
                <button data-action="potion" class="button" ${player.potions <= 0 ? 'disabled' : ''}>ë¬¼ì•½ (${player.potions})</button>
                ${skillButton}
            </div>
        `;
        document.getElementById('action-buttons')?.addEventListener('click', handleSurvivalAction);
    }
    
    function handleSurvivalAction(event) {
        const button = event.target.closest('button');
        if (!button || button.disabled) return;
        const action = button.dataset.action;

        const isStunned = processStatusEffects(player);
        if (isStunned) {
            addMessage(`ğŸ’« ${player.name}ì€(ëŠ”) ê¸°ì ˆí•´ì„œ ì›€ì§ì¼ ìˆ˜ ì—†ë‹¤!`);
            handleSurvivalMonsterTurn();
            return;
        }

        if (player.ultimateSkillCooldown > 0) player.ultimateSkillCooldown--;
        player.activeBuffs = player.activeBuffs.map(b => ({...b, duration: b.duration - 1})).filter(b => b.duration > 0);
        recalculatePlayerStats();

        if (action === 'attack') handleAttack();
        if (action === 'potion') handleUsePotion();
        if (action === 'ultimate') handleUseUltimateSkill();

        if (monster.hp <= 0) {
            handleSurvivalMonsterDefeated();
        } else {
            handleSurvivalMonsterTurn();
        }
    }
    
    function handleSurvivalMonsterTurn() {
        const isStunned = processStatusEffects(monster);
        if (isStunned) {
            addMessage(`ğŸ’« ${monster.name}ì€(ëŠ”) ê¸°ì ˆí•´ì„œ ì›€ì§ì¼ ìˆ˜ ì—†ë‹¤!`);
        } else {
            monsterAttack();
        }
        
        if (player.hp <= 0) {
            handleSurvivalDefeat();
        } else {
            renderSurvivalDungeonScreen();
        }
    }

    function handleSurvivalMonsterDefeated() {
        addMessage(`ğŸ‰ Wave ${survivalWave} í´ë¦¬ì–´!`);

        if (survivalWave % 5 === 0) {
            renderSurvivalRewardScreen();
        } else {
            survivalWave++;
            spawnSurvivalMonster();
            renderSurvivalDungeonScreen();
        }
    }
    
    function renderSurvivalRewardScreen() {
        const rewards = [
            { id: 'heal', text: 'ì²´ë ¥ ì™„ì „ íšŒë³µ' },
            { id: 'potion', text: 'ë¬¼ì•½ 1ê°œ íšë“' },
            { id: 'buff_atk', text: 'ë‹¤ìŒ 5ì›¨ì´ë¸Œ ë™ì•ˆ ê³µê²©ë ¥ 20% ì¦ê°€' }
        ];

        root.innerHTML = `
            <div class="screen-container">
                <h1>íœ´ì‹</h1>
                <p>Wave ${survivalWave}ë¥¼ í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤! ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”.</p>
                <div class="difficulty-selection">
                    ${rewards.map(r => `<button class="difficulty-card" data-reward-id="${r.id}"><h2>${r.text}</h2></button>`).join('')}
                </div>
            </div>
        `;
        document.querySelectorAll('.difficulty-card').forEach(card => {
            card.addEventListener('click', e => {
                const rewardId = e.currentTarget.dataset.rewardId;
                applySurvivalReward(rewardId);
                survivalWave++;
                spawnSurvivalMonster();
                renderSurvivalDungeonScreen();
            });
        });
    }

    function applySurvivalReward(rewardId) {
        if (rewardId === 'heal') {
            player.hp = player.maxHp;
            addMessage('ì²´ë ¥ì„ ëª¨ë‘ íšŒë³µí–ˆë‹¤.');
        } else if (rewardId === 'potion') {
            player.potions++;
            addMessage('ë¬¼ì•½ì„ 1ê°œ ì–»ì—ˆë‹¤.');
        } else if (rewardId === 'buff_atk') {
            player.activeBuffs.push({ name: 'ìƒì¡´ ë²„í”„', duration: 6, effect: { stat: 'attackPower', value: 0.2, isPercent: true } });
            addMessage('ê³µê²©ë ¥ì´ ì¼ì‹œì ìœ¼ë¡œ ì¦ê°€í–ˆë‹¤.');
        }
        recalculatePlayerStats();
    }
    
    function handleSurvivalDefeat() {
        const goldEarned = Math.floor(survivalWave * 15 * DIFFICULTY_SETTINGS[currentDifficulty].rewardMod);
        player.gold += goldEarned;
        player.survivalHighScore = Math.max(player.survivalHighScore, survivalWave);
        
        updateQuestProgress('EARN_GOLD', goldEarned);
        updatePermanentQuestProgress('COLLECT_GOLD', goldEarned);

        messageLog = [`ì„œë°”ì´ë²Œ ëª¨ë“œì—ì„œ ì“°ëŸ¬ì¡Œë‹¤. ìµœì¢… ì›¨ì´ë¸Œ: ${survivalWave}. ê³¨ë“œ ${goldEarned}G íšë“.`];
        
        player.hp = player.maxHp;
        player.statusEffects = [];
        player.activeBuffs = [];
        recalculatePlayerStats();
        saveGameState();
        renderTownScreen();
    }
    
    // --- Rebirth System ---
    function renderRebirthScreen() {
        currentScreen = 'REBIRTH';
        const pointsToGain = Math.floor(player.level / 10);

        const upgradesHtml = Object.entries(REBIRTH_UPGRADES).map(([id, upgrade]) => {
            const currentLevel = player.rebirthUpgrades[id] || 0;
            const cost = upgrade.cost(currentLevel);
            const isMaxed = upgrade.maxLevel && currentLevel >= upgrade.maxLevel;
            
            return `
                <div class="rebirth-upgrade-item">
                    <div class="rebirth-upgrade-info">
                        <h3>${upgrade.name} (Lv. ${currentLevel}${upgrade.maxLevel ? `/${upgrade.maxLevel}` : ''})</h3>
                        <p>${upgrade.description(currentLevel)}</p>
                    </div>
                    <button class="button" data-upgrade-id="${id}" ${player.rebirthPoints < cost || isMaxed ? 'disabled' : ''}>
                        ${isMaxed ? 'ìµœëŒ€ ë ˆë²¨' : `${cost} RP`}
                    </button>
                </div>
            `;
        }).join('');

        root.innerHTML = `
            <div class="screen-container rebirth-screen">
                <h1>í™˜ìƒ</h1>
                <div class="rebirth-info">
                    <p>í™˜ìƒ íšŸìˆ˜: ${player.rebirths}íšŒ</p>
                    <p>ë³´ìœ  í¬ì¸íŠ¸: <span class="rebirth-points">${player.rebirthPoints} RP</span></p>
                    <p>í™˜ìƒ ì‹œ ë ˆë²¨, ê³¨ë“œ, ë˜ì „ ì§„í–‰ë„ê°€ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.</p>
                    <p>ì¥ë¹„, ì•„ì´í…œ, ìŠ¤í‚¬, í™˜ìƒ ì—…ê·¸ë ˆì´ë“œëŠ” ìœ ì§€ë©ë‹ˆë‹¤.</p>
                    <p>ì´ë²ˆ í™˜ìƒ ì‹œ <span class="rebirth-points">${pointsToGain} RP</span>ë¥¼ ì–»ìŠµë‹ˆë‹¤.</p>
                    <button id="rebirth-confirm-button" class="button">í™˜ìƒí•˜ê¸°</button>
                </div>
                <h2>ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ</h2>
                <div class="rebirth-upgrades">${upgradesHtml}</div>
                <button id="back-to-town" class="button">ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°</button>
            </div>
        `;
        document.getElementById('rebirth-confirm-button')?.addEventListener('click', handleRebirth);
        document.querySelectorAll('.rebirth-upgrade-item button').forEach(button => {
            button.addEventListener('click', e => {
                const upgradeId = e.currentTarget.dataset.upgradeId;
                handleBuyRebirthUpgrade(upgradeId);
            });
        });
        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }

    function handleRebirth() {
        if (confirm('ì •ë§ë¡œ í™˜ìƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            const pointsGained = Math.floor(player.level / 10);
            
            player.rebirths++;
            player.rebirthPoints += pointsGained;
            updatePermanentQuestProgress('REBIRTH', player.rebirths);

            // Reset progress
            player.level = 1;
            player.xp = 0;
            player.xpToNextLevel = 100;
            player.gold = DIFFICULTY_SETTINGS[currentDifficulty].startGold;
            dungeonLevel = 1;

            // Reset skills
            player.unlockedSkills = {};
            
            recalculatePlayerStats();
            player.hp = player.maxHp;

            messageLog = [`${player.rebirths}ë²ˆì§¸ í™˜ìƒì„ ì™„ë£Œí–ˆë‹¤. ë”ìš± ê°•í•´ì§„ ê¸°ë¶„ì´ë‹¤.`];
            saveGameState();
            renderTownScreen();
        }
    }

    function handleBuyRebirthUpgrade(upgradeId) {
        const upgrade = REBIRTH_UPGRADES[upgradeId];
        const currentLevel = player.rebirthUpgrades[upgradeId] || 0;
        const cost = upgrade.cost(currentLevel);

        if (player.rebirthPoints >= cost) {
            player.rebirthPoints -= cost;
            player.rebirthUpgrades[upgradeId]++;
            recalculatePlayerStats(); // Recalculate stats immediately
            saveGameState();
            renderRebirthScreen();
        }
    }

    function saveGameState() {
        const gameState = {
            player,
            dungeonLevel,
            currentDifficulty,
            dailyQuests,
            lastQuestDate,
        };
        localStorage.setItem('rpg_save', JSON.stringify(gameState));
    }

    function loadGameState() {
        const savedState = localStorage.getItem('rpg_save');
        if (savedState) {
            try {
                const gameState = JSON.parse(savedState);
                if (!gameState.player || !gameState.player.className || !CLASSES[gameState.player.className]) {
                    throw new Error("Invalid or corrupted player data in save file.");
                }

                player = gameState.player;
                dungeonLevel = gameState.dungeonLevel;
                currentDifficulty = gameState.currentDifficulty || 'ë³´í†µ';
                dailyQuests = gameState.dailyQuests || [];
                lastQuestDate = gameState.lastQuestDate || '';

                // --- Migration Logic for new updates ---
                if (player.survivalTokens) delete player.survivalTokens; // Remove old token data
                if (!player.unlockedSkills) player.unlockedSkills = {};
                if (!player.inventory) player.inventory = [];
                if (!player.activeBuffs) player.activeBuffs = [];
                if (!player.statusEffects) player.statusEffects = [];
                if (!player.equipment) player.equipment = { weapon: null, armor: null, accessory: null };
                if (player.equipment.accessory === undefined) player.equipment.accessory = null;
                if (!player.enchantmentDust) player.enchantmentDust = 0;
                if (!player.survivalHighScore) player.survivalHighScore = 0;
                if (!player.rebirths) player.rebirths = 0;
                if (!player.rebirthPoints) player.rebirthPoints = 0;
                if (!player.rebirthUpgrades) {
                    player.rebirthUpgrades = {};
                    Object.keys(REBIRTH_UPGRADES).forEach(key => player.rebirthUpgrades[key] = 0);
                } else {
                    Object.keys(REBIRTH_UPGRADES).forEach(key => {
                        if (player.rebirthUpgrades[key] === undefined) player.rebirthUpgrades[key] = 0;
                    });
                }
                
                if (!player.permanentQuests) {
                    player.permanentQuests = JSON.parse(JSON.stringify(PERMANENT_QUESTS_DATA)).map(q => ({...q, progress: 0, isComplete: false, isClaimed: false }));
                } else {
                    PERMANENT_QUESTS_DATA.forEach(questTemplate => {
                        if (!player.permanentQuests.find(pq => pq.id === questTemplate.id)) {
                            player.permanentQuests.push({
                                ...JSON.parse(JSON.stringify(questTemplate)),
                                progress: 0, isComplete: false, isClaimed: false
                            });
                        }
                    });
                }

                [...player.inventory, player.equipment.weapon, player.equipment.armor, player.equipment.accessory].forEach(item => {
                    if (item && item.enchantment === undefined) {
                        item.enchantment = null;
                    }
                    if (item && item.type === 'accessory' && !item.classRestriction) {
                        item.classRestriction = ['ì „ì‚¬', 'ë§ˆë²•ì‚¬', 'ë„ì ']; // Accessories are for all classes
                    }
                });
                
                if (player.baseStats && Object.keys(player.baseStats).length === 0) { // Fix for empty baseStats object
                     recalculatePlayerStats();
                } else {
                     player.baseStats = {}; // Force a full recalc
                     recalculatePlayerStats();
                }

                messageLog = ['ê²Œì„ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.'];
                
                if (player.hp > player.maxHp || player.hp === undefined || player.hp === null || isNaN(player.hp) || player.hp <= 0) {
                    player.hp = player.maxHp;
                }

                return true;
            } catch (error) {
                console.error("Failed to parse or migrate saved game state:", error);
                localStorage.removeItem('rpg_save');
                return false;
            }
        }
        return false;
    }

    function initializeApp() {
        const resetButton = document.createElement('button');
        resetButton.id = 'reset-button';
        resetButton.textContent = 'ê²Œì„ ì´ˆê¸°í™”';
        resetButton.addEventListener('click', () => {
            if (confirm('ì •ë§ë¡œ ëª¨ë“  ì§„í–‰ ìƒí™©ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
                localStorage.removeItem('rpg_save');
                location.reload();
            }
        });
        document.body.appendChild(resetButton);

        if (loadGameState()) {
            checkAndGenerateQuests();
            renderTownScreen();
        } else {
            createStartScreen();
        }
    }

    window.addEventListener('DOMContentLoaded', initializeApp);
  </script>
</body>
</html>