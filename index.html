<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Í∞ÑÎã®RPG</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚öîÔ∏è</text></svg>">
  <style>
    :root {
      --primary-bg: #2c3e50;
      --secondary-bg: #34495e;
      --border-color: #7f8c8d;
      --text-color: #ecf0f1;
      --player-hp-color: #2ecc71;
      --monster-hp-color: #e74c3c;
      --xp-bar-color: #3498db;
      --button-bg: #3498db;
      --button-hover-bg: #2980b9;
      --button-disabled-bg: #95a5a6;
      --skill-learned-bg: #27ae60;
      --skill-learnable-bg: #f1c40f;
      --skill-locked-bg: #7f8c8d;
      --skill-maxed-bg: #e67e22;
      --disenchant-color: #9b59b6;
      --enchant-color: #e67e22;
      --rebirth-color: #e74c3c;
      --survival-color: #1abc9c;

      --rarity-common: #ecf0f1;
      --rarity-uncommon: #2ecc71;
      --rarity-rare: #3498db;
      --rarity-legendary: #f39c12;
      --rarity-mythic: #e74c3c;
      --rarity-ultimate: #00e6e6;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: var(--primary-bg);
      color: var(--text-color);
      user-select: none;
      transition: background-color 0.3s, color 0.3s;
    }

    #root {
      width: 100%;
      max-width: 400px;
      height: 100%;
      max-height: 700px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 0.8rem;
      box-sizing: border-box;
      background-color: var(--secondary-bg);
      border-radius: 12px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
      transition: background-color 0.3s, box-shadow 0.3s;
    }

    .screen-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    .town-screen {
        justify-content: space-around;
    }

    .town-screen .player-card {
        margin: 0.8rem 0;
    }

    /* Difficulty & Class Selection */
    .difficulty-selection,
    .class-selection {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        width: 100%;
        margin-top: 1.2rem;
    }
    .difficulty-card,
    .class-card {
        background-color: rgba(0,0,0,0.2);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.8rem;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s;
        color: var(--text-color);
        font-family: inherit;
        text-align: left;
        width: 100%;
        box-sizing: border-box;
    }
    .difficulty-card:hover,
    .class-card:hover {
        background-color: var(--secondary-bg);
        transform: translateY(-3px);
    }
    .difficulty-card h2,
    .class-card h2 {
        margin: 0 0 0.4rem 0;
        color: var(--button-bg);
        font-size: 1.2rem;
    }
    .difficulty-card p,
    .class-card p {
        margin: 0;
        font-size: 0.75rem;
        line-height: 1.4;
    }


    h1 {
      margin-bottom: 0.8rem;
      font-size: 2rem;
    }

    h2.inventory-full {
        color: var(--monster-hp-color);
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }


    .logo {
        font-size: 2.8rem;
        font-weight: 700;
        color: var(--skill-learnable-bg);
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px var(--rarity-legendary);
        margin-bottom: 1.5rem;
        letter-spacing: 2px;
    }

    p {
      line-height: 1.5;
    }

    #game-world {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }

    .character-card {
        background-color: rgba(0,0,0,0.2);
        padding: 0.8rem;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        transition: background-color 0.3s;
    }

    .character-card h2 {
        margin: 0 0 0.4rem 0;
        font-size: 1.2rem;
        white-space: pre-wrap;
    }

    .player-header {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        gap: 0.4rem;
        margin-bottom: 0.4rem;
    }

    .player-header h2 {
        margin: 0;
        text-align: left;
        overflow: hidden;
        text-overflow: ellipsis;
        display: flex;
        align-items: center;
    }
    .player-class {
        color: #bdc3c7;
        font-size: 0.8rem;
    }
    .inventory-warning {
        color: var(--monster-hp-color);
        font-weight: bold;
        font-size: 0.7rem;
    }

    .dungeon-progress {
        text-align: center;
        font-weight: bold;
        color: var(--xp-bar-color);
        margin: 0 0 0.4rem 0 !important;
        padding-bottom: 0.4rem;
        border-bottom: 1px solid var(--border-color);
        font-size: 0.9rem;
    }

    .hp-bar-container, .xp-bar-container {
        width: 100%;
        height: 16px;
        background-color: #2c3e50;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid var(--border-color);
        margin-top: 0.4rem;
        transition: background-color 0.3s;
    }

    .hp-bar, .xp-bar {
        height: 100%;
        transition: width 0.3s ease-in-out;
    }

    .player-card .hp-bar {
        background-color: var(--player-hp-color);
    }

    .monster-card .hp-bar {
        background-color: var(--monster-hp-color);
    }

    .xp-bar {
        background-color: var(--xp-bar-color);
    }

    .character-card p {
        margin: 0.4rem 0 0 0;
        text-align: right;
        font-weight: bold;
        font-size: 0.75rem;
    }

    .gold-display {
        font-size: 0.9rem;
        font-weight: bold;
        margin-bottom: 0.8rem;
    }

    .gold-sp-display {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        font-size: 0.75rem;
        font-weight: bold;
    }
    .gold-sp-display p {
        margin: 0;
    }
    .gold-sp-display.top-display {
        width: 100%;
        flex-direction: row;
        justify-content: space-around;
        background: rgba(0,0,0,0.2);
        padding: 0.4rem;
        border-radius: 8px;
        margin-bottom: 0.8rem;
        transition: background-color 0.3s;
    }


    .player-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.4rem;
        justify-content: space-around;
        margin-top: 0.8rem;
        padding-top: 0.6rem;
        border-top: 1px solid var(--border-color);
        font-size: 0.8rem;
        font-weight: bold;
    }
    .player-equipment {
        grid-column: 1 / -1;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.4rem;
        margin-top: 0.4rem;
        padding-top: 0.4rem;
        border-top: 1px solid var(--border-color);
        font-size: 0.75rem;
        text-align: center;
    }

    .ultimate-skill-display {
        grid-column: 1 / -1;
        margin-top: 0.4rem;
        padding-top: 0.4rem;
        border-top: 1px solid var(--border-color);
        font-size: 0.75rem;
        text-align: center;
    }

    .player-buffs {
        grid-column: 1 / -1;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        margin-top: 0.4rem;
        justify-content: center;
    }
    .buff-icon {
        background-color: var(--button-bg);
        color: white;
        padding: 0.15rem 0.3rem;
        border-radius: 4px;
        font-size: 0.65rem;
        font-weight: bold;
    }

    .status-effects {
        display: flex;
        gap: 0.4rem;
        margin-top: 0.4rem;
        min-height: 18px;
    }
    .status-effect-icon {
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        padding: 0.1rem 0.3rem;
        border-radius: 4px;
        font-size: 0.65rem;
        font-weight: bold;
    }

    #message-log {
        width: 100%;
        height: 120px;
        background-color: rgba(0,0,0,0.3);
        border-radius: 8px;
        padding: 0.4rem 0.8rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column-reverse;
        box-sizing: border-box;
        border: 1px solid var(--border-color);
        margin: 0.8rem 0;
        transition: background-color 0.3s;
    }

    #message-log p {
        margin: 0.2rem 0;
        font-size: 0.75rem;
        border-bottom: 1px solid #4a637e;
        padding-bottom: 0.2rem;
    }
    #message-log p:first-child {
        border-bottom: none;
    }

    #action-buttons {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        gap: 0.4rem;
    }
    .town-actions {
        grid-template-columns: 1fr 1fr;
        gap: 0.6rem;
    }

    .town-actions .button {
        padding: 0.5rem;
        font-size: 0.75rem;
    }


    .button {
      padding: 0.65rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: white;
      background-color: var(--button-bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
      text-align: center;
      white-space: nowrap;
      position: relative;
    }

    .button:hover {
      background-color: var(--button-hover-bg);
    }

    .button:active {
      transform: scale(0.98);
    }

    .button:disabled {
        background-color: var(--button-disabled-bg);
        cursor: not-allowed;
        transform: none;
    }

    .button:disabled:hover {
        background-color: var(--button-disabled-bg);
    }

    .notification-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        background-color: var(--monster-hp-color);
        color: white;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7rem;
        font-weight: bold;
        box-shadow: 0 0 4px rgba(0,0,0,0.5);
    }


    /* Shop & etc. Styles */
    .shop-container, .skill-tree-screen, .rebirth-screen, .survival-shop-screen {
        justify-content: flex-start;
        padding-top: 0.8rem;
    }
    .shop-items, .skill-list, .rebirth-upgrades, .survival-items {
        width: 100%;
        margin-top: 0.8rem;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        overflow-y: auto;
        flex-grow: 1;
    }
    .shop-item, .rebirth-upgrade-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(0,0,0,0.2);
        padding: 0.6rem 0.8rem;
        border-radius: 8px;
        transition: background-color 0.3s;
    }
    .shop-item span, .rebirth-upgrade-info h3 {
        font-size: 0.8rem;
        font-weight: 500;
        margin: 0;
    }
    .shop-item .item-class {
        font-size: 0.65rem;
        color: var(--border-color);
        margin-left: 0.4rem;
    }

    .shop-item .button, .rebirth-upgrade-item .button {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
        min-width: 65px;
    }
    #back-to-town {
        margin-top: auto;
        width: 100%;
    }

    .shop-filters {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        margin-bottom: 0.8rem;
    }
    .filter-group {
        display: flex;
        gap: 0.4rem;
        background: rgba(0,0,0,0.2);
        padding: 0.4rem;
        border-radius: 8px;
        transition: background-color 0.3s;
    }
    .filter-btn {
        flex-grow: 1;
        padding: 0.3rem;
        font-size: 0.7rem;
        color: var(--text-color);
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s;
    }
    .filter-btn:hover {
        background-color: var(--primary-bg);
    }
    .filter-btn.active {
        background-color: var(--button-bg);
        border-color: var(--button-hover-bg);
        font-weight: bold;
        color: white;
    }

    /* Equipment Screen Styles */
    .equipment-screen {
        justify-content: flex-start;
    }
    .equipment-screen h1 {
        margin-bottom: 0.4rem;
        font-size: 1.5rem;
    }
    .equipment-screen h2 {
        margin-top: 1.2rem;
        margin-bottom: 0.4rem;
        font-size: 1.2rem;
    }

    .equipment-slots {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.8rem;
        width: 100%;
        margin: 0.8rem 0 0 0;
    }
    .slot-container h3 {
        margin: 0 0 0.4rem 0;
        font-size: 0.8rem;
    }
    .inventory-grid {
        width: 100%;
        flex-grow: 1;
        overflow-y: auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.4rem;
        padding: 0.4rem;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        border: 2px solid transparent;
        transition: border-color 0.3s;
        min-height: 120px;
    }
    .item-card {
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.6rem;
        cursor: pointer;
        transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
    }
    .item-card:hover {
        background-color: var(--primary-bg);
    }
    .item-card.empty {
        display: flex;
        justify-content: center;
        align-items: center;
        color: var(--border-color);
        font-style: italic;
        cursor: default;
        font-size: 0.75rem;
        min-height: 80px;
    }
    .item-card.empty:hover {
        background-color: var(--secondary-bg);
    }
    .item-card.restricted {
        opacity: 0.6;
    }
    .restricted-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5);
        color: var(--monster-hp-color);
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: 0.8rem;
        border-radius: 8px;
        pointer-events: none;
    }
    .item-card .item-name {
        font-weight: bold;
        margin: 0;
        font-size: 0.8rem;
    }
    .item-card .item-class {
        font-size: 0.65rem;
        color: var(--border-color);
        font-style: italic;
        margin: 0;
    }
    .item-card .item-stats {
        font-size: 0.65rem;
        color: #bdc3c7;
        margin: 0;
    }
    .item-card .item-enchantment {
        font-size: 0.7rem;
        font-weight: bold;
        color: var(--enchant-color);
        margin-top: 0.2rem;
    }

    .equipment-screen-footer {
        width: 100%;
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.8rem;
        margin-top: auto;
        padding-top: 0.8rem;
    }


    /* Blacksmith Screen Styles */
    .blacksmith-screen {
        justify-content: flex-start;
    }
    .blacksmith-screen h1 { margin-bottom: 0.4rem; }
    .blacksmith-tabs {
        display: flex;
        width: 100%;
        margin-bottom: 0.8rem;
    }
    .tab-button {
        flex: 1;
        padding: 0.6rem;
        font-size: 0.7rem;
        font-weight: bold;
        color: var(--text-color);
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        border-bottom-width: 2px;
    }
    .tab-button:first-child {
        border-top-left-radius: 8px;
    }
    .tab-button:last-child {
        border-top-right-radius: 8px;
    }
    .tab-button:not(:first-child) {
        border-left: none;
    }
    .tab-button.active {
        background-color: var(--primary-bg);
        border-bottom: 2px solid var(--button-bg);
    }

    #blacksmith-content {
        width: 100%;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .enhancement-slots {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 0.8rem;
        width: 100%;
        margin-bottom: 0.8rem;
    }
    .enhancement-slot {
        text-align: center;
    }
    .enhancement-slot h3 {
        margin: 0 0 0.4rem;
        font-size: 0.9rem;
    }
    #enhancement-details {
        width: 100%;
        min-height: 120px;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        padding: 0.8rem;
        box-sizing: border-box;
        transition: background-color 0.3s;
    }
    #enhancement-details h3 {
        margin: 0 0 0.8rem;
        color: var(--xp-bar-color);
        font-size: 1.1rem;
    }
    .enhancement-info {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        margin-bottom: 0.8rem;
    }
    .info-row {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem;
    }
    .cost-display {
        font-weight: bold;
    }
    .next-stats {
        display: flex;
        gap: 0.4rem;
        font-weight: bold;
        color: var(--player-hp-color);
    }
    .penalty-info {
        font-size: 0.65rem;
        color: var(--monster-hp-color);
        margin: 0 0 0.8rem;
    }
    #enhance-button, #enchant-button {
        width: 100%;
    }
    .current-enchantment {
        font-size: 0.75rem;
        color: var(--enchant-color);
        margin-bottom: 0.4rem;
        font-style: italic;
    }
    .enchant-warning {
        font-size: 0.65rem;
        color: var(--skill-learnable-bg);
        margin: 0 0 0.8rem;
    }

    /* Disenchant Styles */
    .blacksmith-screen h2 { margin: 0 0 0.4rem 0; font-size: 1rem; }
    .inventory-grid.disenchant-mode {
        border-color: var(--disenchant-color);
    }
    .item-card.disenchantable:hover {
        box-shadow: 0 0 8px var(--disenchant-color);
    }
    .disenchant-overlay {
        position: absolute;
        bottom: 0; left: 0; right: 0;
        background: linear-gradient(to top, var(--disenchant-color), transparent);
        color: white;
        text-align: center;
        font-weight: bold;
        font-size: 0.75rem;
        padding: 1rem 0 0.2rem 0;
        pointer-events: none;
    }

    /* Synthesis Styles */
    .synthesis-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      gap: 0.8rem;
    }
    .synthesis-main {
      display: flex;
      align-items: center;
      justify-content: space-around;
      background-color: rgba(0,0,0,0.2);
      padding: 0.8rem;
      border-radius: 8px;
    }
    .synthesis-slots {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .synthesis-slot {
      width: 100px;
      height: 120px;
    }
    .synthesis-symbol {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--border-color);
      padding: 0 0.4rem;
    }
    .synthesis-result-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.4rem;
      text-align: center;
      min-width: 100px;
    }
    .synthesis-result-area .item-card {
        cursor: default;
    }
    .synthesis-result-area .item-card:hover {
        background-color: var(--secondary-bg);
    }
    .synthesis-result-area .button {
        padding: 0.4rem 0.8rem;
        font-size: 0.75rem;
    }
    .synthesis-result-area p { margin: 0; font-size: 0.75rem; font-weight: bold; }

    .inventory-grid.synthesis-mode .item-card.unselectable {
      opacity: 0.4;
      cursor: not-allowed;
      background-color: var(--primary-bg);
    }
    .inventory-grid.synthesis-mode .item-card.unselectable:hover {
        box-shadow: none;
    }
    .inventory-grid.synthesis-mode .item-card.selected {
      border-color: var(--skill-learnable-bg);
      box-shadow: 0 0 8px var(--skill-learnable-bg);
    }


    /* Skill Tree Styles */
    .skill-node {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(0,0,0,0.2);
        padding: 0.6rem 0.8rem;
        border-radius: 8px;
        border-left: 4px solid var(--skill-locked-bg);
        transition: background-color 0.3s;
    }
    .skill-node.learnable { border-color: var(--skill-learnable-bg); }
    .skill-node.learned { border-color: var(--skill-learned-bg); }
    .skill-node.maxed { border-color: var(--skill-maxed-bg); }

    .skill-node.locked {
        opacity: 0.6;
    }

    .skill-info {
        text-align: left;
        flex-grow: 1;
    }
    .skill-info h3 {
        margin: 0 0 0.2rem;
        font-size: 0.9rem;
    }
    .skill-info p {
        margin: 0 0 0.2rem;
        font-size: 0.75rem;
    }
    .skill-info small {
        font-size: 0.65rem;
        color: var(--border-color);
    }
    .learn-skill-btn {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
        min-width: 70px;
    }
    .skill-node.learnable .learn-skill-btn {
        background-color: var(--skill-learnable-bg);
        color: #2c3e50;
    }


    /* Quest Screen Styles */
    .quest-screen {
        justify-content: flex-start;
    }
    .quest-screen h1 {
        margin-bottom: 0;
    }
    .quest-list {
        width: 100%;
        flex-grow: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }
    .quest-item {
        display: flex;
        justify-content: space-between;
        align-items: stretch;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        padding: 0.8rem;
        gap: 0.8rem;
        transition: background-color 0.3s;
    }
    .quest-info {
        flex-grow: 1;
        text-align: left;
    }
    .quest-description {
        font-weight: bold;
        font-size: 0.9rem;
        margin: 0 0 0.4rem 0;
    }
    .quest-progress-bar-container {
        height: 10px;
        background-color: var(--primary-bg);
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 0.2rem;
    }
    .quest-progress-bar {
        height: 100%;
        background-color: var(--xp-bar-color);
        transition: width 0.3s;
    }
    .quest-progress-text {
        font-size: 0.65rem;
        text-align: right;
        margin: 0 0 0.4rem 0;
        color: var(--border-color);
    }
    .quest-reward {
        font-size: 0.75rem;
        margin: 0;
        font-weight: bold;
    }
    .quest-action {
        display: flex;
        align-items: center;
    }
    .quest-action .button {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
    }

    .quest-tabs {
        display: flex;
        width: 100%;
        margin: 0.8rem 0;
    }


    /* Rarity Colors */
    .rarity-common { color: var(--rarity-common); }
    .rarity-uncommon { color: var(--rarity-uncommon); }
    .rarity-rare { color: var(--rarity-rare); }
    .rarity-legendary { color: var(--rarity-legendary); }
    .rarity-mythic { color: var(--rarity-mythic); }
    .rarity-ultimate { color: var(--rarity-ultimate); }

    #message-log .rarity-uncommon, #message-log .rarity-rare, #message-log .rarity-legendary, #message-log .rarity-mythic, #message-log .rarity-ultimate {
        font-weight: bold;
    }
    
    #creator-credit {
        position: fixed;
        top: 10px;
        right: 10px;
        font-size: 0.7rem;
        color: var(--border-color);
        z-index: 1000;
    }

    /* Rebirth screen styles */
    .rebirth-info {
        background: rgba(0,0,0,0.2);
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1rem;
        width: 100%;
        box-sizing: border-box;
        transition: background-color 0.3s;
    }
    .rebirth-info p {
        margin: 0.5rem 0;
        font-size: 0.9rem;
    }
    .rebirth-points {
        color: var(--rebirth-color);
        font-weight: bold;
    }
    .rebirth-upgrade-info p {
        font-size: 0.8rem;
        margin: 0;
    }

    /* Guide Button & Modal Styles */
    #guide-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 60px;
        height: 60px;
        background-color: var(--skill-learnable-bg);
        color: var(--primary-bg);
        border-radius: 50%;
        border: none;
        font-size: 2rem;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
        transition: transform 0.2s;
    }
    #guide-button:hover {
        transform: scale(1.1);
    }

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        z-index: 2000;
        padding: 1rem;
        box-sizing: border-box;
    }

    .modal-content {
        background-color: var(--primary-bg);
        padding: 1.5rem;
        border-radius: 12px;
        width: 100%;
        max-width: 500px;
        height: 90%;
        max-height: 700px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }

    .modal-content h2 {
        color: var(--xp-bar-color);
        text-align: center;
        margin-top: 0;
        margin-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.5rem;
    }

    .modal-body {
        overflow-y: auto;
        flex-grow: 1;
    }

    .modal-body h3 {
        color: var(--skill-learnable-bg);
        margin-top: 1rem;
        margin-bottom: 0.5rem;
    }

    .modal-body p, .modal-body li {
        font-size: 0.85rem;
        line-height: 1.6;
        color: var(--text-color);
    }
    .modal-body ul {
        padding-left: 1.2rem;
    }

    .modal-footer {
        margin-top: 1rem;
        text-align: center;
    }

    /* Dungeon Map Styles */
    .dungeon-map {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      margin-bottom: 0.8rem;
      padding: 0.4rem;
      background-color: rgba(0,0,0,0.2);
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
    }
    .map-node {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: var(--secondary-bg);
      border: 2px solid var(--border-color);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 10px;
      transition: all 0.3s;
    }
    .map-node.cleared {
      background-color: var(--button-disabled-bg);
      border-color: var(--secondary-bg);
    }
    .map-node.current {
      background-color: var(--player-hp-color);
      border-color: var(--text-color);
      transform: scale(1.2);
      box-shadow: 0 0 8px var(--player-hp-color);
    }
    .map-node.boss {
      background-color: var(--monster-hp-color);
      border-color: #ff7675;
      transform: scale(1.3);
    }
    .map-node.boss.current {
        transform: scale(1.5);
        box-shadow: 0 0 10px var(--monster-hp-color);
    }

    /* Name Change Icon Styles */
    .name-change-icon {
        cursor: pointer;
        font-size: 1rem;
        margin-left: 0.4rem;
        display: inline-block;
        transition: transform 0.2s;
    }
    .name-change-icon:hover {
        transform: scale(1.2);
    }

    /* Item Lock & Batch Disenchant Styles */
    .lock-icon {
        position: absolute;
        top: 4px;
        right: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        z-index: 2;
        background: rgba(0,0,0,0.4);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: transform 0.2s;
    }
    .lock-icon:hover {
        transform: scale(1.2);
    }

    .item-card.locked {
        border-color: var(--skill-learnable-bg);
        box-shadow: 0 0 4px var(--skill-learnable-bg);
    }

    .batch-disenchant-container {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        width: 100%;
    }
    .batch-disenchant-filters {
        background: rgba(0,0,0,0.2);
        padding: 0.8rem;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
    }
    .batch-disenchant-filters h3 {
        margin: 0 0 0.4rem 0;
        font-size: 1rem;
        text-align: center;
    }
    .filter-checkbox-group {
        display: flex;
        gap: 1rem;
        justify-content: center;
    }
    .filter-checkbox-group label {
        display: flex;
        align-items: center;
        gap: 0.3rem;
        font-size: 0.8rem;
        cursor: pointer;
        background: var(--secondary-bg);
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        border: 1px solid var(--border-color);
    }
    .filter-checkbox-group input:checked + span {
        color: var(--skill-learnable-bg);
        font-weight: bold;
    }
    .batch-disenchant-summary {
        background: rgba(0,0,0,0.2);
        padding: 0.8rem;
        border-radius: 8px;
        text-align: left;
    }
    .batch-disenchant-summary p {
        margin: 0.2rem 0;
        font-size: 0.8rem;
    }
    .batch-disenchant-summary strong {
        color: var(--xp-bar-color);
    }
    #batch-disenchant-button {
        background-color: var(--disenchant-color);
        margin-top: 0.4rem;
    }
    #batch-disenchant-button:hover {
        background-color: #8e44ad;
    }
    input[type="checkbox"] {
        display: none;
    }

    /* Permanent UI Styles */
    #game-reset-button {
        position: fixed;
        top: 10px;
        left: 10px;
        background-color: var(--monster-hp-color);
        color: white;
        border: none;
        border-radius: 4px;
        padding: 0.3rem 0.6rem;
        font-size: 0.7rem;
        font-weight: bold;
        cursor: pointer;
        z-index: 1001;
        transition: background-color 0.2s;
    }
    #game-reset-button:hover {
        background-color: #c0392b;
    }

    #rank-display {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background-color: rgba(0,0,0,0.6);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        padding: 0.5rem 1rem;
        z-index: 1001;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    #rank-display span:first-child {
        font-size: 0.8rem;
        color: var(--text-color);
    }
    #rank-display span:last-child {
        font-size: 1.3rem;
        font-weight: bold;
    }
    .rank-C { color: #bdc3c7; }
    .rank-B { color: var(--rarity-uncommon); }
    .rank-A { color: var(--rarity-rare); }
    .rank-S { color: var(--rarity-legendary); }
    .rank-SS { color: var(--rarity-mythic); }
    .rank-SSS { color: var(--disenchant-color); }
  </style>
</head>
<body>
  <div id="creator-credit">Ï†úÏûëÏûê:ÌïúÍµ≠Ïù∏Ïù¥ÎùºÎ©¥</div>
  <div id="root"></div>
  <script type="module">
    /**
     * @license
     * SPDX-License-Identifier: Apache-2.0
     */

    const root = document.getElementById('root');
    if (!root) {
      throw new Error('Could not find root element');
    }

    // --- Game Constants ---
    const CRIT_MULTIPLIER = 1.5;
    const POTION_HEAL_PERCENT = 0.6;
    const POTION_COST = 50;
    const DEFEAT_GOLD_PENALTY = 0.1;
    const ESCAPE_GOLD_PENALTY = 0.05;
    const CLASS_CHANGE_COST = 5000;
    const REBIRTH_LEVEL_REQ = 30;
    const GACHA_COST_SINGLE = 200;
    const GACHA_COST_TEN = 1800;
    const INVENTORY_LIMIT = 100;

    const STATUS_EFFECT_DEFINITIONS = {
        poison: { name: 'ÎèÖ', icon: '‚ò†Ô∏è' },
        burn: { name: 'ÌôîÏÉÅ', icon: 'üî•' },
        stun: { name: 'Í∏∞Ï†à', icon: 'üí´' },
        weaken: { name: 'ÏïΩÌôî', icon: '‚Üì' },
        vulnerable: { name: 'Ï∑®ÏïΩ', icon: 'üõ°Ô∏èüí•' },
    };

    const CLASSES = {
        'Ï†ÑÏÇ¨': { emoji: 'üõ°Ô∏è', baseHp: 160, baseAtk: 12, baseDef: 4, weapon: 'Í≤Ä', crit: 0.1, evade: 0.05 },
        'ÎßàÎ≤ïÏÇ¨': { emoji: 'üî•', baseHp: 110, baseAtk: 16, baseDef: 0, weapon: 'ÏßÄÌå°Ïù¥', crit: 0.1, evade: 0.05 },
        'ÏïîÏÇ¥Ïûê': { emoji: 'üí®', baseHp: 120, baseAtk: 14, baseDef: 1, weapon: 'Îã®Í≤Ä', crit: 0.30, evade: 0.20 },
        'Í∂ÅÏàò': { emoji: 'üèπ', baseHp: 115, baseAtk: 15, baseDef: 2, weapon: 'Ìôú', crit: 0.20, evade: 0.10 },
    };

    const DIFFICULTY_SETTINGS = {
        'Ïâ¨ÏõÄ': { monsterHpMod: 0.8, monsterAtkMod: 0.8, startGold: 50, startPotions: 5, rewardMod: 0.8 },
        'Î≥¥ÌÜµ': { monsterHpMod: 1.05, monsterAtkMod: 1.05, startGold: 20, startPotions: 2, rewardMod: 1.0 },
        'Ïñ¥Î†§ÏõÄ': { monsterHpMod: 1.35, monsterAtkMod: 1.35, startGold: 0, startPotions: 1, rewardMod: 1.25 },
    };

    const ULTIMATE_SKILLS = {
        'Ï†ÑÏÇ¨': {
            id: 'w_ultimate',
            name: 'Ï≤†ÏòπÏÑ±',
            cooldown: 5,
            description: level => `Í≥µÍ≤©Î†•Ïùò 200% ÌîºÌï¥Î•º Ï£ºÍ≥†, ${2+level}ÌÑ¥ ÎèôÏïà Î∞©Ïñ¥Î†•Ïù¥ ${30 + level * 5}% Ï¶ùÍ∞ÄÌïòÎäî 'Ï≤†Î≤Ω' Ìö®Í≥ºÎ•º ÏñªÏäµÎãàÎã§.`,
            effect: level => ({
                damageMultiplier: 2.0,
                buff: { name: 'Ï≤†Î≤Ω', stat: 'defense', value: 0.30 + level * 0.05, duration: 2 + level, isPercent: true },
                message: 'üõ°Ô∏è Í∞ïÏ≤†Ïùò ÏùòÏßÄ! [Ï≤†ÏòπÏÑ±]ÏùÑ Î∞úÎèôÌïòÏó¨ Ï†ÅÏóêÍ≤å Ï∞∏Í≤©ÏùÑ ÎÇ†Î¶¨Í≥†, Î™∏Ïù¥ Í∞ïÏ≤†Ï≤òÎüº Îã®Îã®Ìï¥Ï°åÎã§!'
            })
        },
        'ÎßàÎ≤ïÏÇ¨': {
            id: 'm_ultimate',
            name: 'Î©îÌÖåÏò§',
            cooldown: 5,
            description: level => `Í≥µÍ≤©Î†•Ïùò ${250 + level*20}% ÌîºÌï¥Î•º ÏûÖÌûàÍ≥†, 3ÌÑ¥Í∞Ñ ÌÑ¥ÎßàÎã§ ${10 + level * 3}Ïùò ÌôîÏÉÅ ÌîºÌï¥Î•º Ï§çÎãàÎã§.`,
            effect: level => ({
                damageMultiplier: 2.5 + level * 0.2,
                statusEffect: { type: 'burn', chance: 1.0, duration: 3, potency: 10 + level * 3 },
                message: '‚òÑÔ∏è ÌïòÎäòÏù¥ Î∂âÍ≤å Î¨ºÎì†Îã§! Í±∞ÎåÄÌïú [Î©îÌÖåÏò§]Í∞Ä Îñ®Ïñ¥Ï†∏ Ï†ÅÏùÑ Î∂àÌÉúÏö∞Í≥† ÏßÄÎ©¥ÏùÑ ÎÖπÏù∏Îã§!'
            })
        },
        'ÏïîÏÇ¥Ïûê': {
            id: 'r_ultimate',
            name: 'Í∑∏Î¶ºÏûê ÏäµÍ≤©',
            cooldown: 5,
            description: level => `Í≥µÍ≤©Î†•Ïùò ${180 + level*10}% ÌîºÌï¥Î•º 2Î≤à ÏûÖÌûàÍ≥†, 3ÌÑ¥Í∞Ñ ÌÑ¥ÎßàÎã§ ${8 + level * 2}Ïùò ÎèÖ ÌîºÌï¥Î•º Ï§çÎãàÎã§.`,
            effect: level => ({
                damageMultiplier: 1.8 + level * 0.1, // This is per hit
                statusEffect: { type: 'poison', chance: 1.0, duration: 3, potency: 8 + level * 2 },
                message: 'üí® Ïñ¥Îë† ÏÜçÏóêÏÑú Î≤àÎú©Ïù¥Îäî ÏπºÎÇ†! [Í∑∏Î¶ºÏûê ÏäµÍ≤©]ÏúºÎ°ú Ï†ÅÏùò Î∞∞ÌõÑÎ•º 2Ìöå Í∞ïÌÉÄÌïòÍ≥† ÎßπÎèÖÏùÑ Ï£ºÏûÖÌñàÎã§!'
            })
        },
        'Í∂ÅÏàò': {
            id: 'a_ultimate',
            name: 'ÏßëÏ§ë ÏÇ¨Í≤©',
            cooldown: 5,
            description: level => `Í≥µÍ≤©Î†•Ïùò ${220 + level*15}% ÌîºÌï¥Î•º ÏûÖÌûàÍ≥†, Îã§Ïùå 2ÌÑ¥Í∞Ñ ÏπòÎ™ÖÌÉÄ ÌôïÎ•†Ïù¥ ${15 + level*5}% Ï¶ùÍ∞ÄÌï©ÎãàÎã§.`,
            effect: level => ({
                damageMultiplier: 2.2 + level * 0.15,
                buff: { name: 'ÏßëÏ§ë', stat: 'critChance', value: 0.15 + level * 0.05, duration: 2, isPercent: false },
                message: 'üèπ Ïà®ÏùÑ Î©àÏ∂îÍ≥† ÏãúÏúÑÎ•º ÎãπÍ∏¥Îã§! [ÏßëÏ§ë ÏÇ¨Í≤©]Ïù¥ Ï†ÅÏùò Í∏âÏÜåÎ•º Íø∞Îö´ÏóàÎã§!'
            })
        },
    };
    
    const ULTIMATE_SKILLS_2 = {
        'Ï†ÑÏÇ¨': {
            id: 'w_ultimate_2',
            name: 'Î∂ÑÏáÑ',
            cooldown: 6,
            description: level => `Í≥µÍ≤©Î†•Ïùò 250% ÌîºÌï¥Î•º Ï£ºÍ≥†, 2ÌÑ¥Í∞Ñ Ï†ÅÏùÑ [Ï∑®ÏïΩ] ÏÉÅÌÉúÎ°ú ÎßåÎì§Ïñ¥ Î∞õÎäî ÌîºÌï¥Î•º ${20 + level * 5}% Ï¶ùÍ∞ÄÏãúÌÇµÎãàÎã§.`,
            effect: level => ({
                damageMultiplier: 2.5,
                statusEffect: { type: 'vulnerable', chance: 1.0, duration: 2, potency: 0.20 + level * 0.05 },
                message: 'ÎïÖÏù¥ ÌùîÎì§Î¶∞Îã§! [Î∂ÑÏáÑ]Ïùò ÏùºÍ≤©Ïù¥ Ï†ÅÏùò Î∞©Ïñ¥Î•º ÏÇ∞ÏÇ∞Ï°∞Í∞ÅÎÉàÎã§!'
            })
        },
        'ÎßàÎ≤ïÏÇ¨': {
            id: 'm_ultimate_2',
            name: 'ÏÑúÎ¶¨ Í≥†Î¶¨',
            cooldown: 6,
            description: level => `Í≥µÍ≤©Î†•Ïùò 120% ÌîºÌï¥Î•º Ï£ºÍ≥†, ${70 + level * 10}% ÌôïÎ•†Î°ú 1ÌÑ¥Í∞Ñ Ï†ÅÏùÑ [Í∏∞Ï†à]ÏãúÌÇµÎãàÎã§.`,
            effect: level => ({
                damageMultiplier: 1.2,
                statusEffect: { type: 'stun', chance: 0.7 + level * 0.1, duration: 1, potency: 0 },
                message: 'ÎÉâÍ∏∞Í∞Ä ÌúòÎ™∞ÏïÑÏπúÎã§! [ÏÑúÎ¶¨ Í≥†Î¶¨]Í∞Ä Ï†ÅÏùÑ Í∑∏ ÏûêÎ¶¨Ïóê ÏñºÏñ¥Î∂ôÍ≤å ÌñàÎã§!'
            })
        },
        'ÏïîÏÇ¥Ïûê': {
            id: 'r_ultimate_2',
            name: 'Ïó∞ÎßâÌÉÑ',
            cooldown: 6,
            description: level => `Ï¶âÏãú [ÌöåÌîº] ÏÉÅÌÉúÍ∞Ä ÎêòÏñ¥ Îã§Ïùå 2ÌÑ¥Í∞Ñ ÌöåÌîº ÌôïÎ•†Ïù¥ ${50 + level*10}% Ï¶ùÍ∞ÄÌïòÍ≥†, Îã§Ïùå 1ÌöåÏùò Í≥µÍ≤©Ïù¥ Î∞òÎìúÏãú ÏπòÎ™ÖÌÉÄÎ°ú Ï†ÅÏ§ëÌï©ÎãàÎã§.`,
            effect: level => ({
                buff: { stat: 'evadeChance', value: 0.50 + level * 0.1, duration: 2, isPercent: false },
                buff2: { name: 'ÌôïÏ†ï ÏπòÎ™ÖÌÉÄ', duration: 2, effect: { guaranteedCrit: true } },
                message: 'Ïó∞Í∏∞ ÏÜçÏúºÎ°ú ÏÇ¨ÎùºÏßÑÎã§! [Ïó∞ÎßâÌÉÑ]ÏùÑ ÏÇ¨Ïö©Ìï¥, Îã§Ïùå Í≥µÍ≤©ÏùÑ Ï§ÄÎπÑÌïúÎã§!'
            })
        },
        'Í∂ÅÏàò': {
            id: 'a_ultimate_2',
            name: 'ÌôîÏÇ¥ÎπÑ',
            cooldown: 6,
            description: level => `Í≥µÍ≤©Î†•Ïùò 100% ÌîºÌï¥Î•º 3Î≤à ÏûÖÌûàÍ≥†, ${50 + level*10}% ÌôïÎ•†Î°ú 2ÌÑ¥Í∞Ñ Ï†ÅÏùÑ [ÏïΩÌôî] ÏÉÅÌÉúÎ°ú ÎßåÎì≠ÎãàÎã§.`,
            effect: level => ({
                damageMultiplier: 1.0, // Per hit
                hits: 3,
                statusEffect: { type: 'weaken', chance: 0.5 + level * 0.1, duration: 2, potency: 0.15 },
                message: 'üéØ ÌïòÎäòÏù¥ ÌôîÏÇ¥Î°ú Îí§ÎçÆÏù∏Îã§! [ÌôîÏÇ¥ÎπÑ]Í∞Ä Ï†ÅÏßÑÏùÑ Ï¥àÌÜ†ÌôîÏãúÌÇ®Îã§!'
            })
        },
    };

    const SKILL_DATA = {
        'Ï†ÑÏÇ¨': {
            'w_hp_1': { id: 'w_hp_1', name: 'Í∞ïÍ±¥Ìïú Ïú°Ï≤¥', description: level => `ÏµúÎåÄ ÏÉùÎ™ÖÎ†•Ïù¥ Î†àÎ≤®Îãπ 15Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level*15})`, cost: level => 100 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'maxHp', value: 15 * level }] },
            'w_atk_1': { id: 'w_atk_1', name: 'Î¨¥Í∏∞ Ïó∞Îßà', description: level => `Í≥µÍ≤©Î†•Ïù¥ Î†àÎ≤®Îãπ 2Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level*2})`, cost: level => 120 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'attackPower', value: 2 * level }] },
            'w_def_1': { id: 'w_def_1', name: 'Î∞©Ïñ¥Íµ¨ Í∞ïÌôî', description: level => `Î∞©Ïñ¥Î†•Ïù¥ Î†àÎ≤®Îãπ 1Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level*1})`, cost: level => 150 * (level + 1), requiredPlayerLevel: 3, prerequisites: [{id: 'w_hp_1', level: 1}], effects: level => [{ stat: 'defense', value: 1 * level }] },
            'w_ult_1': { id: 'w_ult_1', name: 'Ï≤†ÏòπÏÑ± Í∞ïÌôî', description: level => `Ï≤†ÏòπÏÑ±Ïùò Î∞©Ïñ¥Î†• Ï¶ùÍ∞Ä Ìö®Í≥ºÍ∞Ä Î†àÎ≤®Îãπ 5%Ïî© Ï∂îÍ∞ÄÎê©ÎãàÎã§.`, cost: level => 500 * (level + 1), requiredPlayerLevel: 5, prerequisites: [{id: 'w_def_1', level: 2}], effects: level => [] }, // Special handling
            'w_ult_2': { id: 'w_ult_2', name: 'Î∂ÑÏáÑ', maxLevel: 3, description: ULTIMATE_SKILLS_2['Ï†ÑÏÇ¨'].description, cost: level => 2000 * (level + 1), requiredPlayerLevel: 15, prerequisites: [{id: 'w_ult_1', level: 1}], effects: level => [] },
        },
        'ÎßàÎ≤ïÏÇ¨': {
            'm_atk_1': { id: 'm_atk_1', name: 'ÎπÑÏ†ÑÎ†• Ï¶ùÌè≠', description: level => `Í≥µÍ≤©Î†•Ïù¥ Î†àÎ≤®Îãπ 3Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level*3})`, cost: level => 120 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'attackPower', value: 3 * level }] },
            'm_hp_1': { id: 'm_hp_1', name: 'ÏõêÏÜå Î≥¥Ìò∏Îßâ', description: level => `ÏµúÎåÄ ÏÉùÎ™ÖÎ†•Ïù¥ Î†àÎ≤®Îãπ 10Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level*10})`, cost: level => 100 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'maxHp', value: 10 * level }] },
            'm_burn_1': { id: 'm_burn_1', name: 'ÌÉÄÏò§Î•¥Îäî Î∂àÍΩÉ', description: level => `Î™®Îì† ÌôîÏÉÅ ÌîºÌï¥Í∞Ä Î†àÎ≤®Îãπ 10%Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§.`, cost: level => 300 * (level + 1), requiredPlayerLevel: 3, prerequisites: [{id: 'm_atk_1', level: 1}], effects: level => [] }, // Special handling
            'm_ult_1': { id: 'm_ult_1', name: 'Î©îÌÖåÏò§ Í∞ïÌôî', description: level => `Î©îÌÖåÏò§Ïùò Í∏∞Î≥∏ ÌîºÌï¥ÎüâÏù¥ Î†àÎ≤®Îãπ 10%Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§.`, cost: level => 500 * (level + 1), requiredPlayerLevel: 5, prerequisites: [{id: 'm_burn_1', level: 1}], effects: level => [] }, // Special handling
            'm_ult_2': { id: 'm_ult_2', name: 'ÏÑúÎ¶¨ Í≥†Î¶¨', maxLevel: 3, description: ULTIMATE_SKILLS_2['ÎßàÎ≤ïÏÇ¨'].description, cost: level => 2000 * (level + 1), requiredPlayerLevel: 15, prerequisites: [{id: 'm_ult_1', level: 1}], effects: level => [] },
        },
        'ÏïîÏÇ¥Ïûê': {
            'r_crit_1': { id: 'r_crit_1', name: 'Í∏âÏÜå ÌååÏïÖ', description: level => `ÏπòÎ™ÖÌÉÄ ÌôïÎ•†Ïù¥ Î†àÎ≤®Îãπ 1%Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level}%)`, cost: level => 150 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'critChance', value: 0.01 * level }] },
            'r_evade_1': { id: 'r_evade_1', name: 'ÎÇ†Î†µÌïú Î™∏ÎÜÄÎ¶º', description: level => `ÌöåÌîº ÌôïÎ•†Ïù¥ Î†àÎ≤®Îãπ 1%Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level}%)`, cost: level => 150 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'evadeChance', value: 0.01 * level }] },
            'r_atk_1': { id: 'r_atk_1', name: 'Îã®Í≤Ä Ïó∞Îßà', description: level => `Í≥µÍ≤©Î†•Ïù¥ Î†àÎ≤®Îãπ 2Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level*2})`, cost: level => 120 * (level + 1), requiredPlayerLevel: 3, prerequisites: [{id: 'r_crit_1', level: 1}], effects: level => [{ stat: 'attackPower', value: 2 * level }] },
            'r_execute_1': { id: 'r_execute_1', name: 'ÎßàÎ¨¥Î¶¨ ÏùºÍ≤©', maxLevel: 1, description: level => `Ï≤¥Î†•Ïù¥ 25% Ïù¥ÌïòÏù∏ Ï†ÅÏóêÍ≤å 20%Ïùò Ï∂îÍ∞Ä ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.`, cost: level => 1000, requiredPlayerLevel: 5, prerequisites: [{id: 'r_atk_1', level: 2}], effects: level => [] }, // Special handling
            'r_ult_2': { id: 'r_ult_2', name: 'Ïó∞ÎßâÌÉÑ', maxLevel: 3, description: ULTIMATE_SKILLS_2['ÏïîÏÇ¥Ïûê'].description, cost: level => 2000 * (level + 1), requiredPlayerLevel: 15, prerequisites: [{id: 'r_execute_1', level: 1}], effects: level => [] },
        },
        'Í∂ÅÏàò': {
            'a_atk_1': { id: 'a_atk_1', name: 'Î™ÖÍ∂ÅÏùò ÎßàÏùå', description: level => `Í≥µÍ≤©Î†•Ïù¥ Î†àÎ≤®Îãπ 2Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level*2})`, cost: level => 120 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'attackPower', value: 2 * level }] },
            'a_crit_1': { id: 'a_crit_1', name: 'Îß§Ïùò Îàà', description: level => `ÏπòÎ™ÖÌÉÄ ÌôïÎ•†Ïù¥ Î†àÎ≤®Îãπ 1%Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level}%)`, cost: level => 150 * (level + 1), requiredPlayerLevel: 1, prerequisites: [], effects: level => [{ stat: 'critChance', value: 0.01 * level }] },
            'a_crit_dmg_1': { id: 'a_crit_dmg_1', name: 'ÏïΩÏ†ê Í∞ÑÌåå', description: level => `ÏπòÎ™ÖÌÉÄ ÌîºÌï¥ÎüâÏù¥ Î†àÎ≤®Îãπ 5%Ïî© Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (Ï¥ù +${level*5}%)`, cost: level => 200 * (level + 1), requiredPlayerLevel: 3, prerequisites: [{id: 'a_crit_1', level: 1}], effects: level => [{ stat: 'critDamage', value: 0.05 * level }] },
            'a_ult_1': { id: 'a_ult_1', name: 'ÏßëÏ§ë ÏÇ¨Í≤© Í∞ïÌôî', description: level => `ÏßëÏ§ë ÏÇ¨Í≤©Ïùò ÏπòÎ™ÖÌÉÄ ÌôïÎ•† Ï¶ùÍ∞Ä Ìö®Í≥ºÍ∞Ä Î†àÎ≤®Îãπ 2%Ïî© Ï∂îÍ∞ÄÎê©ÎãàÎã§.`, cost: level => 500 * (level + 1), requiredPlayerLevel: 5, prerequisites: [{id: 'a_crit_dmg_1', level: 2}], effects: level => [] }, // Special handling
            'a_ult_2': { id: 'a_ult_2', name: 'ÌôîÏÇ¥ÎπÑ', maxLevel: 3, description: ULTIMATE_SKILLS_2['Í∂ÅÏàò'].description, cost: level => 2000 * (level + 1), requiredPlayerLevel: 15, prerequisites: [{id: 'a_ult_1', level: 1}], effects: level => [] },
        },
    };

    const ITEM_DATABASE = [
        // Common
        { id: 101, name: "ÎÖπÏä® Í≤Ä", type: 'weapon', stats: { attackPower: 2 }, rarity: 'common', cost: 25, classRestriction: ['Ï†ÑÏÇ¨'] },
        { id: 102, name: "Ìï¥ÏßÑ Î°úÎ∏å", type: 'armor', stats: { maxHp: 10 }, rarity: 'common', cost: 25, classRestriction: ['ÎßàÎ≤ïÏÇ¨'] },
        { id: 103, name: "Í∞ÄÏ£Ω Í∞ëÏò∑", type: 'armor', stats: { defense: 1, evadeChance: 0.01 }, rarity: 'common', cost: 25, classRestriction: ['ÏïîÏÇ¥Ïûê'] },
        { id: 104, name: "ÎÇòÎ¨¥ ÏßÄÌå°Ïù¥", type: 'weapon', stats: { attackPower: 3 }, rarity: 'common', cost: 25, classRestriction: ['ÎßàÎ≤ïÏÇ¨'] },
        { id: 105, name: "ÏûëÏùÄ Îã®Í≤Ä", type: 'weapon', stats: { attackPower: 1, critChance: 0.02 }, rarity: 'common', cost: 25, classRestriction: ['ÏïîÏÇ¥Ïûê'] },
        { id: 106, name: "ÌåêÍ∏à Ï°∞ÎÅº", type: 'armor', stats: { defense: 2 }, rarity: 'common', cost: 25, classRestriction: ['Ï†ÑÏÇ¨'] },
        { id: 107, name: "ÏßßÏùÄ Ìôú", type: 'weapon', stats: { attackPower: 2, critChance: 0.01 }, rarity: 'common', cost: 25, classRestriction: ['Í∂ÅÏàò'] },
        { id: 108, name: "ÏÇ¨ÎÉ•Íæº Ï°∞ÎÅº", type: 'armor', stats: { defense: 1, evadeChance: 0.02 }, rarity: 'common', cost: 25, classRestriction: ['Í∂ÅÏàò'] },

        // Uncommon
        { id: 201, name: "Í∞ïÏ≤† Í≤Ä", type: 'weapon', stats: { attackPower: 5 }, rarity: 'uncommon', cost: 100, classRestriction: ['Ï†ÑÏÇ¨'] },
        { id: 202, name: "ÎßàÎ≤ïÏÇ¨Ïùò Î°úÎ∏å", type: 'armor', stats: { maxHp: 20, attackPower: 2 }, rarity: 'uncommon', cost: 100, classRestriction: ['ÎßàÎ≤ïÏÇ¨'] },
        { id: 203, name: "Í∑∏Î¶ºÏûê ÏÇ¨Ïä¨ Í∞ëÏò∑", type: 'armor', stats: { defense: 2, maxHp: 10, evadeChance: 0.03 }, rarity: 'uncommon', cost: 100, classRestriction: ['ÏïîÏÇ¥Ïûê'] },
        { id: 204, name: "Î≥¥ÏÑù Î∞ïÌûå ÏßÄÌå°Ïù¥", type: 'weapon', stats: { attackPower: 6 }, rarity: 'uncommon', cost: 100, classRestriction: ['ÎßàÎ≤ïÏÇ¨'] },
        { id: 205, name: "ÏïîÏÇ¥ÏûêÏùò Îã®Í≤Ä", type: 'weapon', stats: { attackPower: 3, critChance: 0.05 }, rarity: 'uncommon', cost: 100, classRestriction: ['ÏïîÏÇ¥Ïûê'] },
        { id: 206, name: "Í∞ïÏ≤† Í∞ëÏò∑", type: 'armor', stats: { defense: 4, maxHp: 25 }, rarity: 'uncommon', cost: 100, classRestriction: ['Ï†ÑÏÇ¨'] },
        { id: 207, name: "Ïû•Í∂Å", type: 'weapon', stats: { attackPower: 5, critChance: 0.02 }, rarity: 'uncommon', cost: 100, classRestriction: ['Í∂ÅÏàò'] },
        { id: 208, name: "Ï†ïÏ∞∞Î≥ëÏùò Í∞ëÏò∑", type: 'armor', stats: { defense: 2, evadeChance: 0.03, maxHp: 15 }, rarity: 'uncommon', cost: 100, classRestriction: ['Í∂ÅÏàò'] },
        
        // Rare
        { id: 301, name: "Î£¨ Î∏îÎ†àÏù¥Îìú", type: 'weapon', stats: { attackPower: 8, critChance: 0.03 }, rarity: 'rare', cost: 300, classRestriction: ['Ï†ÑÏÇ¨'] },
        { id: 302, name: "ÎåÄÎßàÎ≤ïÏÇ¨Ïùò Î°úÎ∏å", type: 'armor', stats: { maxHp: 30, attackPower: 5, defense: 1 }, rarity: 'rare', cost: 300, classRestriction: ['ÎßàÎ≤ïÏÇ¨'] },
        { id: 303, name: "Í∏∞ÏÇ¨Ïùò Í∞ëÏò∑", type: 'armor', stats: { defense: 5, maxHp: 40 }, rarity: 'rare', cost: 300, classRestriction: ['Ï†ÑÏÇ¨'] },
        { id: 304, name: "ÌòÑÏûêÏùò ÏßÄÌå°Ïù¥", type: 'weapon', stats: { attackPower: 10, maxHp: 20 }, rarity: 'rare', cost: 300, classRestriction: ['ÎßàÎ≤ïÏÇ¨'] },
        { id: 305, name: "ÎèÖÏÇ¨Ïùò ÏÜ°Í≥≥Îãà", type: 'weapon', stats: { attackPower: 7, critChance: 0.07 }, rarity: 'rare', cost: 300, classRestriction: ['ÏïîÏÇ¥Ïûê'] },
        { id: 306, name: "Î∞§Ïùò Ïû•Îßâ Í∞ëÏò∑", type: 'armor', stats: { defense: 3, evadeChance: 0.05, maxHp: 20 }, rarity: 'rare', cost: 300, classRestriction: ['ÏïîÏÇ¥Ïûê'] },
        { id: 307, name: "ÏÇ¨ÎÉ•ÍæºÏùò Ìôú", type: 'weapon', stats: { attackPower: 8, critChance: 0.05 }, rarity: 'rare', cost: 300, classRestriction: ['Í∂ÅÏàò'] },
        { id: 308, name: "Î∞îÎûåÏùò Í∞ÄÏ£Ω Í∞ëÏò∑", type: 'armor', stats: { defense: 4, evadeChance: 0.04, critChance: 0.02 }, rarity: 'rare', cost: 300, classRestriction: ['Í∂ÅÏàò'] },
        
        // Legendary
        { id: 401, name: "Ïö©ÏÇ¥ÏûêÏùò ÎåÄÍ≤Ä", type: 'weapon', stats: { attackPower: 20, maxHp: 50 }, rarity: 'legendary', cost: 5000, classRestriction: ['Ï†ÑÏÇ¨'] },
        { id: 402, name: "ÏïÑÌÅ¨Î©îÏù¥ÏßÄÏùò ÏßÄÌå°Ïù¥", type: 'weapon', stats: { attackPower: 25 }, rarity: 'legendary', cost: 5000, classRestriction: ['ÎßàÎ≤ïÏÇ¨'] },
        { id: 403, name: "ÏõîÍ¥ëÏùò Îã®Í≤Ä", type: 'weapon', stats: { attackPower: 15, critChance: 0.10, evadeChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['ÏïîÏÇ¥Ïûê'] },
        { id: 404, name: "ÏàòÌò∏Ïã†Ïùò Í∞ëÏ£º", type: 'armor', stats: { defense: 10, maxHp: 100 }, rarity: 'legendary', cost: 5000, classRestriction: ['Ï†ÑÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'ÎßàÎ≤ïÏÇ¨', 'Í∂ÅÏàò'] },
        { id: 405, name: "Ìè≠ÌíçÏùò Ìôú", type: 'weapon', stats: { attackPower: 18, critChance: 0.08 }, rarity: 'legendary', cost: 5000, classRestriction: ['Í∂ÅÏàò'] },

        // Mythic
        { id: 601, name: "Ï≤úÎ≤å", type: 'weapon', stats: { attackPower: 35, critChance: 0.10 }, rarity: 'mythic', cost: 99999, classRestriction: ['Ï†ÑÏÇ¨'], isGachaOnly: true },
        { id: 602, name: "Ï¢ÖÎßêÏùò ÏÑú", type: 'weapon', stats: { attackPower: 40, maxHp: 50 }, rarity: 'mythic', cost: 99999, classRestriction: ['ÎßàÎ≤ïÏÇ¨'], isGachaOnly: true },
        { id: 603, name: "Î∞§Ïùò ÌååÌé∏", type: 'weapon', stats: { attackPower: 25, critChance: 0.15, evadeChance: 0.08 }, rarity: 'mythic', cost: 99999, classRestriction: ['ÏïîÏÇ¥Ïûê'], isGachaOnly: true },
        { id: 604, name: "ÏÑ∏Í≥ÑÏàòÏùò Ïã¨Ïû•", type: 'armor', stats: { defense: 15, maxHp: 150, evadeChance: 0.05 }, rarity: 'mythic', cost: 99999, classRestriction: ['Ï†ÑÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'ÎßàÎ≤ïÏÇ¨', 'Í∂ÅÏàò'], isGachaOnly: true },
        { id: 605, name: "Ï≤úÍ≥µÏùò Î∂ÑÎÖ∏", type: 'weapon', stats: { attackPower: 30, critChance: 0.15 }, rarity: 'mythic', cost: 99999, classRestriction: ['Í∂ÅÏàò'], isGachaOnly: true },

        // Ultimate
        { id: 701, name: "Í∂ÅÍ∑πÏùò ÌååÎ©∏Í≤Ä", type: 'weapon', stats: { attackPower: 50, critDamage: 0.15 }, rarity: 'ultimate', cost: 999999, classRestriction: ['Ï†ÑÏÇ¨'], isGachaOnly: true },
        { id: 702, name: "ÌÉúÏ¥àÏùò ÏßÄÌòú", type: 'weapon', stats: { attackPower: 60, maxHp: 100 }, rarity: 'ultimate', cost: 999999, classRestriction: ['ÎßàÎ≤ïÏÇ¨'], isGachaOnly: true },
        { id: 703, name: "ÏãúÍ∞Ñ ÏôúÍ≥° Îã®Í≤Ä", type: 'weapon', stats: { attackPower: 35, critChance: 0.1, evadeChance: 0.1 }, rarity: 'ultimate', cost: 999999, classRestriction: ['ÏïîÏÇ¥Ïûê'], isGachaOnly: true },
        { id: 704, name: "Î≥ÑÏùò ÎÖ∏Îûò", type: 'weapon', stats: { attackPower: 45, critChance: 0.20 }, rarity: 'ultimate', cost: 999999, classRestriction: ['Í∂ÅÏàò'], isGachaOnly: true },
        { id: 705, name: "Ï∞ΩÏ°∞Ïã†Ïùò Í∞ëÏ£º", type: 'armor', stats: { defense: 25, maxHp: 250, evadeChance: 0.05 }, rarity: 'ultimate', cost: 999999, classRestriction: ['Ï†ÑÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'ÎßàÎ≤ïÏÇ¨', 'Í∂ÅÏàò'], isGachaOnly: true },

        // Accessories
        { id: 501, name: "ÌûòÏùò Î∞òÏßÄ", type: 'accessory', stats: { attackPower: 5 }, rarity: 'rare', cost: 300, classRestriction: ['Ï†ÑÏÇ¨', 'ÎßàÎ≤ïÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'Í∂ÅÏàò'] },
        { id: 502, name: "ÌôúÎ†•Ïùò Î∂ÄÏ†Å", type: 'accessory', stats: { maxHp: 50 }, rarity: 'rare', cost: 300, classRestriction: ['Ï†ÑÏÇ¨', 'ÎßàÎ≤ïÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'Í∂ÅÏàò'] },
        { id: 503, "name": "ÏàòÌò∏Ïùò ÏßïÌëú", type: 'accessory', stats: { defense: 5 }, rarity: 'rare', cost: 300, classRestriction: ['Ï†ÑÏÇ¨', 'ÎßàÎ≤ïÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'Í∂ÅÏàò'] },
        { id: 504, "name": "ÌïÑÏÇ¥Ïùò Î∞òÏßÄ", type: 'accessory', stats: { critChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['Ï†ÑÏÇ¨', 'ÎßàÎ≤ïÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'Í∂ÅÏàò'] },
        { id: 505, "name": "Í∑∏Î¶ºÏûê ÎßùÌÜ†", type: 'accessory', stats: { evadeChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['Ï†ÑÏÇ¨', 'ÎßàÎ≤ïÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'Í∂ÅÏàò'] },
        { id: 506, "name": "ÌòÑÏûêÏùò Îèå", type: 'accessory', stats: { attackPower: 8, maxHp: 80 }, rarity: 'legendary', cost: 5000, classRestriction: ['Ï†ÑÏÇ¨', 'ÎßàÎ≤ïÏÇ¨', 'ÏïîÏÇ¥Ïûê', 'Í∂ÅÏàò'] },
    ];

    const SYNTHESIS_RECIPES = [
        // Common -> Uncommon
        { resultItemId: 201, ingredients: [ { type: 'item', id: 101, count: 2 }, { type: 'material', id: 'enhancementStones', count: 10 } ] }, // Í∞ïÏ≤† Í≤Ä
        { resultItemId: 202, ingredients: [ { type: 'item', id: 102, count: 2 }, { type: 'material', id: 'enhancementStones', count: 10 } ] }, // ÎßàÎ≤ïÏÇ¨Ïùò Î°úÎ∏å
        { resultItemId: 203, ingredients: [ { type: 'item', id: 103, count: 2 }, { type: 'material', id: 'enhancementStones', count: 10 } ] }, // Í∑∏Î¶ºÏûê ÏÇ¨Ïä¨ Í∞ëÏò∑
        { resultItemId: 204, ingredients: [ { type: 'item', id: 104, count: 2 }, { type: 'material', id: 'enhancementStones', count: 10 } ] }, // Î≥¥ÏÑù Î∞ïÌûå ÏßÄÌå°Ïù¥
        { resultItemId: 205, ingredients: [ { type: 'item', id: 105, count: 2 }, { type: 'material', id: 'enhancementStones', count: 10 } ] }, // ÏïîÏÇ¥ÏûêÏùò Îã®Í≤Ä
        { resultItemId: 206, ingredients: [ { type: 'item', id: 106, count: 2 }, { type: 'material', id: 'enhancementStones', count: 10 } ] }, // Í∞ïÏ≤† Í∞ëÏò∑
        { resultItemId: 207, ingredients: [ { type: 'item', id: 107, count: 2 }, { type: 'material', id: 'enhancementStones', count: 10 } ] }, // Ïû•Í∂Å
        { resultItemId: 208, ingredients: [ { type: 'item', id: 108, count: 2 }, { type: 'material', id: 'enhancementStones', count: 10 } ] }, // Ï†ïÏ∞∞Î≥ëÏùò Í∞ëÏò∑
        // Uncommon -> Rare
        { resultItemId: 301, ingredients: [ { type: 'item', id: 201, count: 2 }, { type: 'material', id: 'enhancementStones', count: 30 }, { type: 'material', id: 'enchantmentDust', count: 10 } ] }, // Î£¨ Î∏îÎ†àÏù¥Îìú
        { resultItemId: 302, ingredients: [ { type: 'item', id: 202, count: 2 }, { type: 'material', id: 'enhancementStones', count: 30 }, { type: 'material', id: 'enchantmentDust', count: 10 } ] }, // ÎåÄÎßàÎ≤ïÏÇ¨Ïùò Î°úÎ∏å
        { resultItemId: 305, ingredients: [ { type: 'item', id: 205, count: 2 }, { type: 'material', id: 'enhancementStones', count: 30 }, { type: 'material', id: 'enchantmentDust', count: 10 } ] }, // ÎèÖÏÇ¨Ïùò ÏÜ°Í≥≥Îãà
        { resultItemId: 307, ingredients: [ { type: 'item', id: 207, count: 2 }, { type: 'material', id: 'enhancementStones', count: 30 }, { type: 'material', id: 'enchantmentDust', count: 10 } ] }, // ÏÇ¨ÎÉ•ÍæºÏùò Ìôú
    ];
    
    const ENCHANTMENT_POOL = {
        weapon: {
            common: [ { id: 'w_c_atk', description: 'Í≥µÍ≤©Î†• +3', effects: { attackPower: 3 } }, { id: 'w_c_crit', description: 'ÏπòÎ™ÖÌÉÄ +1%', effects: { critChance: 0.01 } } ],
            uncommon: [ { id: 'w_u_atk', description: 'Í≥µÍ≤©Î†• +6', effects: { attackPower: 6 } }, { id: 'w_u_crit', description: 'ÏπòÎ™ÖÌÉÄ +2%', effects: { critChance: 0.02 } } ],
            rare: [ { id: 'w_r_atk', description: 'Í≥µÍ≤©Î†• +10', effects: { attackPower: 10 } }, { id: 'w_r_crit', description: 'ÏπòÎ™ÖÌÉÄ +4%', effects: { critChance: 0.04 } } ],
            legendary: [ { id: 'w_l_atk', description: 'Í≥µÍ≤©Î†• +25', effects: { attackPower: 25 } }, { id: 'w_l_crit', description: 'ÏπòÎ™ÖÌÉÄ +8%', effects: { critChance: 0.08 } }, { id: 'w_l_all', description: 'Í≥µÍ≤©Î†• +10, ÏπòÎ™ÖÌÉÄ +3%', effects: { attackPower: 10, critChance: 0.03 } } ],
            mythic: [ { id: 'w_m_atk', description: 'Í≥µÍ≤©Î†• +40', effects: { attackPower: 40 } }, { id: 'w_m_crit', description: 'ÏπòÎ™ÖÌÉÄ +12%', effects: { critChance: 0.12 } }, { id: 'w_m_all', description: 'Î™®Îì† Îä•Î†•Ïπò +5%', effects: { attackPowerPercent: 0.05, maxHpPercent: 0.05, defensePercent: 0.05 } } ]
        },
        armor: {
            common: [ { id: 'a_c_hp', description: 'ÏµúÎåÄ HP +15', effects: { maxHp: 15 } }, { id: 'a_c_def', description: 'Î∞©Ïñ¥Î†• +2', effects: { defense: 2 } } ],
            uncommon: [ { id: 'a_u_hp', description: 'ÏµúÎåÄ HP +30', effects: { maxHp: 30 } }, { id: 'a_u_def', description: 'Î∞©Ïñ¥Î†• +4', effects: { defense: 4 } }, { id: 'a_u_evade', description: 'ÌöåÌîº +1%', effects: { evadeChance: 0.01 } } ],
            rare: [ { id: 'a_r_hp', description: 'ÏµúÎåÄ HP +50', effects: { maxHp: 50 } }, { id: 'a_r_def', description: 'Î∞©Ïñ¥Î†• +7', effects: { defense: 7 } }, { id: 'a_r_evade', description: 'ÌöåÌîº +2%', effects: { evadeChance: 0.02 } } ],
            legendary: [ { id: 'a_l_hp', description: 'ÏµúÎåÄ HP +120', effects: { maxHp: 120 } }, { id: 'a_l_def', description: 'Î∞©Ïñ¥Î†• +15', effects: { defense: 15 } }, { id: 'a_l_evade', description: 'ÌöåÌîº +5%', effects: { evadeChance: 0.05 } } ],
            mythic: [ { id: 'a_m_hp', description: 'ÏµúÎåÄ HP +200', effects: { maxHp: 200 } }, { id: 'a_m_def', description: 'Î∞©Ïñ¥Î†• +25', effects: { defense: 25 } }, { id: 'a_m_all', description: 'ÌöåÌîº +5%, Î∞©Ïñ¥Î†• +15', effects: { evadeChance: 0.05, defense: 15 } } ]
        },
        accessory: {
            rare: [ { id: 'ac_r_atk', description: 'Í≥µÍ≤©Î†• +8', effects: { attackPower: 8 } }, { id: 'ac_r_hp', description: 'ÏµúÎåÄ HP +40', effects: { maxHp: 40 } } ],
            legendary: [ { id: 'ac_l_crit', description: 'ÏπòÎ™ÖÌÉÄ +3%', effects: { critChance: 0.03 } }, { id: 'ac_l_evade', description: 'ÌöåÌîº +3%', effects: { evadeChance: 0.03 } }, { id: 'ac_l_all', description: 'Í≥µÍ≤©Î†• +5, Î∞©Ïñ¥Î†• +5', effects: { attackPower: 5, defense: 5 } } ]
        }
    };

    const QUEST_POOL = [
        { type: 'KILL_MONSTERS', description: (n) => `Î™¨Ïä§ÌÑ∞ ${n}ÎßàÎ¶¨ Ï≤òÏπò`, targets: [10, 15, 20], reward: { gold: 150, stones: 3 } },
        { type: 'CLEAR_DUNGEON', description: (n) => `ÎçòÏ†Ñ ${n}Ìöå ÌÅ¥Î¶¨Ïñ¥`, targets: [1, 2], reward: { gold: 250, potions: 1 } },
        { type: 'ENHANCE_ATTEMPTS', description: (n) => `Ïû•ÎπÑ Í∞ïÌôî ${n}Ìöå ÏãúÎèÑ`, targets: [3, 5], reward: { gold: 200, stones: 5 } },
        { type: 'USE_ULTIMATE', description: (n) => `ÌäπÏàò Í∏∞Ïà† ${n}Ìöå ÏÇ¨Ïö©`, targets: [5, 8], reward: { gold: 100, potions: 1 } },
        { type: 'EARN_GOLD', description: (n) => `Í≥®Îìú ${n} ÌöçÎìù`, targets: [500, 1000], reward: { gold: 100, stones: 2 } },
    ];
    
    const PERMANENT_QUESTS_DATA = [
      { id: 'reach_level_10', type: 'REACH_LEVEL', description: 'Î†àÎ≤® 10 Îã¨ÏÑ±', target: 10, reward: { gold: 1000, stones: 10 } },
      { id: 'reach_level_20', type: 'REACH_LEVEL', description: 'Î†àÎ≤® 20 Îã¨ÏÑ±', target: 20, reward: { gold: 5000, stones: 25 } },
      { id: 'defeat_dragon', type: 'DEFEAT_BOSS', description: 'ÎìúÎûòÍ≥§ Ï≤òÏπò', targetName: 'ÎìúÎûòÍ≥§', target: 1, reward: { gold: 3000, potions: 5 } },
      { id: 'enhance_10', type: 'ENHANCE_SUCCESS', description: 'Ïû•ÎπÑ +10Í∞ï ÏÑ±Í≥µ', target: 10, reward: { gold: 2000, dust: 100 } },
      { id: 'collect_gold_50k', type: 'COLLECT_GOLD', description: 'Ï¥ù 50,000Í≥®Îìú ÏàòÏßë', target: 50000, reward: { stones: 20, potions: 3 } },
      { id: 'first_rebirth', type: 'REBIRTH', description: 'Ï≤´ ÌôòÏÉù Îã¨ÏÑ±', target: 1, reward: { stones: 50, dust: 250 } },
    ];
    
    const REBIRTH_UPGRADES = {
        'gold_gain': { name: 'Í≥®Îìú ÌöçÎìùÎüâ Ï¶ùÍ∞Ä', description: level => `Í≥®Îìú ÌöçÎìùÎüâÏù¥ ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ${level * 5}% Ï¶ùÍ∞ÄÌï©ÎãàÎã§.`, cost: level => (level + 1) },
        'xp_gain': { name: 'Í≤ΩÌóòÏπò ÌöçÎìùÎüâ Ï¶ùÍ∞Ä', description: level => `Í≤ΩÌóòÏπò ÌöçÎìùÎüâÏù¥ ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ${level * 5}% Ï¶ùÍ∞ÄÌï©ÎãàÎã§.`, cost: level => (level + 1) },
        'base_atk': { name: 'Í∏∞Î≥∏ Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä', description: level => `Î™®Îì† ÏßÅÏóÖÏùò Í∏∞Î≥∏ Í≥µÍ≤©Î†•Ïù¥ ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ${level * 2} Ï¶ùÍ∞ÄÌï©ÎãàÎã§.`, cost: level => (level + 1) * 2 },
        'base_hp': { name: 'Í∏∞Î≥∏ ÏÉùÎ™ÖÎ†• Ï¶ùÍ∞Ä', description: level => `Î™®Îì† ÏßÅÏóÖÏùò Í∏∞Î≥∏ ÏÉùÎ™ÖÎ†•Ïù¥ ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ${level * 10} Ï¶ùÍ∞ÄÌï©ÎãàÎã§.`, cost: level => (level + 1) * 2 },
        'ultimate_cooldown': { name: 'Í∂ÅÍ∑πÏùò Í∏∞Ïà† Ïó∞Îßà', maxLevel: 4, description: level => `Í∂ÅÍ∑πÍ∏∞ Ïû¨ÏÇ¨Ïö© ÎåÄÍ∏∞ÏãúÍ∞ÑÏù¥ ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ${level * 5}% Í∞êÏÜåÌï©ÎãàÎã§. (ÌòÑÏû¨: -${level*5}%)`, cost: level => (level + 1) * 3 }
    };


    let player;
    let monster;
    let messageLog;
    let currentScreen;
    let currentDifficulty;
    let dungeonLevel;
    let dungeonFloor;
    let dailyQuests = [];
    let lastQuestDate = '';
    let shopFilterType = 'all';
    let shopFilterRarity = 'all';
    let blacksmithMode = 'enhance';
    let synthesisSelection = [null, null]; // { item, inventoryIndex }
    let batchDisenchantFilters = { common: false, uncommon: false, rare: false };
    let questScreenMode = 'daily';
    let guideElementsRendered = false;
    
    let survivalWave = 0;


    const monsterList = [
        { name: 'Ïä¨ÎùºÏûÑ', emoji: 'üíß', baseHp: 20, baseAttack: 5, xp: 25, gold: 5, lootTable: [102, 105] },
        { name: 'Í≥†Î∏îÎ¶∞', emoji: 'üë∫', baseHp: 30, baseAttack: 7, xp: 40, gold: 10, lootTable: [101, 103, 105, 107, 108], onHitEffect: {type: 'weaken', chance: 0.2, duration: 2, potency: 0.1} },
        { name: 'Ïò§ÌÅ¨', emoji: 'üëπ', baseHp: 45, baseAttack: 11, xp: 60, gold: 15, lootTable: [101, 106, 201] },
        { name: 'ÎèÖÍ±∞ÎØ∏', emoji: 'üï∑Ô∏è', baseHp: 55, baseAttack: 12, xp: 75, gold: 20, lootTable: [205, 203, 207, 208], onHitEffect: {type: 'poison', chance: 0.4, duration: 3, potency: 4} },
        { name: 'Ïä§ÏºàÎ†àÌÜ§', emoji: 'üíÄ', baseHp: 65, baseAttack: 14, xp: 85, gold: 25, lootTable: [201, 206] },
    ];

    const bossList = [
        { name: 'ÎèôÍµ¥ Ìä∏Î°§', emoji: 'üóø', baseHp: 100, baseAttack: 18, xp: 200, gold: 100, lootTable: [201, 206, 205], onHitEffect: {type: 'stun', chance: 0.2, duration: 1, potency: 0} },
        { name: 'Í±∞ÎåÄ Í≥®Î†ò', emoji: 'ü§ñ', baseHp: 150, baseAttack: 23, xp: 300, gold: 150, lootTable: [202, 204, 303], onHitEffect: {type: 'vulnerable', chance: 0.5, duration: 2, potency: 0.25} },
        { name: 'ÌùëÍ∏∞ÏÇ¨', emoji: '‚ôû', baseHp: 200, baseAttack: 28, xp: 450, gold: 220, lootTable: [301, 303, 307, 308], onHitEffect: {type: 'weaken', chance: 0.4, duration: 3, potency: 0.2} },
        { name: 'ÎìúÎûòÍ≥§', emoji: 'üê≤', baseHp: 270, baseAttack: 34, xp: 600, gold: 300, lootTable: [301, 302], onHitEffect: {type: 'burn', chance: 0.7, duration: 3, potency: 15} },
    ];
    
    // --- Helper Functions ---
    function isInventoryFull() {
        return player.inventory.length >= INVENTORY_LIMIT;
    }

    function canAddItem(count = 1) {
        return player.inventory.length + count <= INVENTORY_LIMIT;
    }

    function removeGuideElements() {
        document.getElementById('guide-button')?.remove();
        document.getElementById('guide-modal')?.remove();
        guideElementsRendered = false;
    }

    function removePermanentUI() {
        document.getElementById('game-reset-button')?.remove();
        document.getElementById('rank-display')?.remove();
    }

    function getPlayerRank() {
        if (!player) return { rank: 'C', colorClass: 'rank-C' };
        if (player.rebirths >= 3 && player.isLiberated) return { rank: 'SSS', colorClass: 'rank-SSS' };
        if (player.rebirths >= 3) return { rank: 'SS', colorClass: 'rank-SS' };
        if (player.rebirths >= 2) return { rank: 'S', colorClass: 'rank-S' };
        if (player.rebirths >= 1) return { rank: 'A', colorClass: 'rank-A' };
        if (player.level >= 15) return { rank: 'B', colorClass: 'rank-B' };
        return { rank: 'C', colorClass: 'rank-C' };
    }

    function renderPermanentUI() {
        let resetButton = document.getElementById('game-reset-button');
        if (!resetButton) {
            resetButton = document.createElement('button');
            resetButton.id = 'game-reset-button';
            resetButton.textContent = 'Í≤åÏûÑ Ï¥àÍ∏∞Ìôî';
            document.body.appendChild(resetButton);
            resetButton.addEventListener('click', () => {
                if (confirm('Ï†ïÎßêÎ°ú Í≤åÏûÑÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå? Î™®Îì† ÏßÑÌñâ ÏÉÅÌô©Ïù¥ ÏÇ≠Ï†úÎêòÍ≥† ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.')) {
                    removePermanentUI();
                    deleteSaveData(false);
                    createStartScreen();
                }
            });
        }

        let rankDisplay = document.getElementById('rank-display');
        if (!rankDisplay) {
            rankDisplay = document.createElement('div');
            rankDisplay.id = 'rank-display';
            document.body.appendChild(rankDisplay);
        }
        
        const { rank, colorClass } = getPlayerRank();
        rankDisplay.innerHTML = `
            <span>RANK</span>
            <span class="${colorClass}">${rank}</span>
        `;
    }

    function renderGuideElements() {
        if (guideElementsRendered) return;

        const guideButton = document.createElement('button');
        guideButton.id = 'guide-button';
        guideButton.textContent = '‚ùì';
        guideButton.title = 'Ï¥àÎ≥¥Ïûê Í∞ÄÏù¥Îìú';

        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'guide-modal';
        modalOverlay.className = 'modal-overlay';
        modalOverlay.innerHTML = `
            <div class="modal-content">
                <h2>Ï¥àÎ≥¥Ïûê Í∞ÄÏù¥Îìú</h2>
                <div class="modal-body">
                    <h3>Í≤åÏûÑ Î™©Ìëú</h3>
                    <p>ÎçòÏ†ÑÏóê ÏûÖÏû•ÌïòÏó¨ Î™¨Ïä§ÌÑ∞Î•º Ï≤òÏπòÌïòÍ≥†, Îçî Ï¢ãÏùÄ Ïû•ÎπÑÎ•º ÌöçÎìùÌïòÏó¨ Ï∫êÎ¶≠ÌÑ∞Î•º ÏÑ±Ïû•ÏãúÌÇ§ÏÑ∏Ïöî. ÏµúÏ¢Ö Î™©ÌëúÎäî Îçî ÎÜíÏùÄ Î†àÎ≤®Ïùò ÎçòÏ†ÑÏùÑ ÌÅ¥Î¶¨Ïñ¥ÌïòÍ≥†, ÌôòÏÉùÏùÑ ÌÜµÌï¥ ÏòÅÍµ¨Ï†ÅÏúºÎ°ú Í∞ïÌï¥ÏßÄÎäî Í≤ÉÏûÖÎãàÎã§.</p>
                    
                    <h3>Ï†ÑÌà¨</h3>
                    <ul>
                        <li><strong>Í≥µÍ≤©:</strong> Í∏∞Î≥∏ Í≥µÍ≤©ÏúºÎ°ú Î™¨Ïä§ÌÑ∞ÏóêÍ≤å ÌîºÌï¥Î•º Ï§çÎãàÎã§.</li>
                        <li><strong>Î¨ºÏïΩ:</strong> Ï≤¥Î†•ÏùÑ ÌöåÎ≥µÌï©ÎãàÎã§. ÏÉÅÏ†êÏóêÏÑú Íµ¨Îß§Ìï† Ïàò ÏûàÏäµÎãàÎã§.</li>
                        <li><strong>ÌäπÏàò Í∏∞Ïà†:</strong> ÏßÅÏóÖÎßàÎã§ Í≥†Ïú†Ïùò Í∞ïÎ†•Ìïú Í∏∞Ïà†ÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§. ÏÇ¨Ïö© ÌõÑÏóêÎäî Ïû¨ÏÇ¨Ïö© ÎåÄÍ∏∞ÏãúÍ∞ÑÏù¥ ÏûàÏäµÎãàÎã§.</li>
                        <li><strong>ÏÉÅÌÉú Ïù¥ÏÉÅ:</strong> ÎèÖ, ÌôîÏÉÅ, Í∏∞Ï†à Îì± Îã§ÏñëÌïú Ìö®Í≥ºÍ∞Ä Ï†ÑÌà¨Ïóê ÏòÅÌñ•ÏùÑ Ï§çÎãàÎã§. Î™¨Ïä§ÌÑ∞ÏôÄ ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎëêÏóêÍ≤å Ï†ÅÏö©Îê† Ïàò ÏûàÏäµÎãàÎã§.</li>
                    </ul>

                    <h3>ÏÑ±Ïû•Í≥º Ïû•ÎπÑ</h3>
                    <ul>
                        <li><strong>Î†àÎ≤®ÏóÖ:</strong> Î™¨Ïä§ÌÑ∞Î•º Ï≤òÏπòÌïòÏó¨ Í≤ΩÌóòÏπò(XP)Î•º ÏñªÍ≥† Î†àÎ≤®ÏùÑ Ïò¨Î¶ΩÎãàÎã§.</li>
                        <li><strong>Ïû•ÎπÑ Îì±Í∏â:</strong> ÏùºÎ∞ò(Ìù∞ÏÉâ) &lt; Í≥†Í∏â(Ï¥àÎ°ùÏÉâ) &lt; Ìù¨Í∑Ä(ÌååÎûÄÏÉâ) &lt; Ï†ÑÏÑ§(Ï£ºÌô©ÏÉâ) &lt; Ïã†Ìôî(Îπ®Í∞ÑÏÉâ) &lt; Í∂ÅÍ∑π(Ï≤≠Î°ùÏÉâ) ÏàúÏúºÎ°ú Í∞ïÎ†•Ìï©ÎãàÎã§.</li>
                        <li><strong>Ïû•ÎπÑ Í¥ÄÎ¶¨:</strong> 'Ïû•ÎπÑ' Î©îÎâ¥ÏóêÏÑú ÏïÑÏù¥ÌÖúÏùÑ Ïû•Ï∞©ÌïòÍ±∞ÎÇò Ïû†Í∏Ä Ïàò ÏûàÏäµÎãàÎã§. Ïû†Í∏¥ ÏïÑÏù¥ÌÖúÏùÄ Î∂ÑÌï¥Í∞Ä Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§. <strong>Ïù∏Î≤§ÌÜ†Î¶¨Îäî ${INVENTORY_LIMIT}Ïπ∏ÏúºÎ°ú Ï†úÌïúÎê©ÎãàÎã§.</strong></li>
                    </ul>

                    <h3>ÎåÄÏû•Í∞Ñ</h3>
                    <ul>
                        <li><strong>Í∞ïÌôî:</strong> Í≥®ÎìúÏôÄ Í∞ïÌôîÏÑùÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ïû•ÎπÑÏùò Í∏∞Î≥∏ Îä•Î†•ÏπòÎ•º Ïò¨Î¶ΩÎãàÎã§. Í∞ïÌôî Î†àÎ≤®Ïù¥ ÎÜíÏùÑÏàòÎ°ù ÏÑ±Í≥µ ÌôïÎ•†Ïù¥ Í∞êÏÜåÌïòÎ©∞, Ïã§Ìå® Ïãú Ìå®ÎÑêÌã∞Í∞Ä ÏûàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.</li>
                        <li><strong>Î∂ÑÌï¥:</strong> ÌïÑÏöî ÏóÜÎäî Ïû•ÎπÑÎ•º Î∂ÑÌï¥ÌïòÏó¨ Í∞ïÌôîÏÑùÍ≥º ÎßàÎ≤ï Î∂ÄÏó¨ Í∞ÄÎ£®Î•º ÏñªÏäµÎãàÎã§. 'ÏùºÍ¥Ñ Î∂ÑÌï¥' ÌÉ≠ÏóêÏÑú Ïó¨Îü¨ ÏïÑÏù¥ÌÖúÏùÑ ÌïúÎ≤àÏóê Î∂ÑÌï¥Ìï† Ïàò ÏûàÏäµÎãàÎã§.</li>
                        <li><strong>Ìï©ÏÑ±:</strong> Ïù∏Î≤§ÌÜ†Î¶¨ÏóêÏÑú ÎèôÏùºÌïú ÌïòÏúÑ Îì±Í∏â Ïû•ÎπÑ 2Í∞úÎ•º ÏÑ†ÌÉùÌïòÍ≥† Ïû¨Î£åÎ•º Ï°∞Ìï©ÌïòÏó¨ ÏÉÅÏúÑ Îì±Í∏âÏùò Ïû•ÎπÑ 1Í∞úÎ•º Ï†úÏûëÌï©ÎãàÎã§. Ïû¨Î£åÎ°ú ÏÇ¨Ïö©ÎêòÎäî Ïû•ÎπÑÎäî Í∞ïÌôî/ÎßàÎ≤ïÎ∂ÄÏó¨Í∞Ä ÏóÜÏñ¥Ïïº Ìï©ÎãàÎã§.</li>
                        <li><strong>ÎßàÎ≤ï Î∂ÄÏó¨:</strong> ÎßàÎ≤ï Î∂ÄÏó¨ Í∞ÄÎ£®ÏôÄ Í≥®ÎìúÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Ïû•ÎπÑÏóê Î¨¥ÏûëÏúÑ Ï∂îÍ∞Ä ÏòµÏÖòÏùÑ Î∂ÄÏó¨Ìï©ÎãàÎã§.</li>
                    </ul>

                    <h3>Ïä§ÌÇ¨Í≥º ÌôòÏÉù</h3>
                    <ul>
                        <li><strong>Ïä§ÌÇ¨ Ìä∏Î¶¨:</strong> Í≥®ÎìúÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏßÅÏóÖÎ≥Ñ Ìå®ÏãúÎ∏å Ïä§ÌÇ¨ÏùÑ Î∞∞Ïõå Ï∫êÎ¶≠ÌÑ∞Î•º ÌäπÌôîÏãúÌÇ¨ Ïàò ÏûàÏäµÎãàÎã§.</li>
                        <li><strong>ÌôòÏÉù:</strong> 30Î†àÎ≤®Ïóê ÎèÑÎã¨ÌïòÎ©¥ ÌôòÏÉùÏù¥ Í∞ÄÎä•Ìï©ÎãàÎã§. Î†àÎ≤®, Í≥®Îìú Îì±Ïù¥ Ï¥àÍ∏∞ÌôîÎêòÏßÄÎßå, 'ÌôòÏÉù Ìè¨Ïù∏Ìä∏(RP)'Î•º ÏñªÏñ¥ ÏòÅÍµ¨Ï†ÅÏù∏ Îä•Î†•ÏπòÎ•º Ïò¨Î¶¥ Ïàò ÏûàÏäµÎãàÎã§. Ïû•ÎπÑÏôÄ ÏïÑÏù¥ÌÖúÏùÄ Ïú†ÏßÄÎê©ÎãàÎã§.</li>
                    </ul>

                    <h3>Í∏∞ÌÉÄ ÏΩòÌÖêÏ∏†</h3>
                    <ul>
                        <li><strong>ÌÄòÏä§Ìä∏:</strong> ÏùºÏùº/ÏòÅÍµ¨ ÌÄòÏä§Ìä∏Î•º ÏôÑÎ£åÌïòÍ≥† Î≥¥ÏÉÅÏùÑ Î∞õÏúºÏÑ∏Ïöî.</li>
                        <li><strong>ÏÑúÎ∞îÏù¥Î≤å ÎçòÏ†Ñ:</strong> ÎÅùÏóÜÏù¥ Î™∞Î†§Ïò§Îäî Î™¨Ïä§ÌÑ∞Î•º ÏÉÅÎåÄÎ°ú ÏµúÎåÄÌïú Ïò§Îûò Î≤ÑÌã∞Í≥† Í≥®ÎìúÎ•º ÌöçÎìùÌïòÏÑ∏Ïöî. ÎÜíÏùÄ Ïõ®Ïù¥Î∏åÎ•º Îã¨ÏÑ±Ìï†ÏàòÎ°ù Îçî ÎßéÏùÄ Í≥®ÎìúÎ•º ÏñªÏäµÎãàÎã§.</li>
                        <li><strong>ÎΩëÍ∏∞:</strong> Í≥®ÎìúÎ•º ÏÜåÎ™®ÌïòÏó¨ Î¨¥ÏûëÏúÑ Ïû•ÎπÑ ÎòêÎäî Í∞ïÌôîÏÑùÏùÑ ÌöçÎìùÌï† Ïàò ÏûàÏäµÎãàÎã§. Ïã†Ìôî, Í∂ÅÍ∑π Îì±Í∏â Ïû•ÎπÑÎäî Ïò§ÏßÅ ÎΩëÍ∏∞ÏóêÏÑúÎßå ÎÇòÏòµÎãàÎã§.</li>
                    </ul>
                </div>
                <div class="modal-footer">
                    <button id="close-guide-button" class="button">Îã´Í∏∞</button>
                </div>
            </div>
        `;

        document.body.appendChild(guideButton);
        document.body.appendChild(modalOverlay);

        guideButton.addEventListener('click', () => {
            modalOverlay.style.display = 'flex';
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.style.display = 'none';
            }
        });
        
        document.getElementById('close-guide-button')?.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });
        
        guideElementsRendered = true;
    }
    
    function createStartScreen() {
        currentScreen = 'START';
        removeGuideElements();
        removePermanentUI();
        const hasSaveData = !!localStorage.getItem('simpleRPG_saveData');
        
        root.innerHTML = `
            <div class="screen-container">
                <h1 class="logo">‚öîÔ∏è Í∞ÑÎã®RPG üõ°Ô∏è</h1>
                <div id="action-buttons" class="town-actions" style="grid-template-columns: 1fr; max-width: 250px; gap: 0.8rem;">
                    <button data-action="new-game" class="button">ÏÉà Í≤åÏûÑ</button>
                    <button data-action="continue-game" class="button" style="${hasSaveData ? '' : 'display: none;'}">Ïù¥Ïñ¥ÌïòÍ∏∞</button>
                    <button data-action="delete-save" class="button" style="${hasSaveData ? '' : 'display: none;'} background-color: var(--monster-hp-color);">Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú</button>
                </div>
            </div>
        `;

        document.getElementById('action-buttons')?.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (action === 'new-game') {
                if (hasSaveData && !confirm('Í∏∞Ï°¥ Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏäµÎãàÎã§. Ï†ïÎßêÎ°ú ÏÉà Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå? Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÇ≠Ï†úÎê©ÎãàÎã§.')) {
                    return;
                }
                deleteSaveData(false); // Silently delete
                createDifficultySelectionScreen();
            } else if (action === 'continue-game') {
                if(loadGameState()) {
                    renderTownScreen();
                } else {
                    alert("Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
                }
            } else if (action === 'delete-save') {
                if (confirm('Ï†ïÎßêÎ°ú Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.')) {
                    deleteSaveData(true);
                }
            }
        });
    }


    function createItemInstance(itemId) {
        const itemData = ITEM_DATABASE.find(i => i.id === itemId);
        if (!itemData) return null;

        const newItem = JSON.parse(JSON.stringify(itemData));
        newItem.enhancementLevel = 0;
        newItem.enchantment = null;
        newItem.isLocked = false;
        return newItem;
    }

    function createDifficultySelectionScreen() {
        currentScreen = 'DIFFICULTY_SELECTION';
        removeGuideElements();
        removePermanentUI();
        root.innerHTML = `
            <div class="screen-container">
                 <h1 class="logo">‚öîÔ∏è Í∞ÑÎã®RPG üõ°Ô∏è</h1>
                <h1>ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù</h1>
                <p>Î™®ÌóòÏùò ÎÇúÏù¥ÎèÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
                <div class="difficulty-selection">
                    <button class="difficulty-card" data-difficulty="Ïâ¨ÏõÄ">
                        <h2>Ïâ¨ÏõÄ</h2>
                        <p>Î™¨Ïä§ÌÑ∞Í∞Ä ÏïΩÌï¥ÏßÄÍ≥†, Îçî ÎßéÏùÄ ÏûêÏõêÏúºÎ°ú ÏãúÏûëÌï©ÎãàÎã§. Ìé∏ÏïàÌïú ÌîåÎ†àÏù¥Ïóê Ï†ÅÌï©Ìï©ÎãàÎã§.</p>
                    </button>
                    <button class="difficulty-card" data-difficulty="Î≥¥ÌÜµ">
                        <h2>Î≥¥ÌÜµ</h2>
                        <p>ÌëúÏ§ÄÏ†ÅÏù∏ RPG Í≤ΩÌóòÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.</p>
                    </button>
                    <button class="difficulty-card" data-difficulty="Ïñ¥Î†§ÏõÄ">
                        <h2>Ïñ¥Î†§ÏõÄ</h2>
                        <p>Î™¨Ïä§ÌÑ∞Í∞Ä Îß§Ïö∞ Í∞ïÎ†•Ìï©ÎãàÎã§. Î≥¥ÏÉÅÏù¥ ÌÅ¨ÏßÄÎßå, ÏÉÅÎãπÌïú ÎèÑÏ†ÑÏùÑ ÏöîÍµ¨Ìï©ÎãàÎã§.</p>
                    </button>
                </div>
            </div>
        `;

        document.querySelectorAll('.difficulty-card').forEach(card => {
            card.addEventListener('click', (e) => {
                currentDifficulty = e.currentTarget.dataset.difficulty;
                createClassSelectionScreen();
            });
        });
    }

    function renderDifficultyChangeScreen() {
      currentScreen = 'DIFFICULTY_CHANGE';
      renderPermanentUI();
      root.innerHTML = `
        <div class="screen-container">
          <h1>ÎÇúÏù¥ÎèÑ Î≥ÄÍ≤Ω</h1>
          <p>Î≥ÄÍ≤ΩÌï† ÎÇúÏù¥ÎèÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî. Îã§Ïùå ÎçòÏ†ÑÎ∂ÄÌÑ∞ Ï†ÅÏö©Îê©ÎãàÎã§. (ÌòÑÏû¨: ${currentDifficulty})</p>
          <div class="difficulty-selection">
            <button class="difficulty-card" data-difficulty="Ïâ¨ÏõÄ"><h2>Ïâ¨ÏõÄ</h2><p>Ìé∏ÏïàÌïú ÌîåÎ†àÏù¥.</p></button>
            <button class="difficulty-card" data-difficulty="Î≥¥ÌÜµ"><h2>Î≥¥ÌÜµ</h2><p>ÌëúÏ§ÄÏ†ÅÏù∏ Í≤ΩÌóò.</p></button>
            <button class="difficulty-card" data-difficulty="Ïñ¥Î†§ÏõÄ"><h2>Ïñ¥Î†§ÏõÄ</h2><p>Îçî ÌÅ∞ ÎèÑÏ†ÑÍ≥º Î≥¥ÏÉÅ.</p></button>
          </div>
          <button id="back-to-town" class="button" style="margin-top: 1rem; width: 100%;">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
        </div>
      `;
      document.querySelectorAll('.difficulty-card').forEach(card => {
        card.addEventListener('click', (e) => {
          const newDifficulty = e.currentTarget.dataset.difficulty;
          if (newDifficulty !== currentDifficulty) {
            currentDifficulty = newDifficulty;
            saveGameState();
            alert(`ÎÇúÏù¥ÎèÑÍ∞Ä ${newDifficulty}(Ïúº)Î°ú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.`);
          }
          renderTownScreen();
        });
      });
      document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }


    function createClassSelectionScreen() {
        currentScreen = 'CLASS_SELECTION';
        removePermanentUI();
        root.innerHTML = `
            <div class="screen-container">
                <h1>ÏßÅÏóÖ ÏÑ†ÌÉù</h1>
                <p>Î™®ÌóòÏùÑ Ìï®ÍªòÌï† ÎãπÏã†Ïùò ÏßÅÏóÖÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
                <div class="class-selection">
                    <button class="class-card" data-class="Ï†ÑÏÇ¨">
                        <h2>Ï†ÑÏÇ¨ üõ°Ô∏è</h2>
                        <p>ÎÜíÏùÄ Ï≤¥Î†•Í≥º Î∞©Ïñ¥Î†•. Ï†ÅÏùÑ ÏïΩÌôîÏãúÌÇ§Í≥† Î≤ÑÌã∞Îäî Ï†ÑÌà¨Î•º Ïù¥ÎÅåÏñ¥Í∞ëÎãàÎã§.</p>
                    </button>
                    <button class="class-card" data-class="ÎßàÎ≤ïÏÇ¨">
                        <h2>ÎßàÎ≤ïÏÇ¨ üî•</h2>
                        <p>Í∞ïÎ†•Ìïú ÏõêÏÜå ÎßàÎ≤ïÏúºÎ°ú Ï†ÅÏùÑ Î∂àÌÉúÏö∞Í±∞ÎÇò ÏñºÎ¶ΩÎãàÎã§.</p>
                    </button>
                    <button class="class-card" data-class="ÏïîÏÇ¥Ïûê">
                        <h2>ÏïîÏÇ¥Ïûê üí®</h2>
                        <p>ÏπòÎ™ÖÏ†ÅÏù∏ Í≥µÍ≤©Í≥º ÎÜíÏùÄ ÌöåÌîºÏú®Î°ú Ï†ÅÏùÑ ÏàúÏãùÍ∞ÑÏóê Ï†úÏïïÌï©ÎãàÎã§.</p>
                    </button>
                    <button class="class-card" data-class="Í∂ÅÏàò">
                        <h2>Í∂ÅÏàò üèπ</h2>
                        <p>ÎÇ†Ïπ¥Î°úÏö¥ ÌôîÏÇ¥Î°ú ÏõêÍ±∞Î¶¨ÏóêÏÑú Ï†ÅÏùò ÏïΩÏ†êÏùÑ ÎÖ∏Î¶ΩÎãàÎã§. ÏπòÎ™ÖÌÉÄ Í≥µÍ≤©Ïóê ÌäπÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.</p>
                    </button>
                </div>
            </div>
        `;

        document.querySelectorAll('.class-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const selectedClass = e.currentTarget.dataset.class;
                const playerName = prompt("Ïö©ÏÇ¨ÎãòÏùò Ïù¥Î¶ÑÏùÄ Î¨¥ÏóáÏûÖÎãàÍπå?", "Ïö©ÏÇ¨") || "Ïö©ÏÇ¨";
                 if (selectedClass) {
                    initializeGame(selectedClass, playerName);
                }
            });
        });
    }

    function createClassChangeScreen() {
        currentScreen = 'CLASS_SELECTION';
        renderPermanentUI();
        root.innerHTML = `
            <div class="screen-container">
                <h1>ÏßÅÏóÖ Î≥ÄÍ≤Ω</h1>
                <p>ÏÉàÎ°úÏö¥ ÏßÅÏóÖÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî. Í∏∞Ï°¥ ÏßÅÏóÖÍ≥º Îã§Î•∏ ÏßÅÏóÖÏùÑ ÏÑ†ÌÉùÌï¥Ïïº Ìï©ÎãàÎã§.</p>
                <div class="class-selection">
                    <button class="class-card" data-class="Ï†ÑÏÇ¨" ${player.className === 'Ï†ÑÏÇ¨' ? 'disabled' : ''}>
                        <h2>Ï†ÑÏÇ¨ üõ°Ô∏è</h2>
                        <p>ÎÜíÏùÄ Ï≤¥Î†•Í≥º Î∞©Ïñ¥Î†•. Ï†ÅÏùÑ ÏïΩÌôîÏãúÌÇ§Í≥† Î≤ÑÌã∞Îäî Ï†ÑÌà¨Î•º Ïù¥ÎÅåÏñ¥Í∞ëÎãàÎã§.</p>
                    </button>
                    <button class="class-card" data-class="ÎßàÎ≤ïÏÇ¨" ${player.className === 'ÎßàÎ≤ïÏÇ¨' ? 'disabled' : ''}>
                        <h2>ÎßàÎ≤ïÏÇ¨ üî•</h2>
                        <p>Í∞ïÎ†•Ìïú ÏõêÏÜå ÎßàÎ≤ïÏúºÎ°ú Ï†ÅÏùÑ Î∂àÌÉúÏö∞Í±∞ÎÇò ÏñºÎ¶ΩÎãàÎã§.</p>
                    </button>
                    <button class="class-card" data-class="ÏïîÏÇ¥Ïûê" ${player.className === 'ÏïîÏÇ¥Ïûê' ? 'disabled' : ''}>
                        <h2>ÏïîÏÇ¥Ïûê üí®</h2>
                        <p>ÏπòÎ™ÖÏ†ÅÏù∏ Í≥µÍ≤©Í≥º ÎÜíÏùÄ ÌöåÌîºÏú®Î°ú Ï†ÅÏùÑ ÏàúÏãùÍ∞ÑÏóê Ï†úÏïïÌï©ÎãàÎã§.</p>
                    </button>
                    <button class="class-card" data-class="Í∂ÅÏàò" ${player.className === 'Í∂ÅÏàò' ? 'disabled' : ''}>
                        <h2>Í∂ÅÏàò üèπ</h2>
                        <p>ÎÇ†Ïπ¥Î°úÏö¥ ÌôîÏÇ¥Î°ú ÏõêÍ±∞Î¶¨ÏóêÏÑú Ï†ÅÏùò ÏïΩÏ†êÏùÑ ÎÖ∏Î¶ΩÎãàÎã§. ÏπòÎ™ÖÌÉÄ Í≥µÍ≤©Ïóê ÌäπÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.</p>
                    </button>
                </div>
                <button id="back-to-town" class="button" style="margin-top: 1rem; width: 100%;">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
            </div>
        `;

        document.querySelectorAll('.class-card:not([disabled])').forEach(card => {
            card.addEventListener('click', (e) => {
                const newClass = e.currentTarget.dataset.class;
                if (newClass && player.gold >= CLASS_CHANGE_COST) {
                    if (confirm(`ÏßÅÏóÖÏùÑ Î≥ÄÍ≤ΩÌïòÏãúÍ≤†ÏäµÎãàÍπå? ${CLASS_CHANGE_COST} Í≥®ÎìúÍ∞Ä ÏÜåÎ™®ÎêòÎ©∞, Î™®Îì† Ïä§ÌÇ¨Ïù¥ Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§.`)) {
                        player.gold -= CLASS_CHANGE_COST;
                        handleChangeClass(newClass);
                    }
                } else if (player.gold < CLASS_CHANGE_COST) {
                    alert('Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.');
                }
            });
        });
        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }

    function handleChangeClass(newClass) {
        const classData = CLASSES[newClass];
        
        player.className = newClass;
        player.weaponName = classData.weapon;
        
        player.ultimateSkillLevel = 1;
        player.ultimateSkillCooldown = 0;
        player.ultimateSkill2Cooldown = 0;
        player.unlockedSkills = {};
        
        Object.keys(player.equipment).forEach(slot => {
            const item = player.equipment[slot];
            if (item && !item.classRestriction.includes(newClass)) {
                unequipItem(slot);
            }
        });
        
        recalculatePlayerStats();
        player.hp = player.maxHp;

        messageLog.unshift(`‚ú® ÏßÅÏóÖÏùÑ ${newClass}(Ïúº)Î°ú Î≥ÄÍ≤ΩÌñàÏäµÎãàÎã§!`);
        saveGameState();
        renderTownScreen();
    }

    function initializeGame(chosenClass, playerName) {
      dungeonLevel = 1;

      const classData = CLASSES[chosenClass];
      const difficultySettings = DIFFICULTY_SETTINGS[currentDifficulty];
      
      const permanentQuests = JSON.parse(JSON.stringify(PERMANENT_QUESTS_DATA)).map(q => ({...q, progress: 0, isComplete: false, isClaimed: false }));
      const rebirthUpgrades = {};
      Object.keys(REBIRTH_UPGRADES).forEach(key => rebirthUpgrades[key] = 0);
      
      player = {
        name: playerName,
        className: chosenClass,
        weaponName: classData.weapon,
        level: 1,
        xp: 0,
        xpToNextLevel: 39,
        gold: difficultySettings.startGold,
        enhancementStones: 0,
        enchantmentDust: 0,
        survivalHighScore: 0,
        potions: difficultySettings.startPotions,
        ultimateSkillLevel: 1,
        ultimateSkillCooldown: 0,
        ultimateSkill2Cooldown: 0,
        activeBuffs: [],
        statusEffects: [],
        equipment: { weapon: null, armor: null, accessory: null },
        inventory: [],
        unlockedSkills: {},
        permanentQuests,
        rebirths: 0,
        rebirthPoints: 0,
        rebirthUpgrades,
        baseStats: {},
        hp: 0, maxHp: 0, attackPower: 0, defense: 0, 
        critChance: 0, critDamage: 0, evadeChance: 0,
        isLiberated: false,
      };
      recalculatePlayerStats();
      player.hp = player.maxHp;
      messageLog = ['ÎßàÏùÑÏóê ÎèÑÏ∞©ÌñàÎã§. Î™®ÌóòÏùÑ Ï§ÄÎπÑÌïòÏûê.'];
      generateDailyQuests();
      saveGameState();
      renderTownScreen();
    }

    function recalculatePlayerStats() {
        const p = player;
        const classData = CLASSES[p.className];
        
        const tempStats = {
            maxHp: classData.baseHp,
            attackPower: classData.baseAtk,
            defense: classData.baseDef,
            critChance: classData.crit,
            critDamage: 0, // Base crit damage bonus is 0
            evadeChance: classData.evade,
        };
        
        // Rebirth Upgrades
        tempStats.maxHp += (p.rebirthUpgrades.base_hp || 0) * 10;
        tempStats.attackPower += (p.rebirthUpgrades.base_atk || 0) * 2;
        
        p.baseStats = { ...tempStats }; // Save base stats after rebirth mods
        
        Object.values(p.equipment).forEach(item => {
            if (item) {
                Object.entries(item.stats).forEach(([stat, value]) => {
                    if (stat in tempStats) {
                        tempStats[stat] += value;
                    }
                });
                if (item.enchantment) {
                     Object.entries(item.enchantment.effects).forEach(([stat, value]) => {
                        if (stat.includes('Percent')) return;
                        if (stat in tempStats) {
                            tempStats[stat] += value;
                        }
                    });
                }
            }
        });

        const classSkills = SKILL_DATA[p.className];
        Object.entries(p.unlockedSkills).forEach(([skillId, level]) => {
            const skill = classSkills[skillId];
            if (skill) {
                skill.effects(level).forEach(effect => {
                    if (effect.stat in tempStats) {
                         tempStats[effect.stat] += effect.value;
                    }
                });
            }
        });

        let percentModifiers = { maxHp: 1, attackPower: 1, defense: 1 };
        Object.values(p.equipment).forEach(item => {
            if (item && item.enchantment) {
                 Object.entries(item.enchantment.effects).forEach(([stat, value]) => {
                    if (stat === 'attackPowerPercent') percentModifiers.attackPower += value;
                    if (stat === 'maxHpPercent') percentModifiers.maxHp += value;
                    if (stat === 'defensePercent') percentModifiers.defense += value;
                });
            }
        });

        p.maxHp = Math.floor(tempStats.maxHp * percentModifiers.maxHp);
        p.attackPower = Math.floor(tempStats.attackPower * percentModifiers.attackPower);
        p.defense = Math.floor(tempStats.defense * percentModifiers.defense);
        p.critChance = tempStats.critChance;
        p.critDamage = tempStats.critDamage;
        p.evadeChance = tempStats.evadeChance;

        let buffAtkPercent = 0;
        let buffDefPercent = 0;
        p.activeBuffs.forEach(buff => {
            const b = buff.effect;
            if (!b) return;
            if (b.isPercent) {
                if (b.stat === 'attackPower') buffAtkPercent += b.value;
                if (b.stat === 'defense') {
                    let bonus = b.value;
                    if (p.unlockedSkills['w_ult_1']) {
                        bonus += p.unlockedSkills['w_ult_1'] * 0.05;
                    }
                    buffDefPercent += bonus;
                }
            } else {
                 p[b.stat] += b.value;
            }
        });
        
        p.attackPower = Math.floor(p.attackPower * (1 + buffAtkPercent));
        p.defense = Math.floor(p.defense * (1 + buffDefPercent));
        
        p.statusEffects.forEach(se => {
            if (se.type === 'weaken') p.attackPower = Math.floor(p.attackPower * (1 - se.potency));
            if (se.type === 'vulnerable') p.defense = Math.floor(p.defense * (1 - se.potency));
        });

        if (p.isLiberated) {
            p.maxHp = Math.floor(p.maxHp * 2);
            p.attackPower = Math.floor(p.attackPower * 2);
            p.defense = Math.floor(p.defense * 2);
        }

        if (p.hp) {
            p.hp = Math.min(p.hp, p.maxHp);
        }
    }

    function getFloorsForDungeon(level) {
        return 3 + Math.floor((level - 1) / 3);
    }

    function renderTownScreen() {
        renderGuideElements();
        renderPermanentUI();
        currentScreen = 'TOWN';
        const canAffordClassChange = player.gold >= CLASS_CHANGE_COST;
        const hasClaimableQuests = dailyQuests.some(q => q.isComplete && !q.isClaimed) || player.permanentQuests.some(q => q.isComplete && !q.isClaimed);
        const canRebirth = player.level >= REBIRTH_LEVEL_REQ;
        
        const LIBERATION_COST = { gold: 20000, stones: 500, dust: 250 };
        const canAffordLiberation = player.gold >= LIBERATION_COST.gold && player.enhancementStones >= LIBERATION_COST.stones && player.enchantmentDust >= LIBERATION_COST.dust;

        root.innerHTML = `
            <div class="screen-container town-screen">
                <p>ÌòÑÏû¨ ÎèÑÏ†ÑÌï† ÎçòÏ†Ñ: ${dungeonLevel} Î†àÎ≤® (ÌôòÏÉù: ${player.rebirths}Ìöå) | ÎÇúÏù¥ÎèÑ: ${currentDifficulty}</p>
                ${createCharacterCard(player, true)}
                <div id="action-buttons" class="town-actions">
                    <button data-action="dungeon" class="button">ÎçòÏ†Ñ ÏûÖÏû•</button>
                    <button data-action="survival-dungeon" class="button">ÏÑúÎ∞îÏù¥Î≤å ÎçòÏ†Ñ</button>
                    <button data-action="quests" class="button quest-button">
                        ÌÄòÏä§Ìä∏
                        ${hasClaimableQuests ? '<span class="notification-badge">!</span>' : ''}
                    </button>
                    <button data-action="shop" class="button">ÏÉÅÏ†ê</button>
                    <button data-action="equipment" class="button">Ïû•ÎπÑ</button>
                    <button data-action="blacksmith" class="button">ÎåÄÏû•Í∞Ñ</button>
                    <button data-action="gacha" class="button">ÎΩëÍ∏∞</button>
                    <button data-action="skill-tree" class="button">Ïä§ÌÇ¨ Ìä∏Î¶¨</button>
                    <button data-action="class-change" class="button" ${!canAffordClassChange ? 'disabled' : ''}>ÏßÅÏóÖ Î≥ÄÍ≤Ω</button>
                    <button data-action="difficulty-change" class="button">ÎÇúÏù¥ÎèÑ Î≥ÄÍ≤Ω</button>
                    <button data-action="rebirth" class="button" style="color: ${canRebirth ? 'var(--rebirth-color)' : 'inherit'};" ${!canRebirth ? 'disabled' : ''}>ÌôòÏÉù ${!canRebirth ? `(${player.level}/${REBIRTH_LEVEL_REQ})` : ''}</button>
                    ${!player.isLiberated ? `<button data-action="liberation" class="button" ${!canAffordLiberation ? 'disabled' : ''}>Ìï¥Î∞©</button>` : ''}
                </div>
            </div>
        `;

        document.getElementById('action-buttons')?.addEventListener('click', (e) => {
            const target = e.target;
            const button = target.closest('button');
            if (!button || button.disabled) return;

            switch(button.dataset.action) {
                case 'dungeon': startDungeon(); break;
                case 'survival-dungeon': startSurvivalDungeon(); break;
                case 'quests': renderQuestScreen(); break;
                case 'shop': renderShopScreen(); break;
                case 'equipment': renderEquipmentScreen(); break;
                case 'blacksmith': renderBlacksmithScreen(); break;
                case 'gacha': renderGachaScreen(); break;
                case 'skill-tree': renderSkillTreeScreen(); break;
                case 'rebirth': renderRebirthScreen(); break;
                case 'liberation': handleLiberation(); break;
                case 'class-change':
                    createClassChangeScreen();
                    break;
                case 'difficulty-change':
                    renderDifficultyChangeScreen();
                    break;
            }
        });
        
        document.querySelector('.name-change-icon')?.addEventListener('click', () => {
            const newName = prompt("ÏÉàÎ°úÏö¥ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:", player.name);
            if (newName && newName.trim() !== "") {
                player.name = newName.trim();
                saveGameState();
                renderTownScreen();
                alert("Ïù¥Î¶ÑÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.");
            }
        });
    }

    function startDungeon() {
        dungeonFloor = 1;
        messageLog = [`ÎçòÏ†Ñ ${dungeonLevel} - ${dungeonFloor}Ï∏µÏóê ÏßÑÏûÖÌñàÎã§.`];
        spawnMonster();
        renderDungeonScreen();
    }

    function spawnMonster() {
        const floors = getFloorsForDungeon(dungeonLevel);
        const isBossFloor = dungeonFloor === floors;
        let monsterData;

        if (isBossFloor) {
            monsterData = bossList[Math.min(dungeonLevel - 1, bossList.length - 1)];
        } else {
            const monsterPool = monsterList.slice(0, Math.min(monsterList.length, dungeonLevel + 1));
            const monsterIndex = Math.floor(Math.random() * monsterPool.length);
            monsterData = monsterPool[monsterIndex];
        }
        
        const difficulty = DIFFICULTY_SETTINGS[currentDifficulty];
        const levelModifier = Math.pow(1.12, dungeonLevel - 1);
        
        monster = {
            name: isBossFloor ? `üëë ${monsterData.name}` : monsterData.name,
            emoji: monsterData.emoji,
            maxHp: Math.floor(monsterData.baseHp * levelModifier * difficulty.monsterHpMod),
            hp: Math.floor(monsterData.baseHp * levelModifier * difficulty.monsterHpMod),
            attackPower: Math.floor(monsterData.baseAttack * levelModifier * difficulty.monsterAtkMod),
            defense: 0,
            statusEffects: [],
        };
    }

    function getItemDisplayName(item) {
        if (!item) return 'ÏóÜÏùå';
        return `${item.name}${item.enhancementLevel > 0 ? ` +${item.enhancementLevel}` : ''}`;
    }

    function createCharacterCard(character, isPlayer) {
        const hpPercentage = (character.hp / character.maxHp) * 100;

        const statusEffectsHtml = character.statusEffects.map(se => {
            const def = STATUS_EFFECT_DEFINITIONS[se.type];
            return `<span class="status-effect-icon" title="${def.name}: ${se.duration}ÌÑ¥ ÎÇ®Ïùå">${def.icon}(${se.duration})</span>`;
        }).join('');

        if (isPlayer && 'className' in character) {
            const p = character;
            const ultimateSkill = ULTIMATE_SKILLS[p.className];
            const xpPercentage = (p.xp / p.xpToNextLevel) * 100;
            const floors = getFloorsForDungeon(dungeonLevel);
            const dungeonInfo = currentScreen === 'DUNGEON'
                ? `<p class="dungeon-progress">ÎçòÏ†Ñ ${dungeonLevel} - ${dungeonFloor}/${floors}Ï∏µ</p>`
                : '';
            
            const buffsHtml = p.activeBuffs.map(buff => 
                `<span class="buff-icon" title="${buff.name}: ${buff.duration}ÌÑ¥ ÎÇ®Ïùå">${buff.name.substring(0,2)}(${buff.duration})</span>`
            ).join('');
            
            const equipmentHtml = `
                <div class="player-equipment">
                    <span class="rarity-${p.equipment.weapon?.rarity || 'common'}">‚öîÔ∏è ${getItemDisplayName(p.equipment.weapon)}</span>
                    <span class="rarity-${p.equipment.armor?.rarity || 'common'}">üõ°Ô∏è ${getItemDisplayName(p.equipment.armor)}</span>
                    <span class="rarity-${p.equipment.accessory?.rarity || 'common'}">üíç ${getItemDisplayName(p.equipment.accessory)}</span>
                </div>
            `;
            const ultimateSkillHtml = currentScreen !== 'TOWN' ? '' : `
                 <div class="ultimate-skill-display">
                    <strong>ÌäπÏàò Í∏∞Ïà†:</strong> ${ultimateSkill.name}
                 </div>
            `;
            
            const nameChangeIconHtml = currentScreen === 'TOWN' ? `<span class="name-change-icon" title="Ïù¥Î¶Ñ Î≥ÄÍ≤Ω">‚úèÔ∏è</span>` : '';
            const liberationIconHtml = p.isLiberated ? '‚ú®' : '';
            const inventoryWarningHtml = isInventoryFull() ? `<p class="inventory-warning">Ïù∏Î≤§ÌÜ†Î¶¨ Í∞ÄÎìù Ï∞∏!</p>` : '';


            return `
                <div class="character-card player-card">
                    <div class="player-header">
                        <h2>${liberationIconHtml}${p.name} ${nameChangeIconHtml} <span class="player-class">(${p.className} ${CLASSES[p.className].emoji} Lv.${p.level})</span></h2>
                        <div class="gold-sp-display">
                            <p>üí∞ Gold: ${p.gold}</p>
                            <p>üíé Stones: ${p.enhancementStones}</p>
                            <p>‚ú® Dust: ${p.enchantmentDust}</p>
                            ${inventoryWarningHtml}
                        </div>
                    </div>
                     ${dungeonInfo}
                    <div class="hp-bar-container">
                        <div class="hp-bar" style="width: ${hpPercentage}%;"></div>
                    </div>
                    <p>HP: ${Math.floor(p.hp)} / ${Math.floor(p.maxHp)}</p>
                    <div class="status-effects">${statusEffectsHtml}</div>
                    <div class="xp-bar-container">
                        <div class="xp-bar" style="width: ${xpPercentage}%;"></div>
                    </div>
                    <p>XP: ${p.xp} / ${p.xpToNextLevel}</p>
                    <div class="player-stats">
                        <span>‚öîÔ∏è ATK: ${p.attackPower}</span>
                        <span>üõ°Ô∏è DEF: ${p.defense}</span>
                        <span>üß™ Î¨ºÏïΩ: ${p.potions}</span>
                    </div>
                    ${equipmentHtml}
                     ${ultimateSkillHtml}
                    <div class="player-buffs">${buffsHtml}</div>
                </div>
            `;
        }

        return `
            <div class="character-card monster-card">
                <h2>${character.name} ${character.emoji || ''}</h2>
                <div class="hp-bar-container">
                    <div class="hp-bar" style="width: ${hpPercentage}%;"></div>
                </div>
                <p>HP: ${Math.floor(character.hp)} / ${Math.floor(character.maxHp)}</p>
                <div class="status-effects">${statusEffectsHtml}</div>
            </div>
        `;
    }

    function createDungeonMapHTML() {
        const totalFloors = getFloorsForDungeon(dungeonLevel);
        let mapHtml = '<div class="dungeon-map">';
        for (let i = 1; i <= totalFloors; i++) {
            const isBoss = i === totalFloors;
            const isCurrent = i === dungeonFloor;
            const isCleared = i < dungeonFloor;
            
            let nodeClass = 'map-node';
            if (isCleared) nodeClass += ' cleared';
            if (isCurrent) nodeClass += ' current';
            if (isBoss) nodeClass += ' boss';
            
            const emoji = isBoss ? 'üëë' : '';
            
            mapHtml += `<div class="${nodeClass}" title="Floor ${i}">${emoji}</div>`;
            if (i < totalFloors) {
                mapHtml += '<div class="map-connector"></div>';
            }
        }
        mapHtml += '</div>';
        return mapHtml;
    }

    function renderDungeonScreen(isBattleOver = false) {
        if (currentScreen !== 'TOWN' && currentScreen !== 'DUNGEON' && currentScreen !== 'SURVIVAL') return;
        currentScreen = 'DUNGEON';
        renderPermanentUI();
        
        const ultimateSkill = ULTIMATE_SKILLS[player.className];
        const cooldown = player.ultimateSkillCooldown;
        const disabled = cooldown > 0 || isBattleOver;
        const skillButton = `<button data-action="ultimate" class="button skill-button" ${disabled ? 'disabled' : ''}>${ultimateSkill.name} ${disabled && !isBattleOver ? `(${cooldown})` : ''}</button>`;

        const classSkills = SKILL_DATA[player.className];
        const ultimateSkill2Id = Object.keys(classSkills).find(id => id.includes('_ult_2'));
        let skill2Button = '';
        if (ultimateSkill2Id && player.unlockedSkills[ultimateSkill2Id]) {
            const skill2 = ULTIMATE_SKILLS_2[player.className];
            const cooldown2 = player.ultimateSkill2Cooldown;
            const disabled2 = cooldown2 > 0 || isBattleOver;
            skill2Button = `<button data-action="ultimate2" class="button skill-button" ${disabled2 ? 'disabled' : ''}>${skill2.name} ${disabled2 && !isBattleOver ? `(${cooldown2})` : ''}</button>`;
        }

        root.innerHTML = `
            <div id="game-world">
                ${createDungeonMapHTML()}
                ${createCharacterCard(monster, false)}
                ${createCharacterCard(player, true)}
            </div>
            <div id="message-log">
                ${messageLog.map(msg => `<p>${msg}</p>`).join('')}
            </div>
            <div id="action-buttons">
                <button data-action="attack" class="button" ${isBattleOver ? 'disabled' : ''}>Í≥µÍ≤©</button>
                <button data-action="potion" class="button" ${player.potions <= 0 || isBattleOver ? 'disabled' : ''}>Î¨ºÏïΩ (${player.potions})</button>
                ${skillButton}
                ${skill2Button}
                <button data-action="escape" class="button" ${isBattleOver ? 'disabled' : ''}>ÌÉàÏ∂ú</button>
            </div>
        `;

        const logContainer = document.getElementById('message-log');
        if (logContainer) logContainer.scrollTop = logContainer.scrollHeight;

        document.getElementById('action-buttons')?.addEventListener('click', handleDungeonAction);
    }

    function handleDungeonAction(event) {
        const target = event.target;
        const button = target.closest('button');
        if (!button || button.disabled) return;

        const action = button.dataset.action;
        switch (action) {
            case 'attack': handlePlayerTurn(handleAttack); break;
            case 'potion': handleUsePotion(); break;
            case 'ultimate': handlePlayerTurn(handleUseUltimateSkill); break;
            case 'ultimate2': handlePlayerTurn(handleUseUltimateSkill2); break;
            case 'escape': handleEscape(); break;
        }
    }
    
    function handleEscape() {
        const goldLost = Math.floor(player.gold * ESCAPE_GOLD_PENALTY);
        if (confirm(`ÎçòÏ†ÑÏóêÏÑú ÌÉàÏ∂úÌïòÏãúÍ≤†ÏäµÎãàÍπå? ÏÜåÏßÄ Í≥®ÎìúÏùò 5% (${goldLost}G)Î•º ÏûÉÍ≤å Îê©ÎãàÎã§.`)) {
            player.gold -= goldLost;
            messageLog = [`üí∞ ${goldLost} Í≥®ÎìúÎ•º ÏûÉÍ≥† ÎçòÏ†ÑÏóêÏÑú ÌÉàÏ∂úÌñàÎã§.`];
            player.hp = player.maxHp;
            player.statusEffects = [];
            player.activeBuffs = [];
            recalculatePlayerStats();
            saveGameState();
            renderTownScreen();
        }
    }

    function handlePlayerTurn(action) {
        const isStunned = processStatusEffects(player);
        if (isStunned) {
            addMessage(`üí´ ${player.name}ÏùÄ(Îäî) Í∏∞Ï†àÌï¥ÏÑú ÏõÄÏßÅÏùº Ïàò ÏóÜÎã§!`);
            handleMonsterTurn();
            return;
        }

        if (player.ultimateSkillCooldown > 0) {
            player.ultimateSkillCooldown--;
        }
        if (player.ultimateSkill2Cooldown > 0) {
            player.ultimateSkill2Cooldown--;
        }
        player.activeBuffs = player.activeBuffs.map(buff => ({ ...buff, duration: buff.duration - 1 })).filter(buff => buff.duration > 0);
        recalculatePlayerStats();

        action();

        if (monster.hp <= 0) {
            monsterDefeated();
        } else {
            handleMonsterTurn();
        }
    }

    function handleMonsterTurn() {
        const isStunned = processStatusEffects(monster);
        recalculatePlayerStats(); 
        if (isStunned) {
            addMessage(`üí´ ${monster.name}ÏùÄ(Îäî) Í∏∞Ï†àÌï¥ÏÑú ÏõÄÏßÅÏùº Ïàò ÏóÜÎã§!`);
            renderDungeonScreen();
            return;
        }

        monsterAttack();
        
        if (player.hp <= 0) {
            handlePlayerDefeat();
        } else {
            renderDungeonScreen();
        }
    }

    function addMessage(message) {
        messageLog.unshift(message);
        if (messageLog.length > 5) messageLog.pop();
    }

    function handleAttack() {
        let playerDamage = Math.floor(player.attackPower + (Math.random() * 5 - 2));

        if (player.unlockedSkills['r_execute_1'] && monster.hp / monster.maxHp <= 0.25) {
            playerDamage = Math.floor(playerDamage * 1.2);
        }
        
        let isGuaranteedCrit = false;
        const critBuffIndex = player.activeBuffs.findIndex(b => b.effect && b.effect.guaranteedCrit);
        if (critBuffIndex !== -1) {
            isGuaranteedCrit = true;
            player.activeBuffs.splice(critBuffIndex, 1);
        }

        if (isGuaranteedCrit || Math.random() < player.critChance) {
            playerDamage = Math.floor(playerDamage * (CRIT_MULTIPLIER + player.critDamage));
            addMessage(`üí• ÏπòÎ™ÖÌÉÄ! ${isGuaranteedCrit ? '(ÌôïÏ†ï) ' : ''}${player.name}Ïù¥(Í∞Ä) ${monster.name}ÏóêÍ≤å ${playerDamage}Ïùò Îç∞ÎØ∏ÏßÄÎ•º ÏûÖÌòîÎã§!`);
        } else {
            addMessage(`‚öîÔ∏è ${player.name}Ïù¥(Í∞Ä) ${monster.name}ÏóêÍ≤å ${playerDamage}Ïùò Îç∞ÎØ∏ÏßÄÎ•º ÏûÖÌòîÎã§.`);
        }
        monster.hp = Math.max(0, monster.hp - playerDamage);
    }

    function handleUseUltimateSkill() {
        const skill = ULTIMATE_SKILLS[player.className];
        if (player.ultimateSkillCooldown > 0) return;
        
        updateQuestProgress('USE_ULTIMATE', 1);
        const effect = skill.effect(player.ultimateSkillLevel);
        
        addMessage(`‚ú® ${effect.message}`);
        
        const reduction = (player.rebirthUpgrades.ultimate_cooldown || 0) * 0.05;
        const finalCooldown = Math.ceil(skill.cooldown * (1 - reduction));
        player.ultimateSkillCooldown = finalCooldown;

        const applyDamage = (multiplier) => {
            let damage = player.attackPower * multiplier;

            if (player.className === 'ÎßàÎ≤ïÏÇ¨' && player.unlockedSkills['m_ult_1']) {
                damage *= (1 + player.unlockedSkills['m_ult_1'] * 0.1);
            }

            if (Math.random() < player.critChance) {
                damage = Math.floor(damage * (CRIT_MULTIPLIER + player.critDamage));
                addMessage(`üí• ÏπòÎ™ÖÌÉÄ! ${Math.floor(damage)}Ïùò ÌîºÌï¥!`);
            }
            monster.hp = Math.max(0, monster.hp - Math.floor(damage));
        };

        if (effect.damageMultiplier) {
            if (player.className === 'ÏïîÏÇ¥Ïûê') {
                applyDamage(effect.damageMultiplier);
                if (monster.hp > 0) {
                    applyDamage(effect.damageMultiplier);
                }
            } else {
                applyDamage(effect.damageMultiplier);
            }
        }

        if (effect.buff) {
            const finalBuff = JSON.parse(JSON.stringify(effect.buff)); // Deep copy to avoid mutation issues
            if (player.className === 'Í∂ÅÏàò' && player.unlockedSkills['a_ult_1']) {
                finalBuff.value += player.unlockedSkills['a_ult_1'] * 0.02;
            }
            player.activeBuffs.push({ skillId: skill.id, name: finalBuff.name || skill.name, duration: finalBuff.duration + 1, effect: finalBuff });
            recalculatePlayerStats();
        }
        
        if (effect.statusEffect && Math.random() < effect.statusEffect.chance) {
            applyStatusEffect(monster, { ...effect.statusEffect });
        }
    }
    
    function handleUseUltimateSkill2() {
        const skillId = ULTIMATE_SKILLS_2[player.className].id;
        const skill = ULTIMATE_SKILLS_2[player.className];
        const skillLevel = player.unlockedSkills[skillId] || 1;

        if (player.ultimateSkill2Cooldown > 0) return;
        
        updateQuestProgress('USE_ULTIMATE', 1);
        const effect = skill.effect(skillLevel);
        
        addMessage(`‚ú® ${effect.message}`);
        
        const reduction = (player.rebirthUpgrades.ultimate_cooldown || 0) * 0.05;
        const finalCooldown = Math.ceil(skill.cooldown * (1 - reduction));
        player.ultimateSkill2Cooldown = finalCooldown;

        if (effect.damageMultiplier) {
            const hits = effect.hits || 1;
            for (let i = 0; i < hits; i++) {
                if (monster.hp <= 0) break; // Stop if monster is defeated mid-attack
                let damage = player.attackPower * effect.damageMultiplier;
                if (Math.random() < player.critChance) {
                    damage = Math.floor(damage * (CRIT_MULTIPLIER + player.critDamage));
                    addMessage(`üí• ÏπòÎ™ÖÌÉÄ! ${Math.floor(damage)}Ïùò ÌîºÌï¥! (${i + 1}/${hits})`);
                }
                monster.hp = Math.max(0, monster.hp - Math.floor(damage));
            }
        }

        if (effect.buff) {
            player.activeBuffs.push({ skillId: skill.id, name: skill.name, duration: effect.buff.duration + 1, effect: effect.buff });
        }
        if (effect.buff2) {
             player.activeBuffs.push({ skillId: skill.id, ...effect.buff2, duration: effect.buff2.duration + 1 });
        }
        
        if (effect.statusEffect && Math.random() < effect.statusEffect.chance) {
            applyStatusEffect(monster, { ...effect.statusEffect });
        }

        recalculatePlayerStats();
    }

    function handleUsePotion() {
        if (player.potions <= 0) return;
        player.potions--;
        const healAmount = Math.floor(player.maxHp * POTION_HEAL_PERCENT);
        player.hp = Math.min(player.maxHp, player.hp + healAmount);
        addMessage(`üß™ Î¨ºÏïΩÏùÑ ÏÇ¨Ïö©Ìï¥ HPÎ•º ${healAmount}ÎßåÌÅº ÌöåÎ≥µÌñàÎã§!`);
        if (currentScreen === 'DUNGEON') {
            renderDungeonScreen();
        } else if (currentScreen === 'SURVIVAL') {
            renderSurvivalDungeonScreen();
        }
    }

    function monsterAttack() {
        if (Math.random() < player.evadeChance) {
            addMessage(`üçÉ ${player.name}Ïù¥(Í∞Ä) Í≥µÍ≤©ÏùÑ ÌöåÌîºÌñàÎã§!`);
            return;
        }
        
        let monsterDamage = Math.floor(monster.attackPower + (Math.random() * 4 - 2));
        if (Math.random() < 0.1) { 
            monsterDamage = Math.floor(monsterDamage * CRIT_MULTIPLIER);
            addMessage(`üí¢ ÏπòÎ™ÖÌÉÄ! ${monster.name}Ïù¥(Í∞Ä) ${monsterDamage}Ïùò Îç∞ÎØ∏ÏßÄÎ•º ÏûÖÌòîÎã§!`);
        }
        const finalDamage = Math.max(1, monsterDamage - player.defense);
        addMessage(`üõ°Ô∏è ${monster.name}Ïùò Í≥µÍ≤©! ${player.name}ÏùÄ(Îäî) ${finalDamage}Ïùò ÌîºÌï¥Î•º ÏûÖÏóàÎã§.`);
        player.hp = Math.max(0, player.hp - finalDamage);

        const baseMonsterData = (monster.name.startsWith('üëë') ? bossList : monsterList).find(m => monster.name.includes(m.name));
        if (baseMonsterData?.onHitEffect) {
            const effect = baseMonsterData.onHitEffect;
            if (Math.random() < effect.chance) {
                applyStatusEffect(player, { 
                    type: effect.type, 
                    duration: effect.duration, 
                    potency: effect.potency 
                });
            }
        }
    }

    function generateLoot(monsterData, isBoss) {
        // Legendary Drop
        if (isBoss && dungeonLevel >= 4) {
            const legendaryDropChance = 0.01 + (dungeonLevel - 4) * 0.005; // 1% at level 4, increasing
            if (Math.random() < legendaryDropChance) {
                const legendaryItems = ITEM_DATABASE.filter(i => i.rarity === 'legendary' && (i.type === 'weapon' || i.type === 'armor'));
                if (legendaryItems.length > 0) {
                    const droppedLegendary = legendaryItems[Math.floor(Math.random() * legendaryItems.length)];
                    return createItemInstance(droppedLegendary.id);
                }
            }
        }
    
        const dropChance = isBoss ? 0.5 : 0.15;
        if (Math.random() > dropChance) return null;

        const possibleLootIds = monsterData.lootTable.filter((id) => {
            const item = ITEM_DATABASE.find(i => i.id === id);
            if (!item) return false;
            return dungeonLevel >= (item.rarity === 'rare' ? 3 : (item.rarity === 'uncommon' ? 2 : 1));
        });

        if (possibleLootIds.length === 0) return null;

        const lootId = possibleLootIds[Math.floor(Math.random() * possibleLootIds.length)];
        return createItemInstance(lootId);
    }

    function monsterDefeated() {
        addMessage(`üéâ ${monster.name}ÏùÑ(Î•º) Î¨ºÎ¶¨Ï≥§Îã§!`);
        updateQuestProgress('KILL_MONSTERS', 1);

        const floors = getFloorsForDungeon(dungeonLevel);
        const isBossFloor = dungeonFloor === floors;
        const baseMonsterData = (isBossFloor ? bossList : monsterList).find(m => monster.name.includes(m.name));
        if (!baseMonsterData) return;
        
        if (isBossFloor) {
            updatePermanentQuestProgress('DEFEAT_BOSS', baseMonsterData.name);
        }
        
        const difficulty = DIFFICULTY_SETTINGS[currentDifficulty];
        const xpGainBonus = 1 + (player.rebirthUpgrades.xp_gain || 0) * 0.05;
        const goldGainBonus = 1 + (player.rebirthUpgrades.gold_gain || 0) * 0.05;

        const xpGained = Math.floor(baseMonsterData.xp * (1 + (dungeonLevel - 1) * 0.15) * difficulty.rewardMod * xpGainBonus);
        const goldGained = Math.floor((baseMonsterData.gold + Math.random() * baseMonsterData.gold * dungeonLevel) * difficulty.rewardMod * goldGainBonus);

        player.xp += xpGained;
        player.gold += goldGained;
        updateQuestProgress('EARN_GOLD', goldGained);
        updatePermanentQuestProgress('COLLECT_GOLD', goldGained);
        addMessage(`üåü Í≤ΩÌóòÏπò ${xpGained}ÏùÑ(Î•º) ÌöçÎìùÌñàÎã§!`);
        addMessage(`üí∞ Í≥®Îìú ${goldGained}ÏùÑ(Î•º) ÌöçÎìùÌñàÎã§!`);

        const droppedItem = generateLoot(baseMonsterData, isBossFloor);
        if (droppedItem) {
            if (canAddItem()) {
                player.inventory.push(droppedItem);
                addMessage(`üíé Ï†ÑÎ¶¨Ìíà ÌöçÎìù: <span class="rarity-${droppedItem.rarity}">${droppedItem.name}</span>!`);
            } else {
                addMessage(`‚ö†Ô∏è Ïù∏Î≤§ÌÜ†Î¶¨Í∞Ä Í∞ÄÎìù Ï∞® <span class="rarity-${droppedItem.rarity}">${droppedItem.name}</span>ÏùÑ(Î•º) ÌöçÎìùÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.`);
            }
        }
        
        while (player.xp >= player.xpToNextLevel) {
            player.xp -= player.xpToNextLevel; 
            levelUp();
        }

        saveGameState();

        if (isBossFloor) {
            renderDungeonClearScreen();
        } else {
            renderDungeonScreen(true); // Re-render with buttons disabled
            setTimeout(continueDungeon, 1200);
        }
    }

    function levelUp() {
        player.level++;
        player.xpToNextLevel = Math.floor(player.xpToNextLevel * (1.15 + (player.rebirths || 0) * 0.02));
        
        const goldReward = player.level * 20;
        const stonesReward = 1 + Math.floor(player.level / 3);
        let potionReward = 0;
        if (player.level % 3 === 0) {
            potionReward = 1;
        }
        player.gold += goldReward;
        player.enhancementStones += stonesReward;
        player.potions += potionReward;
        
        let rewardMessage = `üéÅ Î†àÎ≤®ÏóÖ Î≥¥ÏÉÅ: ${goldReward}G, üíé${stonesReward}Í∞ú`;
        if (potionReward > 0) {
            rewardMessage += `, üß™${potionReward}Í∞ú`;
        }
        rewardMessage += `Î•º ÌöçÎìùÌñàÎã§!`;
        
        addMessage(`‚ú® Î†àÎ≤®ÏóÖ! Î†àÎ≤® ${player.level}Ïù¥ ÎêòÏóàÎã§!`);
        addMessage(rewardMessage);

        updatePermanentQuestProgress('REACH_LEVEL', player.level);
        
        const previousMaxHp = player.maxHp;
        recalculatePlayerStats();
        const hpGain = player.maxHp - previousMaxHp;
        player.hp += hpGain;
        player.hp = Math.min(player.hp, player.maxHp);
        saveGameState();
    }

    function continueDungeon() {
        dungeonFloor++;
        messageLog = [`ÎçòÏ†Ñ ${dungeonLevel} - ${dungeonFloor}Ï∏µÏúºÎ°ú Ïù¥ÎèôÌñàÎã§.`];
        spawnMonster();
        renderDungeonScreen();
    }

    function renderDungeonClearScreen() {
        addMessage(`üèÜ ÎçòÏ†Ñ ${dungeonLevel} ÌÅ¥Î¶¨Ïñ¥! ÎßàÏùÑÎ°ú Í∑ÄÌôòÌï©ÎãàÎã§.`);
        updateQuestProgress('CLEAR_DUNGEON', 1);
        dungeonLevel++;
        saveGameState();

        root.innerHTML = `
            <div class="screen-container">
                <h1>ÎçòÏ†Ñ ÌÅ¥Î¶¨Ïñ¥!</h1>
                <p>Í∞ïÎ†•Ìïú Î≥¥Ïä§Î•º Î¨ºÎ¶¨Ï≥§ÏäµÎãàÎã§!</p>
                 <div id="action-buttons" class="town-actions">
                    <button id="return-town-button" class="button">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                </div>
            </div>
        `;
        document.getElementById('return-town-button')?.addEventListener('click', () => {
            player.hp = player.maxHp;
            player.statusEffects = [];
            player.activeBuffs = [];
            recalculatePlayerStats();
            renderTownScreen();
        });
    }

    function getCurrentPotionCost() {
        return POTION_COST;
    }

    function renderShopScreen() {
        currentScreen = 'SHOP';
        renderPermanentUI();
        const itemsForSale = ITEM_DATABASE.filter(item => (item.type === 'weapon' || item.type === 'armor' || item.type === 'accessory') && !item.isGachaOnly);
        
        const filteredItems = itemsForSale.filter(item => {
            const typeMatch = shopFilterType === 'all' || item.type === shopFilterType;
            const rarityMatch = shopFilterRarity === 'all' || item.rarity === shopFilterRarity;
            return typeMatch && rarityMatch;
        }).sort((a, b) => {
            const rarityOrder = { 'ultimate': 6, 'mythic': 5, 'legendary': 4, 'rare': 3, 'uncommon': 2, 'common': 1 };
            if ((rarityOrder[b.rarity] || 0) !== (rarityOrder[a.rarity] || 0)) {
                return (rarityOrder[b.rarity] || 0) - (rarityOrder[a.rarity] || 0);
            }
            return b.cost - a.cost;
        });

        const currentPotionCost = getCurrentPotionCost();

        const itemsHtml = filteredItems.map(item => `
            <div class="shop-item">
                <div>
                    <span class="rarity-${item.rarity}">${item.name}</span>
                    <span class="item-class">(${item.type === 'accessory' ? 'Ïû•Ïã†Íµ¨' : item.classRestriction.join(', ')})</span>
                </div>
                <button class="button buy-item-btn" data-item-id="${item.id}" ${player.gold < item.cost ? 'disabled' : ''}>${item.cost} G</button>
            </div>
        `).join('');
        
        const filtersHtml = `
            <div class="shop-filters">
                <div class="filter-group">
                    <button class="filter-btn ${shopFilterType === 'all' ? 'active' : ''}" data-filter-type="type" data-filter-value="all">Ï†ÑÏ≤¥</button>
                    <button class="filter-btn ${shopFilterType === 'weapon' ? 'active' : ''}" data-filter-type="type" data-filter-value="weapon">Î¨¥Í∏∞</button>
                    <button class="filter-btn ${shopFilterType === 'armor' ? 'active' : ''}" data-filter-type="type" data-filter-value="armor">Î∞©Ïñ¥Íµ¨</button>
                    <button class="filter-btn ${shopFilterType === 'accessory' ? 'active' : ''}" data-filter-type="type" data-filter-value="accessory">Ïû•Ïã†Íµ¨</button>
                </div>
                <div class="filter-group">
                    <button class="filter-btn ${shopFilterRarity === 'all' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="all">Ï†ÑÏ≤¥</button>
                    <button class="filter-btn ${shopFilterRarity === 'common' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="common">ÏùºÎ∞ò</button>
                    <button class="filter-btn ${shopFilterRarity === 'uncommon' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="uncommon">Í≥†Í∏â</button>
                    <button class="filter-btn ${shopFilterRarity === 'rare' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="rare">Ìù¨Í∑Ä</button>
                    <button class="filter-btn ${shopFilterRarity === 'legendary' ? 'active' : ''}" data-filter-type="rarity" data-filter-value="legendary">Ï†ÑÏÑ§</button>
                </div>
            </div>
        `;

        root.innerHTML = `
            <div class="screen-container shop-container">
                <h1>ÏÉÅÏ†ê</h1>
                 <div class="gold-sp-display top-display">
                    <p>üí∞ Gold: ${player.gold}</p>
                    <p>üíé Stones: ${player.enhancementStones}</p>
                    <p>‚ú® Dust: ${player.enchantmentDust || 0}</p>
                </div>
                ${filtersHtml}
                <div class="shop-items">
                    <div class="shop-item">
                        <span>üß™ ÌöåÎ≥µ Î¨ºÏïΩ Íµ¨Îß§</span>
                        <button class="button" id="buy-potion" ${player.gold < currentPotionCost ? 'disabled' : ''}>${currentPotionCost} G</button>
                    </div>
                    <div class="shop-item">
                        <span>üíé Í∞ïÌôîÏÑù 10Í∞ú Íµ¨Îß§</span>
                        <button class="button" id="buy-stones" ${player.gold < 500 ? 'disabled' : ''}>500 G</button>
                    </div>
                    ${itemsHtml}
                    ${filteredItems.length === 0 ? '<p>ÌëúÏãúÌï† ÏïÑÏù¥ÌÖúÏù¥ ÏóÜÏäµÎãàÎã§.</p>' : ''}
                </div>
                <button id="back-to-town" class="button">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
            </div>
        `;

        document.getElementById('buy-potion')?.addEventListener('click', () => {
            const cost = getCurrentPotionCost();
            if (player.gold >= cost) {
                player.gold -= cost;
                player.potions++;
                saveGameState();
                renderShopScreen();
            }
        });

        document.getElementById('buy-stones')?.addEventListener('click', () => {
            const cost = 500;
            const amount = 10;
            if (player.gold >= cost) {
                player.gold -= cost;
                player.enhancementStones += amount;
                saveGameState();
                renderShopScreen();
            }
        });

        document.querySelectorAll('.buy-item-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const itemId = parseInt(e.currentTarget.dataset.itemId || '0');
                const itemData = ITEM_DATABASE.find(i => i.id === itemId);
                if (itemData && player.gold >= itemData.cost) {
                    if (!canAddItem()) {
                        alert('Ïù∏Î≤§ÌÜ†Î¶¨Í∞Ä Í∞ÄÎìù Ï∞ºÏäµÎãàÎã§.');
                        return;
                    }
                    const item = createItemInstance(itemId);
                    player.gold -= itemData.cost;
                    player.inventory.push(item);
                    addMessage(`üõí ÏÉÅÏ†êÏóêÏÑú <span class="rarity-${item.rarity}">${item.name}</span>ÏùÑ(Î•º) Íµ¨Îß§ÌñàÎã§.`);
                    saveGameState();
                    renderShopScreen();
                }
            });
        });

        document.querySelectorAll('.filter-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.currentTarget;
                const filterType = target.dataset.filterType;
                const filterValue = target.dataset.filterValue;

                if (filterType === 'type') {
                    shopFilterType = filterValue;
                } else if (filterType === 'rarity') {
                    shopFilterRarity = filterValue;
                }
                renderShopScreen();
            });
        });

        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }

    function handlePlayerDefeat() {
        const goldLost = Math.floor(player.gold * DEFEAT_GOLD_PENALTY);
        player.gold -= goldLost;
        messageLog = [`Í≥®Îìú ${goldLost}Î•º ÏûÉÏóàÎã§...`, 'Ï†ïÏã†ÏùÑ Ï∞®Î†§Î≥¥Îãà ÎßàÏùÑÏù¥ÏóàÎã§.', `ÎçòÏ†Ñ ${dungeonFloor}Ï∏µÏóêÏÑú Ïì∞Îü¨Ï°åÎã§.`];
        
        player.activeBuffs = [];
        player.statusEffects = [];
        recalculatePlayerStats();
        player.hp = player.maxHp;
        saveGameState();
        renderTownScreen();
    }

    function renderEquipmentScreen() {
        currentScreen = 'EQUIPMENT';
        renderPermanentUI();

        const createItemCard = (item, slot, index) => {
            if (!item) {
                return `<div class="item-card empty" data-slot="${slot}">ÎπÑÏñ¥ÏûàÏùå</div>`;
            }
            const isRestricted = !item.classRestriction.includes(player.className);
            const statsHtml = Object.entries(item.stats).map(([stat, value]) => {
                let statName = '';
                switch(stat) {
                    case 'maxHp': statName = 'HP'; break;
                    case 'attackPower': statName = 'ATK'; break;
                    case 'defense': statName = 'DEF'; break;
                    case 'critChance': statName = 'ÏπòÎ™ÖÌÉÄ'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                    case 'evadeChance': statName = 'ÌöåÌîº'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                    case 'critDamage': statName = 'ÏπòÎ™ÖÌîºÌï¥'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                }
                return `${statName} +${value}`;
            }).join(', ');

            const enchantmentHtml = item.enchantment ? `<p class="item-enchantment">‚ú® ${item.enchantment.description}</p>` : '';
            const lockIconHtml = slot === 'inventory' ? `<div class="lock-icon" data-inventory-index="${index}">${item.isLocked ? 'üîí' : 'üîì'}</div>` : '';

            return `
                <div class="item-card rarity-${item.rarity} ${isRestricted ? 'restricted' : ''} ${item.isLocked ? 'locked' : ''}" data-slot="${slot}" data-item-id="${item.id}" ${index !== undefined ? `data-inventory-index="${index}"` : ''}>
                    <p class="item-name">${getItemDisplayName(item)}</p>
                    <p class="item-class">(${item.classRestriction.join(', ')})</p>
                    <p class="item-stats">${statsHtml}</p>
                    ${enchantmentHtml}
                    ${isRestricted ? `<div class="restricted-overlay">Ïû•Ï∞©Î∂àÍ∞Ä</div>` : ''}
                    ${lockIconHtml}
                </div>
            `;
        };

        const inventoryHtml = player.inventory.map((item, index) => createItemCard(item, 'inventory', index)).join('');
        const inventoryTitleClass = isInventoryFull() ? 'inventory-full' : '';

        root.innerHTML = `
            <div class="screen-container equipment-screen">
                <h1>Ïû•ÎπÑ</h1>
                <div class="gold-sp-display top-display">
                    <p>üí∞ Gold: ${player.gold}</p>
                    <p>üíé Stones: ${player.enhancementStones}</p>
                    <p>‚ú® Dust: ${player.enchantmentDust || 0}</p>
                </div>
                <div class="equipment-slots">
                    <div class="slot-container">
                        <h3>Î¨¥Í∏∞</h3>
                        ${createItemCard(player.equipment.weapon, 'weapon')}
                    </div>
                    <div class="slot-container">
                        <h3>Î∞©Ïñ¥Íµ¨</h3>
                        ${createItemCard(player.equipment.armor, 'armor')}
                    </div>
                    <div class="slot-container">
                        <h3>Ïû•Ïã†Íµ¨</h3>
                        ${createItemCard(player.equipment.accessory, 'accessory')}
                    </div>
                </div>
                <h2 class="${inventoryTitleClass}">Ïù∏Î≤§ÌÜ†Î¶¨ (${player.inventory.length} / ${INVENTORY_LIMIT})</h2>
                <div class="inventory-grid">
                    ${inventoryHtml || '<p>Ïù∏Î≤§ÌÜ†Î¶¨Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.</p>'}
                </div>
                <div class="equipment-screen-footer">
                    <button id="back-to-town-equip" class="button">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                </div>
            </div>
        `;
        
        document.querySelectorAll('.item-card').forEach(card => {
             card.addEventListener('click', handleItemClick);
        });
        
        document.querySelectorAll('.lock-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent item click from firing
                const indexStr = e.currentTarget.dataset.inventoryIndex;
                if (indexStr === undefined) return;
                const index = parseInt(indexStr);
                const item = player.inventory[index];
                if (item) {
                    item.isLocked = !item.isLocked;
                    saveGameState();
                    renderEquipmentScreen();
                }
            });
        });

        document.getElementById('back-to-town-equip')?.addEventListener('click', () => {
            renderTownScreen();
        });
    }

    function handleItemClick(event) {
        const card = event.currentTarget;
        const slot = card.dataset.slot;
        const inventoryIndexStr = card.dataset.inventoryIndex;

        if (slot === 'inventory') {
            const index = parseInt(inventoryIndexStr || '0');
            const item = player.inventory[index];
            if (item) equipItem(item, index);
        } else if (slot) {
            unequipItem(slot);
        }
    }

    function equipItem(item, inventoryIndex) {
        if (item.classRestriction && !item.classRestriction.includes(player.className)) {
            alert("Ïù¥ ÏßÅÏóÖÏùÄ Ï∞©Ïö©Ìï† Ïàò ÏóÜÎäî Ïû•ÎπÑÏûÖÎãàÎã§.");
            return;
        }
        if (!canAddItem(0)) { // Special case for swapping, check if inventory is exactly full
             if (player.equipment[item.type]) {
                // This is a swap, so inventory size doesn't change. Allow it.
            } else if (isInventoryFull()) {
                 alert("Ïù∏Î≤§ÌÜ†Î¶¨Í∞Ä Í∞ÄÎìù Ï∞®ÏÑú Ïû•Ï∞© Ìï¥Ï†úÌï† ÏïÑÏù¥ÌÖúÏùÑ Î≥¥Í¥ÄÌï† Ïàò ÏóÜÏäµÎãàÎã§. ÏïÑÏù¥ÌÖúÏùÑ Ïû•Ï∞©ÌïòÎ†§Î©¥ Î®ºÏ†Ä Í≥µÍ∞ÑÏùÑ ÌôïÎ≥¥ÌïòÏÑ∏Ïöî.");
                 return;
            }
        }

        const currentItem = player.equipment[item.type];
        if (currentItem) {
            player.inventory.push(currentItem);
        }
        player.equipment[item.type] = item;
        player.inventory.splice(inventoryIndex, 1);
        
        const previousMaxHp = player.maxHp;
        recalculatePlayerStats();
        const hpGain = player.maxHp - previousMaxHp;
        player.hp += hpGain;
        player.hp = Math.min(player.hp, player.maxHp);
        
        saveGameState();
        renderEquipmentScreen();
    }

    function unequipItem(slot) {
        const item = player.equipment[slot];
        if (item) {
            if (!canAddItem()) {
                alert("Ïù∏Î≤§ÌÜ†Î¶¨Í∞Ä Í∞ÄÎìù Ï∞®ÏÑú Ïû•ÎπÑÎ•º Ìï¥Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
                return;
            }
            player.inventory.push(item);
            player.equipment[slot] = null;
            
            const previousMaxHp = player.maxHp;
            recalculatePlayerStats();
            const hpLoss = previousMaxHp - player.maxHp;
            player.hp -= hpLoss;
            if(player.hp > player.maxHp) player.hp = player.maxHp;
            if(player.hp <= 0) player.hp = 1;

            saveGameState();
            renderEquipmentScreen();
        }
    }

    function applyStatusEffect(target, newEffect) {
        const existingEffect = target.statusEffects.find(se => se.type === newEffect.type);
        if (existingEffect) {
            existingEffect.duration = Math.max(existingEffect.duration, newEffect.duration);
            existingEffect.potency = Math.max(existingEffect.potency, newEffect.potency);
        } else {
            target.statusEffects.push(newEffect);
        }
        const def = STATUS_EFFECT_DEFINITIONS[newEffect.type];
        addMessage(`${def.icon} ${target.name}Ïù¥(Í∞Ä) [${def.name}] Ìö®Í≥ºÎ•º Î∞õÏïòÎã§!`);
    }

    function processStatusEffects(character) {
        let isStunned = false;
        let totalDamage = 0;

        character.statusEffects = character.statusEffects.filter(se => {
            const def = STATUS_EFFECT_DEFINITIONS[se.type];
            if (se.type === 'stun') {
                isStunned = true;
            }
            if (se.type === 'poison') {
                let poisonDamage = se.potency;
                totalDamage += poisonDamage;
                addMessage(`${def.icon} [${def.name}] Ìö®Í≥ºÎ°ú ${character.name}Ïù¥(Í∞Ä) ${poisonDamage}Ïùò ÌîºÌï¥Î•º ÏûÖÏóàÎã§!`);
            }
            if (se.type === 'burn') {
                let burnDamage = se.potency;
                 if (character === monster && player.unlockedSkills['m_burn_1']) {
                    burnDamage *= (1 + player.unlockedSkills['m_burn_1'] * 0.1);
                }
                totalDamage += burnDamage;
                addMessage(`${def.icon} [${def.name}] Ìö®Í≥ºÎ°ú ${character.name}Ïù¥(Í∞Ä) ${Math.floor(burnDamage)}Ïùò ÌîºÌï¥Î•º ÏûÖÏóàÎã§!`);
            }
            
            se.duration--;
            return se.duration > 0;
        });

        if (totalDamage > 0) {
            character.hp = Math.max(0, character.hp - totalDamage);
        }
        
        recalculatePlayerStats(); 
        return isStunned;
    }

    function getEnhancementCost(item) {
        let rarityMultiplier = 1;
        if (item.rarity === 'uncommon') rarityMultiplier = 1.5;
        if (item.rarity === 'rare') rarityMultiplier = 2.5;
        if (item.rarity === 'legendary') rarityMultiplier = 5;
        if (item.rarity === 'mythic') rarityMultiplier = 10;
        return Math.floor(50 * Math.pow(1.4, item.enhancementLevel) * rarityMultiplier);
    }

    function getEnhancementStoneCost(item) {
        let rarityMultiplier = 1;
        if (item.rarity === 'uncommon') rarityMultiplier = 2;
        if (item.rarity === 'rare') rarityMultiplier = 3;
        if (item.rarity === 'legendary') rarityMultiplier = 5;
        if (item.rarity === 'mythic') rarityMultiplier = 10;
        return Math.ceil( (2 + item.enhancementLevel) * rarityMultiplier / 2);
    }

    function getSuccessChance(level) {
        if (level < 3) return 1.0;
        if (level < 5) return 0.9;
        if (level < 7) return 0.7;
        if (level < 9) return 0.5;
        if (level < 12) return 0.3;
        return 0.15;
    }

    function getStatIncrease(item) {
        let rarityMultiplier = 1;
        if (item.rarity === 'uncommon') rarityMultiplier = 1.2;
        if (item.rarity === 'rare') rarityMultiplier = 1.5;
        if (item.rarity === 'legendary') rarityMultiplier = 2.5;
        if (item.rarity === 'mythic') rarityMultiplier = 4;
        if (item.type === 'weapon') {
            return { attackPower: Math.ceil(2 * rarityMultiplier) };
        } else if (item.type === 'armor') {
            return { defense: Math.ceil(1 * rarityMultiplier), maxHp: Math.ceil(5 * rarityMultiplier) };
        } else if (item.type === 'accessory') {
            const increases = {};
            if (item.stats.attackPower) increases.attackPower = Math.ceil(1 * rarityMultiplier);
            if (item.stats.maxHp) increases.maxHp = Math.ceil(10 * rarityMultiplier);
            if (item.stats.defense) increases.defense = Math.ceil(1 * rarityMultiplier);
            return increases;
        }
        return {};
    }

    function renderBlacksmithScreen() {
        currentScreen = 'BLACKSMITH';
        renderPermanentUI();
        synthesisSelection = synthesisSelection.filter(sel => sel && player.inventory[sel.inventoryIndex]);
        while (synthesisSelection.length < 2) synthesisSelection.push(null);


        const renderEnhanceContent = () => {
            return `
                <div class="enhancement-slots">
                    <div class="enhancement-slot" data-slot="weapon">
                        <h3>Î¨¥Í∏∞</h3>
                        ${player.equipment.weapon ? createItemCardForBlacksmith(player.equipment.weapon) : '<div class="item-card empty">ÏóÜÏùå</div>'}
                    </div>
                    <div class="enhancement-slot" data-slot="armor">
                        <h3>Î∞©Ïñ¥Íµ¨</h3>
                        ${player.equipment.armor ? createItemCardForBlacksmith(player.equipment.armor) : '<div class="item-card empty">ÏóÜÏùå</div>'}
                    </div>
                     <div class="enhancement-slot" data-slot="accessory">
                        <h3>Ïû•Ïã†Íµ¨</h3>
                        ${player.equipment.accessory ? createItemCardForBlacksmith(player.equipment.accessory) : '<div class="item-card empty">ÏóÜÏùå</div>'}
                    </div>
                </div>
                <div id="enhancement-details">
                    <p>Í∞ïÌôîÌï† Ïû•ÎπÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
                </div>
            `;
        };

        const renderDisenchantContent = () => {
            const inventoryHtml = player.inventory.map((item, index) => createItemCardForDisenchant(item, index)).join('');
            const inventoryTitleClass = isInventoryFull() ? 'inventory-full' : '';
            return `
                <h2 class="${inventoryTitleClass}">Î∂ÑÌï¥Ìï† ÏïÑÏù¥ÌÖú ÏÑ†ÌÉù (${player.inventory.length} / ${INVENTORY_LIMIT})</h2>
                <div class="inventory-grid disenchant-mode">
                    ${inventoryHtml || '<p>Ïù∏Î≤§ÌÜ†Î¶¨Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.</p>'}
                </div>
            `;
        };

        const renderEnchantContent = () => {
            return `
                <div class="enhancement-slots">
                    <div class="enhancement-slot" data-slot="weapon">
                        <h3>Î¨¥Í∏∞</h3>
                        ${player.equipment.weapon ? createItemCardForBlacksmith(player.equipment.weapon) : '<div class="item-card empty">ÏóÜÏùå</div>'}
                    </div>
                    <div class="enhancement-slot" data-slot="armor">
                        <h3>Î∞©Ïñ¥Íµ¨</h3>
                        ${player.equipment.armor ? createItemCardForBlacksmith(player.equipment.armor) : '<div class="item-card empty">ÏóÜÏùå</div>'}
                    </div>
                    <div class="enhancement-slot" data-slot="accessory">
                        <h3>Ïû•Ïã†Íµ¨</h3>
                        ${player.equipment.accessory ? createItemCardForBlacksmith(player.equipment.accessory) : '<div class="item-card empty">ÏóÜÏùå</div>'}
                    </div>
                </div>
                <div id="enhancement-details">
                    <p>ÎßàÎ≤ï Î∂ÄÏó¨Ìï† Ïû•ÎπÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
                </div>
            `;
        }

        root.innerHTML = `
            <div class="screen-container blacksmith-screen">
                <h1>ÎåÄÏû•Í∞Ñ</h1>
                <div class="gold-sp-display top-display">
                    <p>üí∞ Gold: ${player.gold}</p>
                    <p>üíé Stones: ${player.enhancementStones}</p>
                    <p>‚ú® Dust: ${player.enchantmentDust || 0}</p>
                </div>
                <div class="blacksmith-tabs">
                    <button id="tab-enhance" class="tab-button ${blacksmithMode === 'enhance' ? 'active' : ''}">Í∞ïÌôî</button>
                    <button id="tab-disenchant" class="tab-button ${blacksmithMode === 'disenchant' ? 'active' : ''}">Î∂ÑÌï¥</button>
                    <button id="tab-batch-disenchant" class="tab-button ${blacksmithMode === 'batch-disenchant' ? 'active' : ''}">ÏùºÍ¥Ñ Î∂ÑÌï¥</button>
                    <button id="tab-synthesis" class="tab-button ${blacksmithMode === 'synthesis' ? 'active' : ''}">Ìï©ÏÑ±</button>
                    <button id="tab-enchant" class="tab-button ${blacksmithMode === 'enchant' ? 'active' : ''}">ÎßàÎ≤ï Î∂ÄÏó¨</button>
                </div>
                <div id="blacksmith-content">
                    ${blacksmithMode === 'enhance' ? renderEnhanceContent() : (blacksmithMode === 'disenchant' ? renderDisenchantContent() : (blacksmithMode === 'batch-disenchant' ? renderBatchDisenchantContent() : (blacksmithMode === 'synthesis' ? renderSynthesisContent() : renderEnchantContent())))}
                </div>
                <button id="back-to-town" class="button">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
            </div>
        `;

        document.getElementById('tab-enhance')?.addEventListener('click', () => { blacksmithMode = 'enhance'; renderBlacksmithScreen(); });
        document.getElementById('tab-disenchant')?.addEventListener('click', () => { blacksmithMode = 'disenchant'; renderBlacksmithScreen(); });
        document.getElementById('tab-batch-disenchant')?.addEventListener('click', () => { blacksmithMode = 'batch-disenchant'; renderBlacksmithScreen(); });
        document.getElementById('tab-synthesis')?.addEventListener('click', () => { blacksmithMode = 'synthesis'; synthesisSelection = [null, null]; renderBlacksmithScreen(); });
        document.getElementById('tab-enchant')?.addEventListener('click', () => { blacksmithMode = 'enchant'; renderBlacksmithScreen(); });

        if (blacksmithMode === 'enhance' || blacksmithMode === 'enchant') {
            document.querySelectorAll('.enhancement-slot').forEach(slot => {
                slot.addEventListener('click', () => {
                    const slotType = slot.getAttribute('data-slot');
                    if (blacksmithMode === 'enhance') {
                        renderEnhancementDetails(slotType);
                    } else {
                        renderEnchantDetails(slotType);
                    }
                });
            });
        } else if (blacksmithMode === 'disenchant') {
            document.querySelectorAll('.item-card.disenchantable').forEach(card => {
                card.addEventListener('click', handleDisenchantItemClick);
            });
        } else if (blacksmithMode === 'batch-disenchant') {
            document.querySelectorAll('.filter-checkbox-group input').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const rarity = e.target.dataset.rarity;
                    batchDisenchantFilters[rarity] = e.target.checked;
                    renderBlacksmithScreen();
                });
            });
             document.getElementById('batch-disenchant-button')?.addEventListener('click', handleBatchDisenchant);
        } else if (blacksmithMode === 'synthesis') {
            document.querySelectorAll('.inventory-grid.synthesis-mode .item-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    const index = parseInt(e.currentTarget.dataset.inventoryIndex);
                    handleSynthesisItemSelect(index);
                });
            });
            document.getElementById('synthesize-button')?.addEventListener('click', handleSynthesize);
        }


        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }

    function renderSynthesisContent() {
        const recipe = findRecipeForSelection();
        const resultItemData = recipe ? ITEM_DATABASE.find(i => i.id === recipe.resultItemId) : null;
        let canCraft = false;
        let costHtml = '<p>Ïû¨Î£åÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>';

        if (recipe && resultItemData) {
            let hasMaterials = true;
            costHtml = recipe.ingredients.filter(ing => ing.type === 'material').map(ing => {
                const name = ing.id === 'enhancementStones' ? 'Í∞ïÌôîÏÑù' : 'ÎßàÎ≤ï Î∂ÄÏó¨ Í∞ÄÎ£®';
                const currentAmount = player[ing.id];
                const hasEnough = currentAmount >= ing.count;
                if (!hasEnough) hasMaterials = false;
                return `<p class="${hasEnough ? 'has-enough' : 'not-enough'}">${name}: ${ing.count}</p>`;
            }).join('');
            if (hasMaterials) canCraft = true;
        }

        const inventoryTitleClass = isInventoryFull() ? 'inventory-full' : '';
        const inventoryHtml = player.inventory.map((item, index) => {
            const isSelected = synthesisSelection.some(sel => sel && sel.inventoryIndex === index);
            const isSynthesizable = item.enhancementLevel === 0 && !item.enchantment && !item.isLocked && SYNTHESIS_RECIPES.some(r => r.ingredients.some(i => i.type === 'item' && i.id === item.id));
            
            const itemClass = `item-card rarity-${item.rarity} ${isSelected ? 'selected' : ''} ${!isSynthesizable ? 'unselectable' : ''}`;

            return `<div class="${itemClass}" data-inventory-index="${index}">
                <p class="item-name">${getItemDisplayName(item)}</p>
            </div>`;
        }).join('');

        return `
            <div class="synthesis-container">
                <div class="synthesis-main">
                    <div class="synthesis-slots">
                        <div class="synthesis-slot">${synthesisSelection[0] ? createItemCardForBlacksmith(synthesisSelection[0].item) : '<div class="item-card empty">Ïû¨Î£å 1</div>'}</div>
                        <span class="synthesis-symbol">+</span>
                        <div class="synthesis-slot">${synthesisSelection[1] ? createItemCardForBlacksmith(synthesisSelection[1].item) : '<div class="item-card empty">Ïû¨Î£å 2</div>'}</div>
                    </div>
                    <span class="synthesis-symbol">‚Üí</span>
                    <div class="synthesis-result-area">
                        ${resultItemData ? createItemCardForBlacksmith(resultItemData) : '<div class="item-card empty">Í≤∞Í≥º</div>'}
                        <div class="cost-display">${costHtml}</div>
                        <button id="synthesize-button" class="button" ${!canCraft ? 'disabled' : ''}>Ìï©ÏÑ±</button>
                    </div>
                </div>
                <h2 class="${inventoryTitleClass}">Ïû¨Î£å ÏÑ†ÌÉù (${player.inventory.length} / ${INVENTORY_LIMIT})</h2>
                <div class="inventory-grid synthesis-mode">
                    ${inventoryHtml || '<p>Ïù∏Î≤§ÌÜ†Î¶¨Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.</p>'}
                </div>
            </div>
        `;
    }
    
    function findRecipeForSelection() {
        if (!synthesisSelection[0] || !synthesisSelection[1]) return null;
        if (synthesisSelection[0].item.id !== synthesisSelection[1].item.id) return null;

        const itemId = synthesisSelection[0].item.id;
        return SYNTHESIS_RECIPES.find(recipe => {
            const itemIngredient = recipe.ingredients.find(ing => ing.type === 'item');
            return itemIngredient && itemIngredient.id === itemId && itemIngredient.count === 2;
        });
    }

    function handleSynthesisItemSelect(inventoryIndex) {
        const item = player.inventory[inventoryIndex];
        if (!item) return;

        const isSynthesizable = item.enhancementLevel === 0 && !item.enchantment && !item.isLocked;
        if (!isSynthesizable) {
            alert("Í∞ïÌôî, ÎßàÎ≤ï Î∂ÄÏó¨, ÎòêÎäî Ïû†Í∏à ÏÉÅÌÉúÏùò Ïû•ÎπÑÎäî Ìï©ÏÑ± Ïû¨Î£åÎ°ú ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }
        
        const selectionIndex = synthesisSelection.findIndex(sel => sel && sel.inventoryIndex === inventoryIndex);

        if (selectionIndex > -1) {
            synthesisSelection[selectionIndex] = null;
        } else {
            const emptySlotIndex = synthesisSelection.indexOf(null);
            if (emptySlotIndex > -1) {
                synthesisSelection[emptySlotIndex] = { item: item, inventoryIndex: inventoryIndex };
            } else {
                alert("Ïû¨Î£å Ïä¨Î°ØÏù¥ Í∞ÄÎìù Ï∞ºÏäµÎãàÎã§. Í∏∞Ï°¥ Ïû¨Î£åÎ•º ÏÑ†ÌÉù Ìï¥Ï†úÌïú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.");
            }
        }
        renderBlacksmithScreen();
    }

    function handleSynthesize() {
        const recipe = findRecipeForSelection();
        if (!recipe) {
            alert("Ïú†Ìö®Ìïú Ï°∞Ìï©Ïù¥ ÏïÑÎãôÎãàÎã§.");
            return;
        }
        if (!canAddItem(-1)) { // Consuming 2, adding 1 -> net change is -1.
            alert("Ïù∏Î≤§ÌÜ†Î¶¨Ïóê Í≥µÍ∞ÑÏù¥ Î∂ÄÏ°±ÌïòÏó¨ Ìï©ÏÑ±ÏùÑ ÏßÑÌñâÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }

        let canCraft = true;
        recipe.ingredients.forEach(ing => {
            if (ing.type === 'material' && player[ing.id] < ing.count) {
                canCraft = false;
            }
        });

        if (!canCraft) {
            alert("Ïû¨Î£åÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
            renderBlacksmithScreen();
            return;
        }

        // Consume materials
        recipe.ingredients.forEach(ing => {
            if (ing.type === 'material') player[ing.id] -= ing.count;
        });

        // Consume items
        const indicesToRemove = [synthesisSelection[0].inventoryIndex, synthesisSelection[1].inventoryIndex].sort((a, b) => b - a);
        indicesToRemove.forEach(index => player.inventory.splice(index, 1));
        
        // Add result item
        const resultItem = createItemInstance(recipe.resultItemId);
        player.inventory.push(resultItem);

        alert(`‚ú® ${resultItem.name} Ìï©ÏÑ±Ïóê ÏÑ±Í≥µÌñàÏäµÎãàÎã§!`);
        synthesisSelection = [null, null];
        saveGameState();
        renderBlacksmithScreen();
    }


    function createItemCardForBlacksmith(item) {
        const statsHtml = Object.entries(item.stats).map(([stat, value]) => {
            let statName = '';
            switch(stat) {
                case 'maxHp': statName = 'HP'; break;
                case 'attackPower': statName = 'ATK'; break;
                case 'defense': statName = 'DEF'; break;
                case 'critChance': statName = 'ÏπòÎ™ÖÌÉÄ'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                case 'evadeChance': statName = 'ÌöåÌîº'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
                case 'critDamage': statName = 'ÏπòÎ™ÖÌîºÌï¥'; value = value * 100; return `${statName} +${value.toFixed(0)}%`;
            }
            return `${statName} +${value}`;
        }).join(', ');

        const enchantmentHtml = item.enchantment ? `<p class="item-enchantment">‚ú® ${item.enchantment.description}</p>` : '';

        return `
            <div class="item-card rarity-${item.rarity}">
                <p class="item-name">${getItemDisplayName(item)}</p>
                <p class="item-class">(${item.classRestriction ? item.classRestriction.join(', ') : 'Î™®Îì† ÏßÅÏóÖ'})</p>
                <p class="item-stats">${statsHtml}</p>
                ${enchantmentHtml}
            </div>
        `;
    }

    function renderEnhancementDetails(slot) {
        const detailsContainer = document.getElementById('enhancement-details');
        if (!detailsContainer) return;
        
        const item = player.equipment[slot];
        if (!item) {
            detailsContainer.innerHTML = `<p>Í∞ïÌôîÌï† Ïû•ÎπÑÍ∞Ä ÏóÜÏäµÎãàÎã§.</p>`;
            return;
        }

        const goldCost = getEnhancementCost(item);
        const stoneCost = getEnhancementStoneCost(item);
        const successChance = getSuccessChance(item.enhancementLevel);
        const statIncrease = getStatIncrease(item);

        const nextStatsHtml = Object.entries(statIncrease).map(([stat, value]) => {
            let statName = '';
            switch(stat) {
                case 'maxHp': statName = 'ÏµúÎåÄ HP'; break;
                case 'attackPower': statName = 'Í≥µÍ≤©Î†•'; break;
                case 'defense': statName = 'Î∞©Ïñ¥Î†•'; break;
            }
            return `<span>${statName} +${value}</span>`;
        }).join('');

        const penaltyInfo = item.enhancementLevel >= 5
            ? `<p class="penalty-info">Ïã§Ìå® Ïãú 30% ÌôïÎ•†Î°ú Í∞ïÌôî Îã®Í≥ÑÍ∞Ä ÌïòÎùΩÌï©ÎãàÎã§. ÌïòÎùΩÌïòÏßÄ ÏïäÏúºÎ©¥ ÎπÑÏö©Ïùò 50%Î•º ÎèåÎ†§Î∞õÏäµÎãàÎã§.</p>`
            : `<p class="penalty-info">Ïã§Ìå® Ïãú Í∞ïÌôî ÎπÑÏö©Îßå ÏÜåÎ™®Îê©ÎãàÎã§.</p>`;

        detailsContainer.innerHTML = `
            <h3>${getItemDisplayName(item)} ‚Üí +${item.enhancementLevel + 1}</h3>
            <div class="enhancement-info">
                <div class="info-row">
                    <span>Îã§Ïùå Î†àÎ≤® Ìö®Í≥º:</span>
                    <div class="next-stats">${nextStatsHtml}</div>
                </div>
                <div class="info-row">
                    <span>Í∞ïÌôî ÎπÑÏö©:</span>
                    <span class="cost-display">${goldCost} G / ${stoneCost} üíé</span>
                </div>
                <div class="info-row">
                    <span>ÏÑ±Í≥µ ÌôïÎ•†:</span>
                    <span>${(successChance * 100).toFixed(0)}%</span>
                </div>
            </div>
            ${penaltyInfo}
            <button id="enhance-button" class="button" ${player.gold < goldCost || player.enhancementStones < stoneCost ? 'disabled' : ''}>Í∞ïÌôî</button>
        `;

        document.getElementById('enhance-button')?.addEventListener('click', () => handleEnhance(slot));
    }

    function handleEnhance(slot) {
        const item = player.equipment[slot];
        if (!item) return;

        const goldCost = getEnhancementCost(item);
        const stoneCost = getEnhancementStoneCost(item);
        if (player.gold < goldCost || player.enhancementStones < stoneCost) return;

        player.gold -= goldCost;
        player.enhancementStones -= stoneCost;
        updateQuestProgress('ENHANCE_ATTEMPTS', 1);

        const successChance = getSuccessChance(item.enhancementLevel);

        if (Math.random() < successChance) {
            item.enhancementLevel++;
            updatePermanentQuestProgress('ENHANCE_SUCCESS', item.enhancementLevel);
            const statIncrease = getStatIncrease(item);
            Object.entries(statIncrease).forEach(([stat, value]) => {
                const key = stat;
                if (item.stats[key] !== undefined) {
                    item.stats[key] += value;
                } else {
                    item.stats[key] = value;
                }
            });
            alert('‚ú® Í∞ïÌôî ÏÑ±Í≥µ!');
        } else {
            if (item.enhancementLevel >= 5 && Math.random() < 0.3) {
                const statIncrease = getStatIncrease({ ...item, enhancementLevel: item.enhancementLevel - 1});
                 Object.entries(statIncrease).forEach(([stat, value]) => {
                    const key = stat;
                    if (item.stats[key]) {
                        item.stats[key] -= value;
                    }
                });
                item.enhancementLevel--;
                alert('üìâ Í∞ïÌôî Ïã§Ìå®... Í∞ïÌôî Îã®Í≥ÑÍ∞Ä ÌïòÎùΩÌñàÏäµÎãàÎã§.');
            } else if (item.enhancementLevel >= 5) {
                const refund = Math.floor(goldCost / 2);
                player.gold += refund;
                alert(`üî• Í∞ïÌôî Ïã§Ìå®... ÌïòÏßÄÎßå ÎπÑÏö©Ïùò 50% (${refund}G)Î•º ÎèåÎ†§Î∞õÏïòÏäµÎãàÎã§.`);
            } else {
                alert('üî• Í∞ïÌôî Ïã§Ìå®...');
            }
        }
        
        const previousMaxHp = player.maxHp;
        recalculatePlayerStats();
        const hpChange = player.maxHp - previousMaxHp;
        player.hp += hpChange;
        player.hp = Math.min(player.hp, player.maxHp);
        if (player.hp <= 0) player.hp = 1;

        saveGameState();
        renderBlacksmithScreen();
        renderEnhancementDetails(slot);
    }

    function getDisenchantYield(item) {
        let rarityBonusStones = 1, rarityBonusDust = 1;
        if (item.rarity === 'uncommon') {
            rarityBonusStones = 3;
            rarityBonusDust = 5;
        } else if (item.rarity === 'rare') {
            rarityBonusStones = 7;
            rarityBonusDust = 15;
        } else if (item.rarity === 'legendary') {
            rarityBonusStones = 20;
            rarityBonusDust = 50;
        } else if (item.rarity === 'mythic') {
            rarityBonusStones = 50;
            rarityBonusDust = 150;
        }
        
        const enhancementBonus = Math.floor(item.enhancementLevel * rarityBonusStones * 0.5);
        
        return {
            stones: rarityBonusStones + enhancementBonus,
            dust: rarityBonusDust
        };
    }
    
    function createItemCardForDisenchant(item, index) {
        if (!item) return '';

        const itemYield = getDisenchantYield(item);
        const disenchantOverlayHtml = `<div class="disenchant-overlay">üíé${itemYield.stones} / ‚ú®${itemYield.dust}</div>`;
        const lockIconHtml = `<div class="lock-icon" data-inventory-index="${index}">${item.isLocked ? 'üîí' : 'üîì'}</div>`;

        return `
            <div class="item-card rarity-${item.rarity} disenchantable ${item.isLocked ? 'locked' : ''}" data-inventory-index="${index}">
                <p class="item-name">${getItemDisplayName(item)}</p>
                <p class="item-stats">Î∂ÑÌï¥ Í≤∞Í≥º</p>
                ${disenchantOverlayHtml}
                ${lockIconHtml}
            </div>
        `;
    }

    function handleDisenchantItemClick(event) {
        const card = event.currentTarget;
        const indexStr = card.dataset.inventoryIndex;
        if (indexStr === undefined) return;
        
        const index = parseInt(indexStr);
        const item = player.inventory[index];
        if (!item) return;
        if (item.isLocked) {
            alert("Ïû†Í∏¥ ÏïÑÏù¥ÌÖúÏùÄ Î∂ÑÌï¥Ìï† Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }

        const itemYield = getDisenchantYield(item);
        if (confirm(`'${getItemDisplayName(item)}'ÏùÑ(Î•º) Î∂ÑÌï¥ÌïòÏó¨ Í∞ïÌôîÏÑù ${itemYield.stones}Í∞úÏôÄ ÎßàÎ≤ï Î∂ÄÏó¨ Í∞ÄÎ£® ${itemYield.dust}Í∞úÎ•º ÏñªÏúºÏãúÍ≤†ÏäµÎãàÍπå?`)) {
            player.enhancementStones += itemYield.stones;
            player.enchantmentDust += itemYield.dust;
            player.inventory.splice(index, 1);
            saveGameState();
            renderBlacksmithScreen();
        }
    }

    function renderBatchDisenchantContent() {
        const getSummary = () => {
            let stones = 0;
            let dust = 0;
            let count = 0;
            player.inventory.forEach(item => {
                if (!item.isLocked && batchDisenchantFilters[item.rarity]) {
                    const itemYield = getDisenchantYield(item);
                    stones += itemYield.stones;
                    dust += itemYield.dust;
                    count++;
                }
            });
            return { stones, dust, count };
        };

        const summary = getSummary();

        return `
            <div class="batch-disenchant-container">
                <div class="batch-disenchant-filters">
                    <h3>Î∂ÑÌï¥Ìï† ÏïÑÏù¥ÌÖú Îì±Í∏â ÏÑ†ÌÉù</h3>
                    <div class="filter-checkbox-group">
                        <label>
                            <input type="checkbox" data-rarity="common" ${batchDisenchantFilters.common ? 'checked' : ''}>
                            <span class="rarity-common">ÏùºÎ∞ò</span>
                        </label>
                        <label>
                            <input type="checkbox" data-rarity="uncommon" ${batchDisenchantFilters.uncommon ? 'checked' : ''}>
                            <span class="rarity-uncommon">Í≥†Í∏â</span>
                        </label>
                        <label>
                            <input type="checkbox" data-rarity="rare" ${batchDisenchantFilters.rare ? 'checked' : ''}>
                            <span class="rarity-rare">Ìù¨Í∑Ä</span>
                        </label>
                    </div>
                </div>
                <div class="batch-disenchant-summary">
                    <h3>Î∂ÑÌï¥ Í≤∞Í≥º ÎØ∏Î¶¨Î≥¥Í∏∞</h3>
                    <p>ÏÑ†ÌÉùÎêú ÏïÑÏù¥ÌÖú: <strong>${summary.count}</strong>Í∞ú</p>
                    <p>ÏòàÏÉÅ Í∞ïÌôîÏÑù: <strong>${summary.stones}</strong>Í∞ú</p>
                    <p>ÏòàÏÉÅ ÎßàÎ≤ï Î∂ÄÏó¨ Í∞ÄÎ£®: <strong>${summary.dust}</strong>Í∞ú</p>
                </div>
                <button id="batch-disenchant-button" class="button" ${summary.count === 0 ? 'disabled' : ''}>ÏùºÍ¥Ñ Î∂ÑÌï¥</button>
            </div>
        `;
    }

    function handleBatchDisenchant() {
        const itemsToDisenchant = player.inventory.filter(item => {
            return !item.isLocked && batchDisenchantFilters[item.rarity];
        });

        if (itemsToDisenchant.length === 0) {
            alert("ÏÑ†ÌÉùÎêú Îì±Í∏âÏùò Î∂ÑÌï¥Ìï† ÏïÑÏù¥ÌÖúÏù¥ ÏóÜÏäµÎãàÎã§.");
            return;
        }

        let totalStonesYield = 0;
        let totalDustYield = 0;
        
        for (const item of itemsToDisenchant) {
            const itemYield = getDisenchantYield(item);
            totalStonesYield += itemYield.stones;
            totalDustYield += itemYield.dust;
        }

        if (!confirm(`${itemsToDisenchant.length}Í∞úÏùò ÏïÑÏù¥ÌÖúÏùÑ Î∂ÑÌï¥ÌïòÏó¨ Í∞ïÌôîÏÑù ${totalStonesYield}Í∞ú, ÎßàÎ≤ï Î∂ÄÏó¨ Í∞ÄÎ£® ${totalDustYield}Í∞úÎ•º ÏñªÏúºÏãúÍ≤†ÏäµÎãàÍπå?`)) {
            return;
        }

        const remainingInventory = player.inventory.filter(item => !itemsToDisenchant.includes(item));
        
        player.inventory = remainingInventory;
        player.enhancementStones += totalStonesYield;
        player.enchantmentDust += totalDustYield;
        
        alert(`${itemsToDisenchant.length}Í∞úÏùò ÏïÑÏù¥ÌÖúÏùÑ Î∂ÑÌï¥ÌïòÏó¨ Í∞ïÌôîÏÑù ${totalStonesYield}Í∞úÏôÄ ÎßàÎ≤ï Î∂ÄÏó¨ Í∞ÄÎ£® ${totalDustYield}Í∞úÎ•º ÌöçÎìùÌñàÏäµÎãàÎã§.`);
        
        saveGameState();
        renderBlacksmithScreen();
    }
    
    function getEnchantmentCost(item) {
        let cost = { gold: 0, dust: 0 };
        switch(item.rarity) {
            case 'common': cost = { gold: 100, dust: 5 }; break;
            case 'uncommon': cost = { gold: 300, dust: 15 }; break;
            case 'rare': cost = { gold: 1000, dust: 40 }; break;
            case 'legendary': cost = { gold: 5000, dust: 100 }; break;
            case 'mythic': cost = { gold: 15000, dust: 250 }; break;
        }
        return cost;
    }

    function renderEnchantDetails(slot) {
        const detailsContainer = document.getElementById('enhancement-details');
        if (!detailsContainer) return;
        
        const item = player.equipment[slot];
        if (!item) {
            detailsContainer.innerHTML = `<p>ÎßàÎ≤ï Î∂ÄÏó¨Ìï† Ïû•ÎπÑÍ∞Ä ÏóÜÏäµÎãàÎã§.</p>`;
            return;
        }
        
        const enchantPool = ENCHANTMENT_POOL[item.type];
        if (!enchantPool || !enchantPool[item.rarity]) {
            detailsContainer.innerHTML = `<p>Ïù¥ ÏïÑÏù¥ÌÖúÏùÄ ÎßàÎ≤ï Î∂ÄÏó¨Î•º Ìï† Ïàò ÏóÜÏäµÎãàÎã§.</p>`;
            return;
        }
        
        const cost = getEnchantmentCost(item);
        
        detailsContainer.innerHTML = `
            <h3>${getItemDisplayName(item)} ÎßàÎ≤ï Î∂ÄÏó¨</h3>
            ${item.enchantment ? `<p class="current-enchantment">ÌòÑÏû¨ Ìö®Í≥º: ${item.enchantment.description}</p>` : ''}
            <div class="enhancement-info">
                <div class="info-row">
                    <span>Î∂ÄÏó¨ ÎπÑÏö©:</span>
                    <span class="cost-display">${cost.gold} G / ${cost.dust} ‚ú®</span>
                </div>
            </div>
            ${item.enchantment ? `<p class="enchant-warning">Ï£ºÏùò: Í∏∞Ï°¥ ÎßàÎ≤ï Î∂ÄÏó¨ Ìö®Í≥ºÎäî ÏÇ¨ÎùºÏßëÎãàÎã§.</p>` : ''}
            <button id="enchant-button" class="button" ${player.gold < cost.gold || player.enchantmentDust < cost.dust ? 'disabled' : ''}>ÎßàÎ≤ï Î∂ÄÏó¨</button>
        `;
        
        document.getElementById('enchant-button')?.addEventListener('click', () => handleEnchant(slot));
    }
    
    function handleEnchant(slot) {
        const item = player.equipment[slot];
        if (!item) return;

        const cost = getEnchantmentCost(item);
        if (player.gold < cost.gold || player.enchantmentDust < cost.dust) return;
        
        player.gold -= cost.gold;
        player.enchantmentDust -= cost.dust;

        const enchantPool = ENCHANTMENT_POOL[item.type][item.rarity];
        if (!enchantPool) return;
        
        const newEnchantment = enchantPool[Math.floor(Math.random() * enchantPool.length)];
        item.enchantment = newEnchantment;
        
        alert(`‚ú® ÎßàÎ≤ï Î∂ÄÏó¨ ÏÑ±Í≥µ! [${newEnchantment.description}] Ìö®Í≥ºÎ•º ÏñªÏóàÏäµÎãàÎã§.`);

        const previousMaxHp = player.maxHp;
        recalculatePlayerStats();
        const hpChange = player.maxHp - previousMaxHp;
        player.hp += hpChange;
        player.hp = Math.min(player.hp, player.maxHp);
        if (player.hp <= 0) player.hp = 1;
        
        saveGameState();
        renderBlacksmithScreen();
        renderEnchantDetails(slot);
    }
    
    function renderSkillTreeScreen() {
        currentScreen = 'SKILL_TREE';
        renderPermanentUI();
        const classSkills = SKILL_DATA[player.className];
        
        const skillsHtml = Object.values(classSkills).map(skill => {
            const currentLevel = player.unlockedSkills[skill.id] || 0;
            const maxLevel = skill.maxLevel || 5;
            const cost = skill.cost(currentLevel);
            const canLearn = player.gold >= cost && currentLevel < maxLevel && arePrerequisitesMet(skill);
            const isMaxed = currentLevel >= maxLevel;
            
            let status = 'locked';
            if (isMaxed) {
                status = 'maxed';
            } else if (arePrerequisitesMet(skill)) {
                if (canLearn) {
                    status = 'learnable';
                } else {
                    status = 'learned'; // Can't afford but pre-reqs met
                }
            } else {
                 status = 'locked';
            }

            return `
                <div class="skill-node ${status} ${player.level < skill.requiredPlayerLevel ? 'locked' : ''}">
                    <div class="skill-info">
                        <h3>${skill.name} [${currentLevel}/${maxLevel}]</h3>
                        <p>${skill.description(currentLevel)}</p>
                        <small>ÏöîÍµ¨ Î†àÎ≤®: ${skill.requiredPlayerLevel}${skill.prerequisites.length > 0 ? `, ÏÑ†Ìñâ: ${skill.prerequisites.map(p => `${SKILL_DATA[player.className][p.id].name} Lv.${p.level}`).join(', ')}` : ''}</small>
                    </div>
                    <button class="button learn-skill-btn" data-skill-id="${skill.id}" ${!canLearn || isMaxed ? 'disabled' : ''}>
                        ${isMaxed ? 'ÏµúÎåÄ Î†àÎ≤®' : `${cost} G`}
                    </button>
                </div>
            `;
        }).join('');
        
        root.innerHTML = `
            <div class="screen-container skill-tree-screen">
                <h1>Ïä§ÌÇ¨ Ìä∏Î¶¨ (${player.className})</h1>
                 <div class="gold-sp-display top-display">
                    <p>üí∞ Gold: ${player.gold}</p>
                </div>
                <div class="skill-list">
                    ${skillsHtml}
                </div>
                <button id="back-to-town" class="button">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
            </div>
        `;
        
        document.querySelectorAll('.learn-skill-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const skillId = e.currentTarget.dataset.skillId;
                const skill = classSkills[skillId];
                if (skill) {
                    learnSkill(skill);
                }
            });
        });
        
        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }
    
    function arePrerequisitesMet(skill) {
        if (player.level < skill.requiredPlayerLevel) return false;
        return skill.prerequisites.every(prereq => (player.unlockedSkills[prereq.id] || 0) >= prereq.level);
    }
    
    function learnSkill(skill) {
        const currentLevel = player.unlockedSkills[skill.id] || 0;
        const cost = skill.cost(currentLevel);
        
        if (player.gold >= cost) {
            player.gold -= cost;
            player.unlockedSkills[skill.id] = currentLevel + 1;
            
            const previousMaxHp = player.maxHp;
            recalculatePlayerStats();
            const hpChange = player.maxHp - previousMaxHp;
            player.hp += hpChange;
            player.hp = Math.min(player.hp, player.maxHp);
            if (player.hp <= 0) player.hp = 1;

            saveGameState();
            renderSkillTreeScreen();
        }
    }
    
    function getTodayDateString() {
        const now = new Date();
        return `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()}`;
    }

    function generateDailyQuests() {
        const today = getTodayDateString();
        if (lastQuestDate === today && dailyQuests.length > 0) return;

        lastQuestDate = today;
        dailyQuests = [];
        const availableQuests = [...QUEST_POOL];
        
        for (let i = 0; i < 5; i++) {
            if (availableQuests.length === 0) break;
            const questIndex = Math.floor(Math.random() * availableQuests.length);
            const questData = availableQuests.splice(questIndex, 1)[0];
            
            const target = questData.targets[Math.floor(Math.random() * questData.targets.length)];
            
            dailyQuests.push({
                type: questData.type,
                description: questData.description(target),
                target: target,
                progress: 0,
                reward: questData.reward,
                isComplete: false,
                isClaimed: false
            });
        }
    }
    
    function updateQuestProgress(type, amount) {
        dailyQuests.forEach(quest => {
            if (quest.type === type && !quest.isComplete) {
                quest.progress += amount;
                if (quest.progress >= quest.target) {
                    quest.progress = quest.target;
                    quest.isComplete = true;
                }
            }
        });
    }

    function updatePermanentQuestProgress(type, value) {
        player.permanentQuests.forEach(quest => {
            if (quest.type === type && !quest.isComplete) {
                if (type === 'REACH_LEVEL') {
                    quest.progress = Math.max(quest.progress, value);
                } else if (type === 'DEFEAT_BOSS') {
                    if (quest.targetName === value) {
                        quest.progress++;
                    }
                } else if (type === 'ENHANCE_SUCCESS') {
                     quest.progress = Math.max(quest.progress, value);
                } else { // Generic accumulation
                    quest.progress += value;
                }
                
                if (quest.progress >= quest.target) {
                    quest.progress = quest.target;
                    quest.isComplete = true;
                }
            }
        });
    }

    function renderQuestScreen() {
        currentScreen = 'QUESTS';
        renderPermanentUI();
        
        const renderQuests = (quests) => {
            return quests.map((quest, index) => {
                const progressPercent = (quest.progress / quest.target) * 100;
                const rewardText = Object.entries(quest.reward).map(([type, amount]) => {
                    if (type === 'gold') return `üí∞${amount}G`;
                    if (type === 'stones') return `üíé${amount}Í∞ú`;
                    if (type === 'potions') return `üß™${amount}Í∞ú`;
                    if (type === 'dust') return `‚ú®${amount}Í∞ú`;
                }).join(', ');

                return `
                    <div class="quest-item">
                        <div class="quest-info">
                            <p class="quest-description">${quest.description}</p>
                            <div class="quest-progress-bar-container">
                                <div class="quest-progress-bar" style="width: ${progressPercent}%;"></div>
                            </div>
                            <p class="quest-progress-text">${quest.progress} / ${quest.target}</p>
                            <p class="quest-reward">Î≥¥ÏÉÅ: ${rewardText}</p>
                        </div>
                        <div class="quest-action">
                            <button class="button claim-quest-btn" data-quest-index="${index}" ${!quest.isComplete || quest.isClaimed ? 'disabled' : ''}>
                                ${quest.isClaimed ? 'ÏôÑÎ£åÎê®' : (quest.isComplete ? 'Î≥¥ÏÉÅ Î∞õÍ∏∞' : 'ÏßÑÌñâÏ§ë')}
                            </button>
                        </div>
                    </div>
                `;
            }).join('') || '<p>ÏôÑÎ£åÌïú ÌÄòÏä§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§.</p>';
        }

        root.innerHTML = `
            <div class="screen-container quest-screen">
                <h1>ÌÄòÏä§Ìä∏</h1>
                 <div class="quest-tabs">
                    <button class="tab-button ${questScreenMode === 'daily' ? 'active' : ''}" data-mode="daily">ÏùºÏùº ÌÄòÏä§Ìä∏</button>
                    <button class="tab-button ${questScreenMode === 'permanent' ? 'active' : ''}" data-mode="permanent">ÏòÅÍµ¨ ÌÄòÏä§Ìä∏</button>
                </div>
                <div class="quest-list">
                    ${renderQuests(questScreenMode === 'daily' ? dailyQuests : player.permanentQuests)}
                </div>
                <button id="back-to-town" class="button">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
            </div>
        `;

        document.querySelectorAll('.claim-quest-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const index = parseInt(e.currentTarget.dataset.questIndex);
                const quest = (questScreenMode === 'daily' ? dailyQuests : player.permanentQuests)[index];
                if (quest && quest.isComplete && !quest.isClaimed) {
                    claimQuestReward(quest);
                    renderQuestScreen();
                }
            });
        });
        
        document.querySelectorAll('.quest-tabs .tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                questScreenMode = e.currentTarget.dataset.mode;
                renderQuestScreen();
            });
        });

        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }
    
    function claimQuestReward(quest) {
        quest.isClaimed = true;
        let rewardMsg = "Î≥¥ÏÉÅ: ";
        if (quest.reward.gold) {
            player.gold += quest.reward.gold;
            updatePermanentQuestProgress('COLLECT_GOLD', quest.reward.gold);
            rewardMsg += `üí∞${quest.reward.gold}G `;
        }
        if (quest.reward.stones) {
            player.enhancementStones += quest.reward.stones;
            rewardMsg += `üíé${quest.reward.stones}Í∞ú `;
        }
        if (quest.reward.potions) {
            player.potions += quest.reward.potions;
            rewardMsg += `üß™${quest.reward.potions}Í∞ú `;
        }
         if (quest.reward.dust) {
            player.enchantmentDust += quest.reward.dust;
            rewardMsg += `‚ú®${quest.reward.dust}Í∞ú `;
        }
        alert(`ÌÄòÏä§Ìä∏ ÏôÑÎ£å! ${rewardMsg}`);
        saveGameState();
    }
    
    function renderRebirthScreen() {
        if (player.level < REBIRTH_LEVEL_REQ) return;
        currentScreen = 'REBIRTH';
        renderPermanentUI();
        
        const pointsToGain = 1 + Math.floor(dungeonLevel / 5) + Math.floor(player.level / 10);
        
        const upgradesHtml = Object.entries(REBIRTH_UPGRADES).map(([key, upgrade]) => {
            const currentLevel = player.rebirthUpgrades[key] || 0;
            const maxLevel = upgrade.maxLevel || 10;
            const cost = upgrade.cost(currentLevel);
            const canAfford = player.rebirthPoints >= cost;
            const isMaxed = currentLevel >= maxLevel;

            return `
                <div class="rebirth-upgrade-item">
                    <div class="rebirth-upgrade-info">
                        <h3>${upgrade.name} [${currentLevel}/${maxLevel}]</h3>
                        <p>${upgrade.description(currentLevel)}</p>
                    </div>
                    <button class="button" data-upgrade-key="${key}" ${!canAfford || isMaxed ? 'disabled' : ''}>
                        ${isMaxed ? 'ÏµúÎåÄ' : `${cost} RP`}
                    </button>
                </div>
            `;
        }).join('');
        
        root.innerHTML = `
            <div class="screen-container rebirth-screen">
                <h1>ÌôòÏÉù</h1>
                <div class="rebirth-info">
                    <p>ÌòÑÏû¨ ÌôòÏÉù ÌöüÏàò: ${player.rebirths}Ìöå</p>
                    <p>Î≥¥Ïú† ÌôòÏÉù Ìè¨Ïù∏Ìä∏(RP): <span class="rebirth-points">${player.rebirthPoints}</span></p>
                    <p>Ïù¥Î≤à ÌôòÏÉù Ïãú ÌöçÎìùÌï† RP: <span class="rebirth-points">${pointsToGain}</span></p>
                    <p>ÌôòÏÉù Ïãú Î†àÎ≤®, Í≥®Îìú, ÌÄòÏä§Ìä∏Í∞Ä Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§. Ïû•ÎπÑ, ÏïÑÏù¥ÌÖú, ÌôòÏÉù ÏóÖÍ∑∏Î†àÏù¥ÎìúÎäî Ïú†ÏßÄÎê©ÎãàÎã§.</p>
                </div>
                <div class="rebirth-upgrades">${upgradesHtml}</div>
                <button id="rebirth-button" class="button" style="background-color: var(--rebirth-color); margin-bottom: 0.5rem;">ÌôòÏÉùÌïòÍ∏∞</button>
                <button id="back-to-town" class="button">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
            </div>
        `;
        
        document.querySelectorAll('.rebirth-upgrade-item button').forEach(button => {
            button.addEventListener('click', e => {
                const key = e.currentTarget.dataset.upgradeKey;
                handleBuyRebirthUpgrade(key);
            });
        });
        
        document.getElementById('rebirth-button')?.addEventListener('click', handleRebirth);
        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }
    
    function handleBuyRebirthUpgrade(key) {
        const upgrade = REBIRTH_UPGRADES[key];
        const currentLevel = player.rebirthUpgrades[key] || 0;
        const cost = upgrade.cost(currentLevel);
        
        if (player.rebirthPoints >= cost && currentLevel < (upgrade.maxLevel || 10)) {
            player.rebirthPoints -= cost;
            player.rebirthUpgrades[key] = currentLevel + 1;
            saveGameState();
            renderRebirthScreen();
        }
    }
    
    function handleRebirth() {
        if (player.level < REBIRTH_LEVEL_REQ) return;
        if (!confirm('Ï†ïÎßêÎ°ú ÌôòÏÉùÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) return;

        updatePermanentQuestProgress('REBIRTH', 1);

        const pointsToGain = 1 + Math.floor(dungeonLevel / 5) + Math.floor(player.level / 10);
        player.rebirths++;
        player.rebirthPoints += pointsToGain;
        
        // Reset progress
        const difficultySettings = DIFFICULTY_SETTINGS[currentDifficulty];
        dungeonLevel = 1;
        player.level = 1;
        player.xp = 0;
        player.xpToNextLevel = 39;
        player.gold = difficultySettings.startGold + (player.rebirthUpgrades.gold_gain || 0) * 100; // Bonus starting gold
        player.potions = difficultySettings.startPotions;
        player.unlockedSkills = {};
        player.ultimateSkillCooldown = 0;
        player.ultimateSkill2Cooldown = 0;

        generateDailyQuests();
        
        recalculatePlayerStats();
        player.hp = player.maxHp;
        
        alert(`ÌôòÏÉù ÏôÑÎ£å! ${pointsToGain} RPÎ•º ÌöçÎìùÌñàÏäµÎãàÎã§.`);
        
        saveGameState();
        renderTownScreen();
    }

    function handleLiberation() {
        const COST = { gold: 20000, stones: 500, dust: 250 };
        if (player.gold < COST.gold || player.enhancementStones < COST.stones || player.enchantmentDust < COST.dust) {
            alert('Ìï¥Î∞©Ïóê ÌïÑÏöîÌïú Ïû¨Î£åÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.');
            return;
        }

        if (confirm(`Ìï¥Î∞©ÏùÑ ÏßÑÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå? 20000 Í≥®Îìú, Í∞ïÌôîÏÑù 500Í∞ú, ÎßàÎ≤ï Î∂ÄÏó¨ Í∞ÄÎ£® 250Í∞úÍ∞Ä ÏÜåÎ™®Îê©ÎãàÎã§. Î™®Îì† Îä•Î†•ÏπòÍ∞Ä ÏòÅÍµ¨Ï†ÅÏúºÎ°ú 2Î∞∞Í∞Ä Îê©ÎãàÎã§.`)) {
            player.gold -= COST.gold;
            player.enhancementStones -= COST.stones;
            player.enchantmentDust -= COST.dust;
            player.isLiberated = true;

            const previousMaxHp = player.maxHp;
            recalculatePlayerStats();
            const hpChange = player.maxHp - previousMaxHp;
            player.hp += hpChange;
            player.hp = Math.min(player.hp, player.maxHp);
            if (player.hp <= 0) player.hp = 1;
            
            alert('‚ú® Ìï¥Î∞©Ïùò ÎπõÏù¥ ÎãπÏã†ÏùÑ Í∞êÏåâÎãàÎã§! Î™®Îì† Îä•Î†•ÏπòÍ∞Ä 2Î∞∞Î°ú Ï¶ùÌè≠ÎêòÏóàÏäµÎãàÎã§!');
            saveGameState();
            renderTownScreen();
        }
    }
    
    function renderGachaScreen() {
        currentScreen = 'GACHA';
        renderPermanentUI();
        root.innerHTML = `
            <div class="screen-container">
                <h1>Ïû•ÎπÑ ÎΩëÍ∏∞</h1>
                <p>Ìù¨Í∑ÄÌïú Ïû•ÎπÑÎ•º ÌöçÎìùÌï† Í∏∞Ìöå! Ïã†Ìôî Îì±Í∏â Ïû•ÎπÑÎäî Ïò§ÏßÅ ÎΩëÍ∏∞ÏóêÏÑúÎßå Îì±Ïû•Ìï©ÎãàÎã§.</p>
                <div class="gacha-info" style="margin: 1rem 0; background: rgba(0,0,0,0.2); padding: 0.8rem; border-radius: 8px;">
                    <p><strong>1Ìöå ÎΩëÍ∏∞:</strong> ${GACHA_COST_SINGLE} G</p>
                    <p><strong>10Ìöå ÎΩëÍ∏∞ (10% Ìï†Ïù∏):</strong> ${GACHA_COST_TEN} G</p>
                </div>
                <div class="gold-sp-display top-display">
                    <p>üí∞ Gold: ${player.gold}</p>
                </div>
                <div id="action-buttons" class="town-actions" style="margin: 1rem 0;">
                    <button data-action="single" class="button" ${player.gold < GACHA_COST_SINGLE ? 'disabled' : ''}>1Ìöå ÎΩëÍ∏∞</button>
                    <button data-action="ten" class="button" ${player.gold < GACHA_COST_TEN ? 'disabled' : ''}>10Ìöå ÎΩëÍ∏∞</button>
                </div>
                <div id="gacha-results" style="width: 100%; height: 150px; overflow-y: auto;"></div>
                <button id="back-to-town" class="button" style="margin-top: 1rem;">ÎßàÏùÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
            </div>
        `;
        
        document.getElementById('action-buttons')?.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (action === 'single') handleGacha(1);
            else if (action === 'ten') handleGacha(10);
        });
        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }
    
    function handleGacha(count) {
        const totalCost = count === 1 ? GACHA_COST_SINGLE : GACHA_COST_TEN;
        if (player.gold < totalCost) return;

        let itemsToGain = 0;
        const rarityWeights = {
            'enhancementStones': 19.9, 'uncommon': 40, 'rare': 37,
            'legendary': 2, 'mythic': 1, 'ultimate': 0.1
        };
        const totalWeight = Object.values(rarityWeights).reduce((a, b) => a + b, 0);

        // Pre-calculate how many items will be generated to check inventory space
        for (let i = 0; i < count; i++) {
            let rand = Math.random() * totalWeight;
            let chosenRarity = 'uncommon';
            for (const [rarity, weight] of Object.entries(rarityWeights)) {
                if (rand < weight) { chosenRarity = rarity; break; }
                rand -= weight;
            }
            if (chosenRarity !== 'enhancementStones') {
                itemsToGain++;
            }
        }
        
        if (!canAddItem(itemsToGain)) {
            alert(`Ïù∏Î≤§ÌÜ†Î¶¨Ïóê Í≥µÍ∞ÑÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§. (${itemsToGain}Ïπ∏ ÌïÑÏöî, ${INVENTORY_LIMIT - player.inventory.length}Ïπ∏ ÎÇ®Ïùå)`);
            return;
        }
        
        player.gold -= totalCost;
        
        const gachaPool = ITEM_DATABASE.filter(i => (i.type === 'weapon' || i.type === 'armor' || i.type === 'accessory'));
        const results = [];
        
        for (let i = 0; i < count; i++) {
            let rand = Math.random() * totalWeight;
            let chosenRarity = 'uncommon'; // Default fallback
            for (const [rarity, weight] of Object.entries(rarityWeights)) {
                if (rand < weight) {
                    chosenRarity = rarity;
                    break;
                }
                rand -= weight;
            }
            
            if (chosenRarity === 'enhancementStones') {
                const stonesGained = Math.floor(Math.random() * 21) + 5; // 5~25 stones
                player.enhancementStones += stonesGained;
                results.push({ type: 'material', name: `üíé Í∞ïÌôîÏÑù ${stonesGained}Í∞ú` });
            } else {
                const itemsOfRarity = gachaPool.filter(item => item.rarity === chosenRarity);
                if (itemsOfRarity.length > 0) {
                    const itemData = itemsOfRarity[Math.floor(Math.random() * itemsOfRarity.length)];
                    const newItem = createItemInstance(itemData.id);
                    player.inventory.push(newItem);
                    results.push(newItem);
                } else {
                    const fallbackItems = gachaPool.filter(item => item.rarity === 'rare');
                    if(fallbackItems.length > 0) {
                        const itemData = fallbackItems[Math.floor(Math.random() * fallbackItems.length)];
                        const newItem = createItemInstance(itemData.id);
                        player.inventory.push(newItem);
                        results.push(newItem);
                    }
                }
            }
        }
        
        const resultsEl = document.getElementById('gacha-results');
        if (resultsEl) {
            resultsEl.innerHTML = '<h3>ÎΩëÍ∏∞ Í≤∞Í≥º:</h3>' + results.map(res => {
                if (res.type === 'material') {
                    return `<p>${res.name}</p>`;
                }
                return `<p class="rarity-${res.rarity}">${res.name}</p>`;
            }).join('');
        }
        
        saveGameState();
        const goldDisplay = document.querySelector('.gold-sp-display p');
        if (goldDisplay) goldDisplay.textContent = `üí∞ Gold: ${player.gold}`;
        const singleBtn = document.querySelector('[data-action="single"]');
        if (singleBtn) singleBtn.disabled = player.gold < GACHA_COST_SINGLE;
        const tenBtn = document.querySelector('[data-action="ten"]');
        if(tenBtn) tenBtn.disabled = player.gold < GACHA_COST_TEN;
    }

    function startSurvivalDungeon() {
        survivalWave = 1;
        messageLog = [`ÏÑúÎ∞îÏù¥Î≤å ÎçòÏ†ÑÏóê ÏßÑÏûÖÌñàÎã§. Wave ${survivalWave}`];
        spawnSurvivalMonster();
        renderSurvivalDungeonScreen();
    }

    function spawnSurvivalMonster() {
        const monsterPool = monsterList.slice(0, Math.min(monsterList.length, Math.floor(survivalWave / 2) + 1));
        const monsterIndex = Math.floor(Math.random() * monsterPool.length);
        let monsterData = monsterPool[monsterIndex];

        if (survivalWave % 10 === 0) { // Boss every 10 waves
            const bossIndex = Math.min(Math.floor(survivalWave / 10) -1, bossList.length - 1);
            monsterData = bossList[bossIndex];
        }

        const levelModifier = Math.pow(1.08, survivalWave - 1);

        monster = {
            name: (survivalWave % 10 === 0 ? `üëë ` : '') + monsterData.name,
            emoji: monsterData.emoji,
            maxHp: Math.floor(monsterData.baseHp * levelModifier * 1.2),
            hp: Math.floor(monsterData.baseHp * levelModifier * 1.2),
            attackPower: Math.floor(monsterData.baseAttack * levelModifier),
            defense: 0,
            statusEffects: [],
        };
    }
    
    function renderSurvivalDungeonScreen(isBattleOver = false) {
        currentScreen = 'SURVIVAL';
        renderPermanentUI();
        // Re-use dungeon screen logic with slight modifications
        const ultimateSkill = ULTIMATE_SKILLS[player.className];
        const cooldown = player.ultimateSkillCooldown;
        const disabled = cooldown > 0 || isBattleOver;
        const skillButton = `<button data-action="ultimate" class="button" ${disabled ? 'disabled' : ''}>${ultimateSkill.name} ${disabled ? `(${cooldown})` : ''}</button>`;

        const classSkills = SKILL_DATA[player.className];
        const ultimateSkill2Id = Object.keys(classSkills).find(id => id.includes('_ult_2'));
        let skill2Button = '';
        if (ultimateSkill2Id && player.unlockedSkills[ultimateSkill2Id]) {
            const skill2 = ULTIMATE_SKILLS_2[player.className];
            const cooldown2 = player.ultimateSkill2Cooldown;
            const disabled2 = cooldown2 > 0 || isBattleOver;
            skill2Button = `<button data-action="ultimate2" class="button" ${disabled2 ? 'disabled' : ''}>${skill2.name} ${disabled2 ? `(${cooldown2})` : ''}</button>`;
        }

        const survivalInfo = `<p class="dungeon-progress" style="color: var(--survival-color);">ÏÑúÎ∞îÏù¥Î≤å Wave ${survivalWave}</p>`;
        
        root.innerHTML = `
            <div id="game-world">
                ${survivalInfo}
                ${createCharacterCard(monster, false)}
                ${createCharacterCard(player, true)}
            </div>
            <div id="message-log">${messageLog.map(msg => `<p>${msg}</p>`).join('')}</div>
            <div id="action-buttons">
                <button data-action="attack" class="button" ${isBattleOver ? 'disabled' : ''}>Í≥µÍ≤©</button>
                <button data-action="potion" class="button" ${player.potions <= 0 || isBattleOver ? 'disabled' : ''}>Î¨ºÏïΩ (${player.potions})</button>
                ${skillButton}
                ${skill2Button}
                <button data-action="survival-escape" class="button" ${isBattleOver ? 'disabled' : ''}>Ìè¨Í∏∞</button>
            </div>
        `;
        document.getElementById('action-buttons')?.addEventListener('click', handleSurvivalAction);
    }
    
    function handleSurvivalAction(e) {
        const target = e.target.closest('button');
        if (!target) return;
        const action = target.dataset.action;
        if (action === 'survival-escape') {
            handleSurvivalEnd(false);
            return;
        }
        
        const isStunned = processStatusEffects(player);
        if (isStunned) {
            addMessage(`üí´ ${player.name}ÏùÄ(Îäî) Í∏∞Ï†àÌï¥ÏÑú ÏõÄÏßÅÏùº Ïàò ÏóÜÎã§!`);
            handleSurvivalMonsterTurn();
            return;
        }

        if (player.ultimateSkillCooldown > 0) player.ultimateSkillCooldown--;
        if (player.ultimateSkill2Cooldown > 0) player.ultimateSkill2Cooldown--;
        player.activeBuffs = player.activeBuffs.map(buff => ({ ...buff, duration: buff.duration - 1 })).filter(buff => buff.duration > 0);
        recalculatePlayerStats();

        switch (action) {
            case 'attack': handleAttack(); break;
            case 'potion': handleUsePotion(); break;
            case 'ultimate': handleUseUltimateSkill(); break;
            case 'ultimate2': handleUseUltimateSkill2(); break;
        }
        
        if (monster.hp <= 0) {
            survivalMonsterDefeated();
        } else {
            handleSurvivalMonsterTurn();
        }
    }
    
    function handleSurvivalMonsterTurn() {
        const isStunned = processStatusEffects(monster);
        recalculatePlayerStats();
        if (isStunned) {
            addMessage(`üí´ ${monster.name}ÏùÄ(Îäî) Í∏∞Ï†àÌï¥ÏÑú ÏõÄÏßÅÏùº Ïàò ÏóÜÎã§!`);
            renderSurvivalDungeonScreen();
            return;
        }

        monsterAttack();
        
        if (player.hp <= 0) {
            handleSurvivalEnd(true); // Defeated
        } else {
            renderSurvivalDungeonScreen();
        }
    }
    
    function survivalMonsterDefeated() {
        addMessage(`üéâ Wave ${survivalWave}Ïùò Î™¨Ïä§ÌÑ∞Î•º Î¨ºÎ¶¨Ï≥§Îã§!`);
        
        const goldGained = Math.floor(10 * Math.pow(1.1, survivalWave - 1));
        player.gold += goldGained;
        addMessage(`üí∞ ${goldGained} Í≥®ÎìúÎ•º ÌöçÎìùÌñàÎã§.`);
        
        survivalWave++;
        addMessage(`Îã§Ïùå Wave: ${survivalWave}`);

        // Small HP recovery between waves
        const hpRecovery = Math.floor(player.maxHp * 0.05);
        player.hp = Math.min(player.maxHp, player.hp + hpRecovery);
        
        renderSurvivalDungeonScreen(true);
        setTimeout(continueSurvival, 1500);
    }
    
    function continueSurvival() {
        spawnSurvivalMonster();
        renderSurvivalDungeonScreen();
    }
    
    function handleSurvivalEnd(isDefeat) {
        const goldEarned = Math.floor(50 * Math.pow(1.1, survivalWave - 1) * (survivalWave-1) * 0.5);
        player.gold += goldEarned;
        
        if (survivalWave -1 > player.survivalHighScore) {
            player.survivalHighScore = survivalWave -1;
        }

        player.hp = player.maxHp;
        player.statusEffects = [];
        player.activeBuffs = [];
        recalculatePlayerStats();

        if (isDefeat) {
            alert(`ÏÑúÎ∞îÏù¥Î≤å Ï¢ÖÎ£å! ${survivalWave - 1} WaveÍπåÏßÄ ÎèÑÎã¨ÌñàÏäµÎãàÎã§. Î≥¥ÏÉÅÏúºÎ°ú ${goldEarned}GÎ•º ÌöçÎìùÌï©ÎãàÎã§.`);
        } else {
            alert(`ÏÑúÎ∞îÏù¥Î≤åÏùÑ Ìè¨Í∏∞ÌñàÏäµÎãàÎã§. ${survivalWave - 1} WaveÍπåÏßÄ ÎèÑÎã¨ÌñàÏäµÎãàÎã§. Î≥¥ÏÉÅÏúºÎ°ú ${goldEarned}GÎ•º ÌöçÎìùÌï©ÎãàÎã§.`);
        }
        
        saveGameState();
        renderTownScreen();
    }

    function saveGameState() {
      try {
        const gameState = {
          player,
          monster,
          messageLog,
          currentScreen,
          currentDifficulty,
          dungeonLevel,
          dungeonFloor,
          dailyQuests,
          lastQuestDate,
          shopFilterType,
          shopFilterRarity,
          blacksmithMode,
          batchDisenchantFilters,
          questScreenMode,
          survivalWave,
        };
        localStorage.setItem('simpleRPG_saveData', JSON.stringify(gameState));
      } catch (e) {
        console.error("Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§:", e);
      }
    }

    function loadGameState() {
        const savedData = localStorage.getItem('simpleRPG_saveData');
        if (!savedData) return false;

        try {
            const gameState = JSON.parse(savedData);
            player = gameState.player;
            monster = gameState.monster;
            messageLog = gameState.messageLog;
            currentScreen = gameState.currentScreen;
            currentDifficulty = gameState.currentDifficulty;
            dungeonLevel = gameState.dungeonLevel;
            dungeonFloor = gameState.dungeonFloor;
            dailyQuests = gameState.dailyQuests;
            lastQuestDate = gameState.lastQuestDate;
            shopFilterType = gameState.shopFilterType;
            shopFilterRarity = gameState.shopFilterRarity;
            blacksmithMode = gameState.blacksmithMode;
            batchDisenchantFilters = gameState.batchDisenchantFilters;
            questScreenMode = gameState.questScreenMode;
            survivalWave = gameState.survivalWave;
            
            // Backwards compatibility for new features
            if (!player.inventory) player.inventory = [];
            if (player.enchantmentDust === undefined) player.enchantmentDust = 0;


            return true;
        } catch (e) {
            console.error("Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:", e);
            deleteSaveData();
            return false;
        }
    }

    function deleteSaveData(showAlert = true) {
        localStorage.removeItem('simpleRPG_saveData');
        if (showAlert) {
            alert("Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.");
            createStartScreen();
        }
    }
    
    function initializeApp() {
        createStartScreen();
    }
    
    // Initial Setup
    initializeApp();

  </script>
</body>
</html>