
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>간단RPG</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚔️</text></svg>">
  <style>
    :root {
      --primary-bg: #2c3e50;
      --secondary-bg: #34495e;
      --border-color: #7f8c8d;
      --text-color: #ecf0f1;
      --player-hp-color: #2ecc71;
      --monster-hp-color: #e74c3c;
      --xp-bar-color: #3498db;
      --button-bg: #3498db;
      --button-hover-bg: #2980b9;
      --button-disabled-bg: #95a5a6;
      --skill-learned-bg: #27ae60;
      --skill-learnable-bg: #f1c40f;
      --skill-locked-bg: #7f8c8d;
      --skill-maxed-bg: #e67e22;
      --disenchant-color: #9b59b6;
      --enchant-color: #e67e22;
      --rebirth-color: #e74c3c;
      --survival-color: #1abc9c;

      --rarity-common: #ecf0f1;
      --rarity-uncommon: #2ecc71;
      --rarity-rare: #3498db;
      --rarity-legendary: #f39c12;
      --rarity-mythic: #e74c3c;
      --rarity-ultimate: #00e6e6;
      --rarity-eternal: #ff66ff;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: var(--primary-bg);
      color: var(--text-color);
      user-select: none;
      transition: background-color 0.3s, color 0.3s;
    }

    #root {
      width: 100%;
      max-width: 400px;
      height: 100%;
      max-height: 700px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 0.8rem;
      box-sizing: border-box;
      background-color: var(--secondary-bg);
      border-radius: 12px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
      transition: background-color 0.3s, box-shadow 0.3s;
    }

    .screen-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    .town-screen {
        justify-content: space-around;
    }

    .town-screen .player-card {
        margin: 0.8rem 0;
    }

    /* Difficulty & Class Selection */
    .difficulty-selection,
    .class-selection {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        width: 100%;
        margin-top: 1.2rem;
    }
    .difficulty-card,
    .class-card {
        background-color: rgba(0,0,0,0.2);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.8rem;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s;
        color: var(--text-color);
        font-family: inherit;
        text-align: left;
        width: 100%;
        box-sizing: border-box;
    }
    .difficulty-card:hover,
    .class-card:hover {
        background-color: var(--secondary-bg);
        transform: translateY(-3px);
    }
    .difficulty-card h2,
    .class-card h2 {
        margin: 0 0 0.4rem 0;
        color: var(--button-bg);
        font-size: 1.2rem;
    }
    .difficulty-card p,
    .class-card p {
        margin: 0;
        font-size: 0.75rem;
        line-height: 1.4;
    }


    h1 {
      margin-bottom: 0.8rem;
      font-size: 2rem;
    }

    h2.inventory-full {
        color: var(--monster-hp-color);
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }


    .logo {
        font-size: 2.8rem;
        font-weight: 700;
        color: var(--skill-learnable-bg);
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px var(--rarity-legendary);
        margin-bottom: 1.5rem;
        letter-spacing: 2px;
    }

    p {
      line-height: 1.5;
    }

    #game-world {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }

    .character-card {
        background-color: rgba(0,0,0,0.2);
        padding: 0.8rem;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        transition: background-color 0.3s;
        width: 100%;
        box-sizing: border-box;
    }

    .character-card h2 {
        margin: 0 0 0.4rem 0;
        font-size: 1.2rem;
        white-space: pre-wrap;
    }

    .player-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.4rem;
        margin-bottom: 0.4rem;
    }

    .player-header h2 {
        margin: 0;
        text-align: left;
        overflow: hidden;
        text-overflow: ellipsis;
        display: flex;
        align-items: center;
    }
    .player-class {
        color: #bdc3c7;
        font-size: 0.8rem;
    }
    .inventory-warning {
        color: var(--monster-hp-color);
        font-weight: bold;
        font-size: 0.9rem;
        margin-left: 0.4rem;
        display: inline-block;
        vertical-align: middle;
    }

    .dungeon-progress {
        text-align: center;
        font-weight: bold;
        color: var(--xp-bar-color);
        margin: 0 0 0.4rem 0 !important;
        padding-bottom: 0.4rem;
        border-bottom: 1px solid var(--border-color);
        font-size: 0.9rem;
    }

    .hp-bar-container, .xp-bar-container {
        width: 100%;
        height: 16px;
        background-color: #2c3e50;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid var(--border-color);
        margin-top: 0.4rem;
        transition: background-color 0.3s;
    }

    .hp-bar, .xp-bar {
        height: 100%;
        transition: width 0.3s ease-in-out;
    }

    .player-card .hp-bar {
        background-color: var(--player-hp-color);
    }

    .monster-card .hp-bar {
        background-color: var(--monster-hp-color);
    }

    .xp-bar {
        background-color: var(--xp-bar-color);
    }

    .character-card p {
        margin: 0.4rem 0 0 0;
        text-align: right;
        font-weight: bold;
        font-size: 0.75rem;
    }

    .gold-display {
        font-size: 0.9rem;
        font-weight: bold;
        margin-bottom: 0.8rem;
    }

    .gold-sp-display {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        font-size: 0.75rem;
        font-weight: bold;
    }
    .gold-sp-display p {
        margin: 0;
    }
    .gold-sp-display.top-display {
        width: 100%;
        flex-direction: row;
        justify-content: space-around;
        background: rgba(0,0,0,0.2);
        padding: 0.4rem;
        border-radius: 8px;
        margin-bottom: 0.8rem;
        transition: background-color 0.3s;
    }

    /* Styles for new concise character UI */
    .bar-wrapper {
        width: 100%;
        margin-bottom: 0.4rem;
    }
    .bar-wrapper:last-of-type {
        margin-bottom: 0.8rem;
    }
    .bar-container-overlay {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 16px;
        background-color: #2c3e50;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid var(--border-color);
    }
    .bar-container-overlay .hp-bar, .bar-container-overlay .xp-bar {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        transition: width 0.3s ease-in-out;
    }
    .bar-text {
        position: relative;
        z-index: 2;
        color: white;
        font-size: 0.7rem;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    .info-section {
        width: 100%;
        margin-top: 0.6rem;
    }
    .info-section h3 {
        margin: 0 0 0.4rem 0;
        font-size: 0.8rem;
        text-align: left;
        color: var(--border-color);
        padding-bottom: 0.2rem;
        border-bottom: 1px solid var(--secondary-bg);
        font-weight: 500;
    }

    .compact-info-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0.4rem;
        font-size: 0.75rem;
        text-align: center;
        background: rgba(0,0,0,0.15);
        padding: 0.4rem;
        border-radius: 6px;
    }
    .compact-info-grid span {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .equipment-ultimate-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.4rem;
        font-size: 0.7rem;
    }
    .equipment-compact-item {
        background: rgba(0,0,0,0.15);
        padding: 0.3rem 0.5rem;
        border-radius: 6px;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        overflow: hidden;
    }
    .equipment-compact-item span:first-child {
        font-size: 1rem;
        flex-shrink: 0;
    }
    .equipment-compact-item span:last-child {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex-grow: 1;
    }

    .compact-equipment-display {
        grid-column: 1 / -1;
        display: flex;
        flex-wrap: wrap;
        gap: 0.2rem 0.6rem;
        margin-top: 0.4rem;
        padding-top: 0.4rem;
        border-top: 1px solid var(--border-color);
        font-size: 0.7rem;
        justify-content: center;
    }
    .compact-equipment-item {
        background: rgba(0,0,0,0.3);
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
    }

    .player-buffs {
        grid-column: 1 / -1;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        margin-top: 0.4rem;
        justify-content: center;
    }
    .buff-icon {
        background-color: var(--button-bg);
        color: white;
        padding: 0.15rem 0.3rem;
        border-radius: 4px;
        font-size: 0.65rem;
        font-weight: bold;
    }

    .status-effects {
        display: flex;
        gap: 0.4rem;
        margin-top: 0.4rem;
        min-height: 18px;
    }
    .status-effect-icon {
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        padding: 0.1rem 0.3rem;
        border-radius: 4px;
        font-size: 0.65rem;
        font-weight: bold;
    }

    #message-log {
        width: 100%;
        height: 120px;
        background-color: rgba(0,0,0,0.3);
        border-radius: 8px;
        padding: 0.4rem 0.8rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column-reverse;
        box-sizing: border-box;
        border: 1px solid var(--border-color);
        margin: 0.8rem 0;
        transition: background-color 0.3s;
    }

    #message-log p {
        margin: 0.2rem 0;
        font-size: 0.75rem;
        border-bottom: 1px solid #4a637e;
        padding-bottom: 0.2rem;
    }
    #message-log p:first-child {
        border-bottom: none;
    }

    #action-buttons {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        gap: 0.4rem;
    }
    .town-actions {
        grid-template-columns: 1fr 1fr;
        gap: 0.6rem;
    }

    .button {
      padding: 0.5rem;
      font-size: 0.75rem;
      font-weight: bold;
      color: white;
      background-color: var(--button-bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
      text-align: center;
      white-space: nowrap;
      position: relative;
    }

    .button:hover {
      background-color: var(--button-hover-bg);
    }

    .button:active {
      transform: scale(0.98);
    }

    .button:disabled {
        background-color: var(--button-disabled-bg);
        cursor: not-allowed;
        transform: none;
    }

    .button:disabled:hover {
        background-color: var(--button-disabled-bg);
    }

    .notification-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        background-color: var(--monster-hp-color);
        color: white;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7rem;
        font-weight: bold;
        box-shadow: 0 0 4px rgba(0,0,0,0.5);
    }


    /* Shop & etc. Styles */
    .shop-container, .skill-tree-screen, .rebirth-screen, .survival-shop-screen, .quest-screen {
        justify-content: flex-start;
        padding-top: 0.8rem;
    }
    .shop-items, .skill-list, .rebirth-upgrades, .survival-items, .quest-list {
        width: 100%;
        margin-top: 0.8rem;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        overflow-y: auto;
        flex-grow: 1;
    }
    .shop-item, .rebirth-upgrade-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(0,0,0,0.2);
        padding: 0.6rem 0.8rem;
        border-radius: 8px;
        transition: background-color 0.3s;
    }
    .shop-item span, .rebirth-upgrade-info h3 {
        font-size: 0.8rem;
        font-weight: 500;
        margin: 0;
    }
    .shop-item .item-class {
        font-size: 0.65rem;
        color: var(--border-color);
        margin-left: 0.4rem;
    }

    .shop-item .button, .rebirth-upgrade-item .button {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
        min-width: 65px;
    }
    #back-to-town {
        margin-top: auto;
        width: 100%;
    }

    .shop-filters {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        margin-bottom: 0.8rem;
    }
    .filter-group {
        display: flex;
        gap: 0.4rem;
        background: rgba(0,0,0,0.2);
        padding: 0.4rem;
        border-radius: 8px;
        transition: background-color 0.3s;
    }
    .filter-btn {
        flex-grow: 1;
        padding: 0.3rem;
        font-size: 0.7rem;
        color: var(--text-color);
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s;
    }
    .filter-btn:hover {
        background-color: var(--primary-bg);
    }
    .filter-btn.active {
        background-color: var(--button-bg);
        border-color: var(--button-hover-bg);
        font-weight: bold;
        color: white;
    }

    /* Equipment Screen Styles */
    .equipment-screen {
        justify-content: flex-start;
    }
    .equipment-screen h1 {
        margin-bottom: 0.4rem;
        font-size: 1.5rem;
    }
    .equipment-screen h2 {
        margin-top: 1.2rem;
        margin-bottom: 0.4rem;
        font-size: 1.2rem;
    }

    .equipment-slots {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.8rem;
        width: 100%;
        margin: 0.8rem 0 0 0;
    }
    .slot-container h3 {
        margin: 0 0 0.4rem 0;
        font-size: 0.8rem;
    }
    .inventory-grid {
        width: 100%;
        flex-grow: 1;
        overflow-y: auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.4rem;
        padding: 0.4rem;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        border: 2px solid transparent;
        transition: border-color 0.3s;
        min-height: 120px;
    }
    .item-card {
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.6rem;
        cursor: pointer;
        transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
    }
    .item-card:hover {
        background-color: var(--primary-bg);
    }
    .item-card.empty {
        display: flex;
        justify-content: center;
        align-items: center;
        color: var(--border-color);
        font-style: italic;
        cursor: default;
        font-size: 0.75rem;
        min-height: 80px;
    }
    .item-card.empty:hover {
        background-color: var(--secondary-bg);
    }
    .item-card.restricted {
        opacity: 0.6;
    }
    .restricted-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5);
        color: var(--monster-hp-color);
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: 0.8rem;
        border-radius: 8px;
        pointer-events: none;
    }
    .item-card .item-name {
        font-weight: bold;
        margin: 0;
        font-size: 0.8rem;
    }
    .item-card .item-class {
        font-size: 0.65rem;
        color: var(--border-color);
        font-style: italic;
        margin: 0;
    }
    .item-card .item-stats {
        font-size: 0.65rem;
        color: #bdc3c7;
        margin: 0;
    }
    .item-card .item-enchantment {
        font-size: 0.7rem;
        font-weight: bold;
        color: var(--enchant-color);
        margin-top: 0.2rem;
    }

    .equipment-screen-footer {
        width: 100%;
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.8rem;
        margin-top: auto;
        padding-top: 0.8rem;
    }


    /* Blacksmith Screen Styles */
    .blacksmith-screen {
        justify-content: flex-start;
    }
    .blacksmith-screen h1 { margin-bottom: 0.4rem; }
    .blacksmith-tabs {
        display: flex;
        width: 100%;
        margin-bottom: 0.8rem;
    }
    .tab-button {
        flex: 1;
        padding: 0.6rem;
        font-size: 0.7rem;
        font-weight: bold;
        color: var(--text-color);
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        border-bottom-width: 2px;
    }
    .tab-button:first-child {
        border-top-left-radius: 8px;
    }
    .tab-button:last-child {
        border-top-right-radius: 8px;
    }
    .tab-button:not(:first-child) {
        border-left: none;
    }
    .tab-button.active {
        background-color: var(--primary-bg);
        border-bottom: 2px solid var(--button-bg);
    }

    #blacksmith-content {
        width: 100%;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .enhancement-slots {
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.8rem;
        width: 100%;
        margin-bottom: 0.8rem;
    }
    .enhancement-slot {
        text-align: center;
    }
    .enhancement-slot h3 {
        margin: 0 0 0.4rem;
        font-size: 0.9rem;
    }
    #enhancement-details {
        width: 100%;
        min-height: 120px;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        padding: 0.8rem;
        box-sizing: border-box;
        transition: background-color 0.3s;
    }
    #enhancement-details h3 {
        margin: 0 0 0.8rem;
        color: var(--xp-bar-color);
        font-size: 1.1rem;
    }
    .enhancement-info {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        margin-bottom: 0.8rem;
    }
    .info-row {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem;
    }
    .cost-display {
        font-weight: bold;
    }
    .next-stats {
        display: flex;
        gap: 0.4rem;
        font-weight: bold;
        color: var(--player-hp-color);
    }
    .penalty-info {
        font-size: 0.65rem;
        color: var(--monster-hp-color);
        margin: 0 0 0.8rem;
    }
    #enhance-button, #enchant-button {
        width: 100%;
    }
    .current-enchantment {
        font-size: 0.75rem;
        color: var(--enchant-color);
        margin-bottom: 0.4rem;
        font-style: italic;
    }
    .enchant-warning {
        font-size: 0.65rem;
        color: var(--skill-learnable-bg);
        margin: 0 0 0.8rem;
    }

    /* Disenchant Styles */
    .blacksmith-screen h2 { margin: 0 0 0.4rem 0; font-size: 1rem; }
    .inventory-grid.disenchant-mode {
        border-color: var(--disenchant-color);
    }
    .item-card.disenchantable:hover {
        box-shadow: 0 0 8px var(--disenchant-color);
    }
    .disenchant-overlay {
        position: absolute;
        bottom: 0; left: 0; right: 0;
        background: linear-gradient(to top, var(--disenchant-color), transparent);
        color: white;
        text-align: center;
        font-weight: bold;
        font-size: 0.75rem;
        padding: 1rem 0 0.2rem 0;
        pointer-events: none;
    }

    /* Transcendence Styles */
    .transcendence-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      gap: 0.8rem;
    }
    .transcendence-main {
      display: flex;
      align-items: center;
      justify-content: space-around;
      background-color: rgba(0,0,0,0.2);
      padding: 0.8rem;
      border-radius: 8px;
    }
    .transcendence-slots {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .transcendence-slot {
      width: 100px;
      height: 120px;
    }
    .transcendence-symbol {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--border-color);
      padding: 0 0.4rem;
    }
    .transcendence-result-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.4rem;
      text-align: center;
      min-width: 100px;
    }
    .transcendence-result-area .item-card {
        cursor: default;
    }
    .transcendence-result-area .item-card:hover {
        background-color: var(--secondary-bg);
    }
    .transcendence-result-area .button {
        padding: 0.4rem 0.8rem;
        font-size: 0.75rem;
    }
    .transcendence-result-area p { margin: 0; font-size: 0.75rem; font-weight: bold; }

    .inventory-grid.transcendence-mode .item-card.unselectable {
      opacity: 0.4;
      cursor: not-allowed;
      background-color: var(--primary-bg);
    }
    .inventory-grid.transcendence-mode .item-card.unselectable:hover {
        box-shadow: none;
    }
    .inventory-grid.transcendence-mode .item-card.selected {
      border-color: var(--skill-learnable-bg);
      box-shadow: 0 0 8px var(--skill-learnable-bg);
    }


    /* Skill Tree Styles */
    .skill-node {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(0,0,0,0.2);
        padding: 0.6rem 0.8rem;
        border-radius: 8px;
        border-left: 4px solid var(--skill-locked-bg);
        transition: background-color 0.3s;
    }
    .skill-node.learnable { border-color: var(--skill-learnable-bg); }
    .skill-node.learned { border-color: var(--skill-learned-bg); }
    .skill-node.maxed { border-color: var(--skill-maxed-bg); }

    .skill-node.locked {
        opacity: 0.6;
    }

    .skill-info {
        text-align: left;
        flex-grow: 1;
    }
    .skill-info h3 {
        margin: 0 0 0.2rem;
        font-size: 0.9rem;
    }
    .skill-info p {
        margin: 0 0 0.2rem;
        font-size: 0.75rem;
    }
    .skill-info small {
        font-size: 0.65rem;
        color: var(--border-color);
    }
    .learn-skill-btn {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
        min-width: 70px;
    }
    .skill-node.learnable .learn-skill-btn {
        background-color: var(--skill-learnable-bg);
        color: #2c3e50;
    }


    /* Quest Screen Styles */
    .quest-screen h1 {
        margin-bottom: 0.8rem;
    }
    .quest-item {
        display: flex;
        justify-content: space-between;
        align-items: stretch;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        padding: 0.8rem;
        gap: 0.8rem;
        transition: background-color 0.3s;
    }
    .quest-info {
        flex-grow: 1;
        text-align: left;
    }
    .quest-description {
        font-weight: bold;
        font-size: 0.9rem;
        margin: 0 0 0.4rem 0;
    }
    .quest-progress-bar-container {
        height: 10px;
        background-color: var(--primary-bg);
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 0.2rem;
    }
    .quest-progress-bar {
        height: 100%;
        background-color: var(--xp-bar-color);
        transition: width 0.3s;
    }
    .quest-progress-text {
        font-size: 0.65rem;
        text-align: right;
        margin: 0 0 0.4rem 0;
        color: var(--border-color);
    }
    .quest-reward {
        font-size: 0.75rem;
        margin: 0;
        font-weight: bold;
    }
    .quest-action {
        display: flex;
        align-items: center;
    }
    .quest-action .button {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
    }

    /* Rarity Colors */
    .rarity-common { color: var(--rarity-common); }
    .rarity-uncommon { color: var(--rarity-uncommon); }
    .rarity-rare { color: var(--rarity-rare); }
    .rarity-legendary { color: var(--rarity-legendary); }
    .rarity-mythic { color: var(--rarity-mythic); }
    .rarity-ultimate { color: var(--rarity-ultimate); }
    .rarity-eternal { color: var(--rarity-eternal); text-shadow: 0 0 5px var(--rarity-eternal); }

    #message-log .rarity-uncommon, #message-log .rarity-rare, #message-log .rarity-legendary, #message-log .rarity-mythic, #message-log .rarity-ultimate, #message-log .rarity-eternal {
        font-weight: bold;
    }
    
    #creator-credit {
        position: fixed;
        top: 10px;
        right: 10px;
        font-size: 0.7rem;
        color: var(--border-color);
        z-index: 1000;
    }

    /* Rebirth screen styles */
    .rebirth-info {
        background: rgba(0,0,0,0.2);
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1rem;
        width: 100%;
        box-sizing: border-box;
        transition: background-color 0.3s;
    }
    .rebirth-info p {
        margin: 0.5rem 0;
        font-size: 0.9rem;
    }
    .rebirth-points {
        color: var(--rebirth-color);
        font-weight: bold;
    }
    .rebirth-upgrade-info p {
        font-size: 0.8rem;
        margin: 0;
    }

    /* Guide Button & Modal Styles */
    #guide-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 60px;
        height: 60px;
        background-color: var(--skill-learnable-bg);
        color: var(--primary-bg);
        border-radius: 50%;
        border: none;
        font-size: 2rem;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
        transition: transform 0.2s;
    }
    #guide-button:hover {
        transform: scale(1.1);
    }

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        z-index: 2000;
        padding: 1rem;
        box-sizing: border-box;
    }

    .modal-content {
        background-color: var(--primary-bg);
        padding: 1.5rem;
        border-radius: 12px;
        width: 100%;
        max-width: 500px;
        height: 90%;
        max-height: 700px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }

    .modal-content h2 {
        color: var(--xp-bar-color);
        text-align: center;
        margin-top: 0;
        margin-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.5rem;
    }

    .modal-body {
        overflow-y: auto;
        flex-grow: 1;
    }

    .modal-body h3 {
        color: var(--skill-learnable-bg);
        margin-top: 1rem;
        margin-bottom: 0.5rem;
    }

    .modal-body p, .modal-body li {
        font-size: 0.85rem;
        line-height: 1.6;
        color: var(--text-color);
    }
    .modal-body ul {
        padding-left: 1.2rem;
    }

    .modal-footer {
        margin-top: 1rem;
        text-align: center;
    }

    /* Dungeon Map Styles */
    .dungeon-map {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      margin-bottom: 0.8rem;
      padding: 0.4rem;
      background-color: rgba(0,0,0,0.2);
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
      position: relative;
    }
    .map-node {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: var(--secondary-bg);
      border: 2px solid var(--border-color);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 10px;
      font-weight: bold;
      transition: all 0.3s;
      z-index: 1;
    }
    .map-node:not(:first-child)::before {
      content: '';
      position: absolute;
      right: 100%;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 2px;
      background-color: var(--border-color);
      z-index: 0;
    }
    .map-node.cleared {
      background-color: var(--button-disabled-bg);
      border-color: var(--secondary-bg);
    }
    .map-node.cleared::before {
        background-color: var(--button-disabled-bg);
    }
    .map-node.current {
      background-color: var(--player-hp-color);
      border-color: var(--text-color);
      transform: scale(1.2);
      box-shadow: 0 0 8px var(--player-hp-color);
    }
    .map-node.boss {
      background-color: var(--monster-hp-color);
      border-color: #ff7675;
      transform: scale(1.3);
    }
    .map-node.boss.current {
        transform: scale(1.5);
        box-shadow: 0 0 10px var(--monster-hp-color);
    }

    /* Name Change Icon Styles */
    .name-change-icon {
        cursor: pointer;
        font-size: 1rem;
        margin-left: 0.4rem;
        display: inline-block;
        transition: transform 0.2s;
    }
    .name-change-icon:hover {
        transform: scale(1.2);
    }

    /* Item Lock & Batch Disenchant Styles */
    .lock-icon {
        position: absolute;
        top: 4px;
        right: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        z-index: 2;
        background: rgba(0,0,0,0.4);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: transform 0.2s;
    }
    .lock-icon:hover {
        transform: scale(1.2);
    }

    .item-card.locked {
        border-color: var(--skill-learnable-bg);
        box-shadow: 0 0 4px var(--skill-learnable-bg);
    }

    .batch-disenchant-container {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        width: 100%;
    }
    .batch-disenchant-filters {
        background: rgba(0,0,0,0.2);
        padding: 0.8rem;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
    }
    .batch-disenchant-filters h3 {
        margin: 0 0 0.4rem 0;
        font-size: 1rem;
        text-align: center;
    }
    .filter-checkbox-group {
        display: flex;
        gap: 1rem;
        justify-content: center;
    }
    .filter-checkbox-group label {
        display: flex;
        align-items: center;
        gap: 0.3rem;
        font-size: 0.8rem;
        cursor: pointer;
        background: var(--secondary-bg);
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        border: 1px solid var(--border-color);
    }
    .filter-checkbox-group input:checked + span {
        color: var(--skill-learnable-bg);
        font-weight: bold;
    }
    .batch-disenchant-summary {
        background: rgba(0,0,0,0.2);
        padding: 0.8rem;
        border-radius: 8px;
        text-align: left;
    }
    .batch-disenchant-summary p {
        margin: 0.2rem 0;
        font-size: 0.8rem;
    }
    .batch-disenchant-summary strong {
        color: var(--xp-bar-color);
    }
    #batch-disenchant-button {
        background-color: var(--disenchant-color);
        margin-top: 0.4rem;
    }
    #batch-disenchant-button:hover {
        background-color: #8e44ad;
    }
    input[type="checkbox"] {
        display: none;
    }

    /* Permanent UI Styles */
    #game-reset-button {
        position: fixed;
        top: 10px;
        left: 10px;
        background-color: var(--monster-hp-color);
        color: white;
        border: none;
        border-radius: 4px;
        padding: 0.3rem 0.6rem;
        font-size: 0.7rem;
        font-weight: bold;
        cursor: pointer;
        z-index: 1001;
        transition: background-color 0.2s;
    }
    #game-reset-button:hover {
        background-color: #c0392b;
    }

    #rank-display {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background-color: rgba(0,0,0,0.6);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        padding: 0.5rem 1rem;
        z-index: 1001;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    #rank-display span:first-child {
        font-size: 0.8rem;
        color: var(--text-color);
    }
    #rank-display span:last-child {
        font-size: 1.3rem;
        font-weight: bold;
    }
    .rank-C { color: #bdc3c7; }
    .rank-B { color: var(--rarity-uncommon); }
    .rank-A { color: var(--rarity-rare); }
    .rank-S { color: var(--rarity-legendary); }
    .rank-SS { color: var(--rarity-mythic); }
    .rank-SSS { color: var(--rarity-eternal); text-shadow: 0 0 8px var(--rarity-eternal); }
  </style>
</head>
<body>
  <div id="creator-credit">제작자:한국인이라면</div>
  <div id="root"></div>
  <script type="module">
    /**
     * @license
     * SPDX-License-Identifier: Apache-2.0
     */

    const root = document.getElementById('root');
    if (!root) {
      throw new Error('Could not find root element');
    }

    // --- Game Constants ---
    const CRIT_MULTIPLIER = 1.5;
    const POTION_HEAL_PERCENT = 0.6;
    const POTION_COST = 50;
    const ATTACK_POTION_COST = 100;
    const DEFEAT_GOLD_PENALTY = 0.1;
    const ESCAPE_GOLD_PENALTY = 0.05;
    const CLASS_CHANGE_COST = 5000;
    const REBIRTH_LEVEL_REQ = 30;
    const GACHA_COST_SINGLE = 200;
    const GACHA_COST_TEN = 1800;
    const INVENTORY_LIMIT = 100;
    const SURVIVAL_ENTRY_COST = 400;
    const SURVIVAL_REWARD_MULTIPLIER = 120;

    const STATUS_EFFECT_DEFINITIONS = {
        poison: { name: '독', icon: '☠️' },
        burn: { name: '화상', icon: '🔥' },
        stun: { name: '기절', icon: '💫' },
        weaken: { name: '약화', icon: '↓' },
        vulnerable: { name: '취약', icon: '🛡️💥' },
    };

    const CLASSES = {
        '전사': { emoji: '🛡️', baseHp: 160, baseAtk: 12, baseDef: 4, weapon: '검', crit: 0.1, evade: 0.05 },
        '마법사': { emoji: '🔥', baseHp: 110, baseAtk: 16, baseDef: 0, weapon: '지팡이', crit: 0.1, evade: 0.05 },
        '암살자': { emoji: '💨', baseHp: 120, baseAtk: 14, baseDef: 1, weapon: '단검', crit: 0.30, evade: 0.20 },
        '궁수': { emoji: '🏹', baseHp: 115, baseAtk: 15, baseDef: 2, weapon: '활', crit: 0.20, evade: 0.10 },
    };

    const DIFFICULTY_SETTINGS = {
        '쉬움': { monsterHpMod: 0.8, monsterAtkMod: 0.8, startGold: 50, startPotions: 5, startAttackPotions: 2, rewardMod: 0.8 },
        '보통': { monsterHpMod: 1.05, monsterAtkMod: 1.05, startGold: 20, startPotions: 2, startAttackPotions: 1, rewardMod: 1.0 },
        '어려움': { monsterHpMod: 1.35, monsterAtkMod: 1.35, startGold: 0, startPotions: 1, startAttackPotions: 0, rewardMod: 1.25 },
        '하드코어': { monsterHpMod: 2.0, monsterAtkMod: 2.0, startGold: 0, startPotions: 0, startAttackPotions: 0, rewardMod: 2.0, isHardcore: true },
    };

    const ULTIMATE_SKILLS = {
        '전사': {
            id: 'w_ultimate',
            name: '철옹성',
            cooldown: 5,
            description: level => `공격력의 200% 피해를 주고, ${2+level}턴 동안 방어력이 ${30 + level * 5}% 증가하는 '철벽' 효과를 얻습니다.`,
            effect: level => ({
                damageMultiplier: 2.0,
                buff: { name: '철벽', stat: 'defense', value: 0.30 + level * 0.05, duration: 2 + level, isPercent: true },
                message: '🛡️ 강철의 의지! [철옹성]을 발동하여 적에게 참격을 날리고, 몸이 강철처럼 단단해졌다!'
            })
        },
        '마법사': {
            id: 'm_ultimate',
            name: '메테오',
            cooldown: 5,
            description: level => `공격력의 ${250 + level*20}% 피해를 입히고, 3턴간 턴마다 ${10 + level * 3}의 화상 피해를 줍니다.`,
            effect: level => ({
                damageMultiplier: 2.5 + level * 0.2,
                statusEffect: { type: 'burn', chance: 1.0, duration: 3, potency: 10 + level * 3 },
                message: '☄️ 하늘이 붉게 물든다! 거대한 [메테오]가 떨어져 적을 불태우고 지면을 녹인다!'
            })
        },
        '암살자': {
            id: 'r_ultimate',
            name: '그림자 습격',
            cooldown: 5,
            description: level => `공격력의 ${180 + level*10}% 피해를 2번 입히고, 3턴간 턴마다 ${8 + level * 2}의 독 피해를 줍니다.`,
            effect: level => ({
                damageMultiplier: 1.8 + level * 0.1, // This is per hit
                hits: 2,
                statusEffect: { type: 'poison', chance: 1.0, duration: 3, potency: 8 + level * 2 },
                message: '💨 어둠 속에서 번뜩이는 칼날! [그림자 습격]으로 적의 배후를 2회 강타하고 맹독을 주입했다!'
            })
        },
        '궁수': {
            id: 'a_ultimate',
            name: '집중 사격',
            cooldown: 5,
            description: level => `공격력의 ${220 + level*15}% 피해를 입히고, 다음 2턴간 치명타 확률이 ${15 + level*5}% 증가합니다.`,
            effect: level => ({
                damageMultiplier: 2.2 + level * 0.15,
                buff: { name: '집중', stat: 'critChance', value: 0.15 + level * 0.05, duration: 2, isPercent: false },
                message: '🏹 숨을 멈추고 시위를 당긴다! [집중 사격]이 적의 급소를 꿰뚫었다!'
            })
        },
    };
    
    const ULTIMATE_SKILLS_2 = {
        '전사': {
            id: 'w_ultimate_2',
            name: '분쇄',
            cooldown: 6,
            description: level => `공격력의 250% 피해를 주고, 2턴간 적을 [취약] 상태로 만들어 받는 피해를 ${20 + level * 5}% 증가시킵니다.`,
            effect: level => ({
                damageMultiplier: 2.5,
                statusEffect: { type: 'vulnerable', chance: 1.0, duration: 2, potency: 0.20 + level * 0.05 },
                message: '땅이 흔들린다! [분쇄]의 일격이 적의 방어를 산산조각냈다!'
            })
        },
        '마법사': {
            id: 'm_ultimate_2',
            name: '서리 고리',
            cooldown: 6,
            description: level => `공격력의 120% 피해를 주고, ${70 + level * 10}% 확률로 1턴간 적을 [기절]시킵니다.`,
            effect: level => ({
                damageMultiplier: 1.2,
                statusEffect: { type: 'stun', chance: 0.7 + level * 0.1, duration: 1, potency: 0 },
                message: '냉기가 휘몰아친다! [서리 고리]가 적을 그 자리에 얼어붙게 했다!'
            })
        },
        '암살자': {
            id: 'r_ultimate_2',
            name: '연막탄',
            cooldown: 6,
            description: level => `즉시 [회피] 상태가 되어 다음 2턴간 회피 확률이 ${50 + level*10}% 증가하고, 다음 1회의 공격이 반드시 치명타로 적중합니다.`,
            effect: level => ({
                buff: { name: '은신', stat: 'evadeChance', value: 0.50 + level * 0.1, duration: 2, isPercent: false },
                buff2: { name: '확정 치명타', duration: 1, isPercent: false, effect: { guaranteedCrit: true } },
                message: '연기 속으로 사라진다! [연막탄]을 사용해, 다음 공격을 준비한다!'
            })
        },
        '궁수': {
            id: 'a_ultimate_2',
            name: '화살비',
            cooldown: 6,
            description: level => `공격력의 100% 피해를 3번 입히고, ${50 + level*10}% 확률로 2턴간 적을 [약화] 상태로 만듭니다.`,
            effect: level => ({
                damageMultiplier: 1.0, // Per hit
                hits: 3,
                statusEffect: { type: 'weaken', chance: 0.5 + level * 0.1, duration: 2, potency: 0.15 },
                message: '🎯 하늘이 화살로 뒤덮인다! [화살비]가 적진을 초토화시킨다!'
            })
        },
    };

    const ULTIMATE_SKILLS_3 = {
        '전사': {
            id: 'w_ultimate_3',
            name: '광전사의 포효',
            cooldown: 7,
            description: level => `3턴간 공격력이 ${50 + level * 10}% 증가하지만 방어력이 50% 감소합니다.`,
            effect: level => ({
                buff: { name: '광폭화', stat: 'attackPower', value: 0.50 + level * 0.1, duration: 3, isPercent: true },
                debuff: { name: '방어 약화', stat: 'defense', value: -0.5, duration: 3, isPercent: true },
                message: '크아아아! [광전사의 포효]와 함께 핏빛 광기가 온몸을 휩싼다!'
            })
        },
        '마법사': {
            id: 'm_ultimate_3',
            name: '연쇄 번개',
            cooldown: 7,
            description: level => `적에게 공격력의 150% 피해를 주고, ${2 + level}번 튕기며 피해량이 25%씩 감소합니다.`,
            effect: level => ({
                hits: 3 + level,
                initialDamageMultiplier: 1.5,
                damageFalloff: 0.75, // Each bounce deals 75% of the previous one's damage
                message: '파지지직! [연쇄 번개]가 적들 사이를 가르며 타오른다!'
            })
        },
        '암살자': {
            id: 'r_ultimate_3',
            name: '심장 찌르기',
            cooldown: 7,
            description: level => `공격력의 300% 피해를 줍니다. 적의 잃은 체력 1%당 피해량이 ${0.5 + level * 0.1}%씩 증가합니다.`,
            effect: level => ({
                damageMultiplier: 3.0,
                executeMultiplier: 0.005 + level * 0.001,
                message: '급소를 노린 일격! [심장 찌르기]가 적의 숨통을 끊으려 한다!'
            })
        },
        '궁수': {
            id: 'a_ultimate_3',
            name: '꿰뚫는 화살',
            cooldown: 7,
            description: level => `공격력의 350% 피해를 주고, 적의 방어력을 ${25 + level * 5}% 무시합니다.`,
            effect: level => ({
                damageMultiplier: 3.5,
                defensePenetration: 0.25 + level * 0.05,
                message: '모든 것을 꿰뚫는 한 발! [꿰뚫는 화살]이 적의 방어를 무력화시킨다!'
            })
        },
    };

    const SKILL_DATA = {
        '전사': {
            'w_hp_1': { id: 'w_hp_1', name: '강건한 육체', description: level => `최대 생명력이 레벨당 15씩 증가합니다. (총 +${level*15})`, cost: level => 100 * (level + 1), prerequisites: [], effects: level => [{ stat: 'maxHp', value: 15 * level }] },
            'w_atk_1': { id: 'w_atk_1', name: '무기 연마', description: level => `공격력이 레벨당 2씩 증가합니다. (총 +${level*2})`, cost: level => 120 * (level + 1), prerequisites: [], effects: level => [{ stat: 'attackPower', value: 2 * level }] },
            'w_def_1': { id: 'w_def_1', name: '방어구 강화', description: level => `방어력이 레벨당 1씩 증가합니다. (총 +${level*1})`, cost: level => 150 * (level + 1), prerequisites: [{id: 'w_hp_1', level: 1}], effects: level => [{ stat: 'defense', value: 1 * level }] },
            'w_ult_1': { id: 'w_ult_1', name: '철옹성 강화', description: level => `철옹성의 방어력 증가 효과가 레벨당 5%씩 추가됩니다.`, cost: level => 500 * (level + 1), prerequisites: [{id: 'w_def_1', level: 2}], effects: level => [] },
            'w_ult_2': { id: 'w_ult_2', name: '분쇄', maxLevel: 3, description: ULTIMATE_SKILLS_2['전사'].description, cost: level => 2000 * (level + 1), prerequisites: [{id: 'w_ult_1', level: 1}], effects: level => [] },
            'w_ult_3': { id: 'w_ult_3', name: '광전사의 포효', maxLevel: 3, description: ULTIMATE_SKILLS_3['전사'].description, cost: level => 5000 * (level + 1), prerequisites: [{id: 'w_ult_2', level: 1}], effects: level => [] },
        },
        '마법사': {
            'm_atk_1': { id: 'm_atk_1', name: '비전력 증폭', description: level => `공격력이 레벨당 3씩 증가합니다. (총 +${level*3})`, cost: level => 120 * (level + 1), prerequisites: [], effects: level => [{ stat: 'attackPower', value: 3 * level }] },
            'm_hp_1': { id: 'm_hp_1', name: '원소 보호막', description: level => `최대 생명력이 레벨당 10씩 증가합니다. (총 +${level*10})`, cost: level => 100 * (level + 1), prerequisites: [], effects: level => [{ stat: 'maxHp', value: 10 * level }] },
            'm_burn_1': { id: 'm_burn_1', name: '타오르는 불꽃', description: level => `모든 화상 피해가 레벨당 10%씩 증가합니다.`, cost: level => 300 * (level + 1), prerequisites: [{id: 'm_atk_1', level: 1}], effects: level => [] },
            'm_ult_1': { id: 'm_ult_1', name: '메테오 강화', description: level => `메테오의 기본 피해량이 레벨당 10%씩 증가합니다.`, cost: level => 500 * (level + 1), prerequisites: [{id: 'm_burn_1', level: 1}], effects: level => [] },
            'm_ult_2': { id: 'm_ult_2', name: '서리 고리', maxLevel: 3, description: ULTIMATE_SKILLS_2['마법사'].description, cost: level => 2000 * (level + 1), prerequisites: [{id: 'm_ult_1', level: 1}], effects: level => [] },
            'm_ult_3': { id: 'm_ult_3', name: '연쇄 번개', maxLevel: 3, description: ULTIMATE_SKILLS_3['마법사'].description, cost: level => 5000 * (level + 1), prerequisites: [{id: 'm_ult_2', level: 1}], effects: level => [] },
        },
        '암살자': {
            'r_crit_1': { id: 'r_crit_1', name: '급소 파악', description: level => `치명타 확률이 레벨당 1%씩 증가합니다. (총 +${level}%)`, cost: level => 150 * (level + 1), prerequisites: [], effects: level => [{ stat: 'critChance', value: 0.01 * level }] },
            'r_evade_1': { id: 'r_evade_1', name: '날렵한 몸놀림', description: level => `회피 확률이 레벨당 1%씩 증가합니다. (총 +${level}%)`, cost: level => 150 * (level + 1), prerequisites: [], effects: level => [{ stat: 'evadeChance', value: 0.01 * level }] },
            'r_atk_1': { id: 'r_atk_1', name: '단검 연마', description: level => `공격력이 레벨당 2씩 증가합니다. (총 +${level*2})`, cost: level => 120 * (level + 1), prerequisites: [{id: 'r_crit_1', level: 1}], effects: level => [{ stat: 'attackPower', value: 2 * level }] },
            'r_execute_1': { id: 'r_execute_1', name: '마무리 일격', maxLevel: 1, description: level => `체력이 25% 이하인 적에게 20%의 추가 피해를 입힙니다.`, cost: level => 1000, prerequisites: [{id: 'r_atk_1', level: 2}], effects: level => [] },
            'r_ult_2': { id: 'r_ult_2', name: '연막탄', maxLevel: 3, description: ULTIMATE_SKILLS_2['암살자'].description, cost: level => 2000 * (level + 1), prerequisites: [{id: 'r_execute_1', level: 1}], effects: level => [] },
            'r_ult_3': { id: 'r_ult_3', name: '심장 찌르기', maxLevel: 3, description: ULTIMATE_SKILLS_3['암살자'].description, cost: level => 5000 * (level + 1), prerequisites: [{id: 'r_ult_2', level: 1}], effects: level => [] },
        },
        '궁수': {
            'a_atk_1': { id: 'a_atk_1', name: '명궁의 마음', description: level => `공격력이 레벨당 2씩 증가합니다. (총 +${level*2})`, cost: level => 120 * (level + 1), prerequisites: [], effects: level => [{ stat: 'attackPower', value: 2 * level }] },
            'a_crit_1': { id: 'a_crit_1', name: '매의 눈', description: level => `치명타 확률이 레벨당 1%씩 증가합니다. (총 +${level}%)`, cost: level => 150 * (level + 1), prerequisites: [], effects: level => [{ stat: 'critChance', value: 0.01 * level }] },
            'a_crit_dmg_1': { id: 'a_crit_dmg_1', name: '약점 간파', description: level => `치명타 피해량이 레벨당 5%씩 증가합니다. (총 +${level*5}%)`, cost: level => 200 * (level + 1), prerequisites: [{id: 'a_crit_1', level: 1}], effects: level => [{ stat: 'critDamage', value: 0.05 * level }] },
            'a_ult_1': { id: 'a_ult_1', name: '집중 사격 강화', description: level => `집중 사격의 치명타 확률 증가 효과가 레벨당 2%씩 추가됩니다.`, cost: level => 500 * (level + 1), prerequisites: [{id: 'a_crit_dmg_1', level: 2}], effects: level => [] },
            'a_ult_2': { id: 'a_ult_2', name: '화살비', maxLevel: 3, description: ULTIMATE_SKILLS_2['궁수'].description, cost: level => 2000 * (level + 1), prerequisites: [{id: 'a_ult_1', level: 1}], effects: level => [] },
            'a_ult_3': { id: 'a_ult_3', name: '꿰뚫는 화살', maxLevel: 3, description: ULTIMATE_SKILLS_3['궁수'].description, cost: level => 5000 * (level + 1), prerequisites: [{id: 'a_ult_2', level: 1}], effects: level => [] },
        },
    };

    const ITEM_DATABASE = [
        // Common
        { id: 101, name: "녹슨 검", type: 'weapon', stats: { attackPower: 2 }, rarity: 'common', cost: 25, classRestriction: ['전사'] },
        { id: 102, name: "해진 로브", type: 'armor', stats: { maxHp: 10 }, rarity: 'common', cost: 25, classRestriction: ['마법사'] },
        { id: 103, name: "가죽 갑옷", type: 'armor', stats: { defense: 1, evadeChance: 0.01 }, rarity: 'common', cost: 25, classRestriction: ['암살자'] },
        { id: 104, name: "나무 지팡이", type: 'weapon', stats: { attackPower: 3 }, rarity: 'common', cost: 25, classRestriction: ['마법사'] },
        { id: 105, name: "작은 단검", type: 'weapon', stats: { attackPower: 1, critChance: 0.02 }, rarity: 'common', cost: 25, classRestriction: ['암살자'] },
        { id: 106, name: "판금 조끼", type: 'armor', stats: { defense: 2 }, rarity: 'common', cost: 25, classRestriction: ['전사'] },
        { id: 107, name: "짧은 활", type: 'weapon', stats: { attackPower: 2, critChance: 0.01 }, rarity: 'common', cost: 25, classRestriction: ['궁수'] },
        { id: 108, name: "사냥꾼 조끼", type: 'armor', stats: { defense: 1, evadeChance: 0.02 }, rarity: 'common', cost: 25, classRestriction: ['궁수'] },

        // Uncommon
        { id: 201, name: "강철 검", type: 'weapon', stats: { attackPower: 5 }, rarity: 'uncommon', cost: 100, classRestriction: ['전사'] },
        { id: 202, name: "마법사의 로브", type: 'armor', stats: { maxHp: 20, attackPower: 2 }, rarity: 'uncommon', cost: 100, classRestriction: ['마법사'] },
        { id: 203, name: "그림자 사슬 갑옷", type: 'armor', stats: { defense: 2, maxHp: 10, evadeChance: 0.03 }, rarity: 'uncommon', cost: 100, classRestriction: ['암살자'] },
        { id: 204, name: "보석 박힌 지팡이", type: 'weapon', stats: { attackPower: 6 }, rarity: 'uncommon', cost: 100, classRestriction: ['마법사'] },
        { id: 205, name: "암살자의 단검", type: 'weapon', stats: { attackPower: 3, critChance: 0.05 }, rarity: 'uncommon', cost: 100, classRestriction: ['암살자'] },
        { id: 206, name: "강철 갑옷", type: 'armor', stats: { defense: 4, maxHp: 25 }, rarity: 'uncommon', cost: 100, classRestriction: ['전사'] },
        { id: 207, name: "장궁", type: 'weapon', stats: { attackPower: 5, critChance: 0.02 }, rarity: 'uncommon', cost: 100, classRestriction: ['궁수'] },
        { id: 208, name: "정찰병의 갑옷", type: 'armor', stats: { defense: 2, evadeChance: 0.03, maxHp: 15 }, rarity: 'uncommon', cost: 100, classRestriction: ['궁수'] },
        
        // Rare
        { id: 301, name: "룬 블레이드", type: 'weapon', stats: { attackPower: 8, critChance: 0.03 }, rarity: 'rare', cost: 300, classRestriction: ['전사'] },
        { id: 302, name: "대마법사의 로브", type: 'armor', stats: { maxHp: 30, attackPower: 5, defense: 1 }, rarity: 'rare', cost: 300, classRestriction: ['마법사'] },
        { id: 303, name: "기사의 갑옷", type: 'armor', stats: { defense: 5, maxHp: 40 }, rarity: 'rare', cost: 300, classRestriction: ['전사'] },
        { id: 304, name: "현자의 지팡이", type: 'weapon', stats: { attackPower: 10, maxHp: 20 }, rarity: 'rare', cost: 300, classRestriction: ['마법사'] },
        { id: 305, name: "독사의 송곳니", type: 'weapon', stats: { attackPower: 7, critChance: 0.07 }, rarity: 'rare', cost: 300, classRestriction: ['암살자'] },
        { id: 306, name: "밤의 장막 갑옷", type: 'armor', stats: { defense: 3, evadeChance: 0.05, maxHp: 20 }, rarity: 'rare', cost: 300, classRestriction: ['암살자'] },
        { id: 307, name: "사냥꾼의 활", type: 'weapon', stats: { attackPower: 8, critChance: 0.05 }, rarity: 'rare', cost: 300, classRestriction: ['궁수'] },
        { id: 308, name: "바람의 가죽 갑옷", type: 'armor', stats: { defense: 4, evadeChance: 0.04, critChance: 0.02 }, rarity: 'rare', cost: 300, classRestriction: ['궁수'] },
        
        // Legendary
        { id: 401, name: "용살자의 대검", type: 'weapon', stats: { attackPower: 20, maxHp: 50 }, rarity: 'legendary', cost: 5000, classRestriction: ['전사'] },
        { id: 402, name: "아크메이지의 지팡이", type: 'weapon', stats: { attackPower: 25 }, rarity: 'legendary', cost: 5000, classRestriction: ['마법사'] },
        { id: 403, name: "월광의 단검", type: 'weapon', stats: { attackPower: 15, critChance: 0.10, evadeChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['암살자'] },
        { id: 404, name: "수호신의 갑주", type: 'armor', stats: { defense: 10, maxHp: 100 }, rarity: 'legendary', cost: 5000, classRestriction: ['전사', '암살자', '마법사', '궁수'] },
        { id: 405, name: "폭풍의 활", type: 'weapon', stats: { attackPower: 18, critChance: 0.08 }, rarity: 'legendary', cost: 5000, classRestriction: ['궁수'] },

        // Mythic
        { id: 601, name: "천벌", type: 'weapon', stats: { attackPower: 35, critChance: 0.10 }, rarity: 'mythic', cost: 99999, classRestriction: ['전사'], isGachaOnly: true },
        { id: 602, name: "종말의 서", type: 'weapon', stats: { attackPower: 40, maxHp: 50 }, rarity: 'mythic', cost: 99999, classRestriction: ['마법사'], isGachaOnly: true },
        { id: 603, name: "밤의 파편", type: 'weapon', stats: { attackPower: 25, critChance: 0.15, evadeChance: 0.08 }, rarity: 'mythic', cost: 99999, classRestriction: ['암살자'], isGachaOnly: true },
        { id: 604, name: "세계수의 심장", type: 'armor', stats: { defense: 15, maxHp: 150, evadeChance: 0.05 }, rarity: 'mythic', cost: 99999, classRestriction: ['전사', '암살자', '마법사', '궁수'], isGachaOnly: true },
        { id: 605, name: "천공의 분노", type: 'weapon', stats: { attackPower: 30, critChance: 0.15 }, rarity: 'mythic', cost: 99999, classRestriction: ['궁수'], isGachaOnly: true },

        // Ultimate
        { id: 701, name: "궁극의 파멸검", type: 'weapon', stats: { attackPower: 50, critDamage: 0.15 }, rarity: 'ultimate', cost: 999999, classRestriction: ['전사'], isGachaOnly: true },
        { id: 702, name: "태초의 지혜", type: 'weapon', stats: { attackPower: 60, maxHp: 100 }, rarity: 'ultimate', cost: 999999, classRestriction: ['마법사'], isGachaOnly: true },
        { id: 703, name: "시간 왜곡 단검", type: 'weapon', stats: { attackPower: 35, critChance: 0.1, evadeChance: 0.1 }, rarity: 'ultimate', cost: 999999, classRestriction: ['암살자'], isGachaOnly: true },
        { id: 704, name: "별의 노래", type: 'weapon', stats: { attackPower: 45, critChance: 0.20 }, rarity: 'ultimate', cost: 999999, classRestriction: ['궁수'], isGachaOnly: true },
        { id: 705, name: "창조신의 갑주", type: 'armor', stats: { defense: 25, maxHp: 250, evadeChance: 0.05 }, rarity: 'ultimate', cost: 999999, classRestriction: ['전사', '암살자', '마법사', '궁수'], isGachaOnly: true },

        // Eternal
        { id: 805, name: "영원의 성의", type: 'armor', stats: { defense: 40, maxHp: 400, evadeChance: 0.08 }, rarity: 'eternal', cost: 9999999, classRestriction: ['전사', '암살자', '마법사', '궁수'], isGachaOnly: true },

        // Accessories
        { id: 501, name: "힘의 반지", type: 'accessory', stats: { attackPower: 5 }, rarity: 'rare', cost: 300, classRestriction: ['전사', '마법사', '암살자', '궁수'] },
        { id: 502, name: "활력의 부적", type: 'accessory', stats: { maxHp: 50 }, rarity: 'rare', cost: 300, classRestriction: ['전사', '마법사', '암살자', '궁수'] },
        { id: 503, "name": "수호의 징표", type: 'accessory', stats: { defense: 5 }, rarity: 'rare', cost: 300, classRestriction: ['전사', '마법사', '암살자', '궁수'] },
        { id: 504, "name": "필살의 반지", type: 'accessory', stats: { critChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['전사', '마법사', '암살자', '궁수'] },
        { id: 505, "name": "그림자 망토", type: 'accessory', stats: { evadeChance: 0.05 }, rarity: 'legendary', cost: 5000, classRestriction: ['전사', '마법사', '암살자', '궁수'] },
        { id: 506, "name": "현자의 돌", type: 'accessory', stats: { attackPower: 8, maxHp: 80 }, rarity: 'legendary', cost: 5000, classRestriction: ['전사', '마법사', '암살자', '궁수'] },
        { id: 507, name: "타이탄의 견갑", type: 'accessory', rarity: 'mythic', cost: 99999, stats: { maxHp: 120, defense: 10, attackPower: 10 }, classRestriction: ['전사', '암살자', '마법사', '궁수'] },
        { id: 508, name: "신속의 각반", type: 'accessory', rarity: 'mythic', cost: 99999, stats: { evadeChance: 0.08, critChance: 0.08 }, classRestriction: ['전사', '암살자', '마법사', '궁수'] },
        { id: 509, name: "전능의 눈", type: 'accessory', rarity: 'ultimate', cost: 999999, stats: { attackPower: 20, critChance: 0.1, critDamage: 0.1 }, classRestriction: ['전사', '암살자', '마법사', '궁수'], isGachaOnly: true },
        { id: 510, name: "불멸자의 심장", type: 'accessory', rarity: 'ultimate', cost: 999999, stats: { maxHp: 300, defense: 20 }, classRestriction: ['전사', '암살자', '마법사', '궁수'], isGachaOnly: true },

        // Relics
        { id: 901, name: "피의 성배", type: 'relic', rarity: 'legendary', cost: 7500, stats: { maxHp: 100, attackPower: 10 }, classRestriction: ['전사', '암살자', '마법사', '궁수'] },
        { id: 902, name: "폭풍의 눈", type: 'relic', rarity: 'mythic', cost: 99999, stats: { critChance: 0.06, evadeChance: 0.06 }, classRestriction: ['전사', '암살자', '마법사', '궁수'], isGachaOnly: true },
        { id: 903, name: "고대 신의 조각상", type: 'relic', rarity: 'ultimate', cost: 999999, stats: { allStatsPercent: 0.05 }, classRestriction: ['전사', '암살자', '마법사', '궁수'], isGachaOnly: true },
        { id: 904, name: "창조의 근원", type: 'relic', rarity: 'eternal', cost: 9999999, stats: { attackPower: 25, defense: 25, maxHp: 250 }, classRestriction: ['전사', '암살자', '마법사', '궁수'], isGachaOnly: true },
    ];
    
    const ENCHANTMENT_POOL = {
        weapon: {
            common: [ { id: 'w_c_atk', description: '공격력 +3', effects: { attackPower: 3 } }, { id: 'w_c_crit', description: '치명타 +1%', effects: { critChance: 0.01 } } ],
            uncommon: [ { id: 'w_u_atk', description: '공격력 +6', effects: { attackPower: 6 } }, { id: 'w_u_crit', description: '치명타 +2%', effects: { critChance: 0.02 } } ],
            rare: [ { id: 'w_r_atk', description: '공격력 +10', effects: { attackPower: 10 } }, { id: 'w_r_crit', description: '치명타 +4%', effects: { critChance: 0.04 } } ],
            legendary: [ { id: 'w_l_atk', description: '공격력 +25', effects: { attackPower: 25 } }, { id: 'w_l_crit', description: '치명타 +8%', effects: { critChance: 0.08 } }, { id: 'w_l_all', description: '공격력 +10, 치명타 +3%', effects: { attackPower: 10, critChance: 0.03 } } ],
            mythic: [ { id: 'w_m_atk', description: '공격력 +40', effects: { attackPower: 40 } }, { id: 'w_m_crit', description: '치명타 +12%', effects: { critChance: 0.12 } }, { id: 'w_m_all', description: '모든 능력치 +5%', effects: { attackPowerPercent: 0.05, maxHpPercent: 0.05, defensePercent: 0.05 } } ],
            ultimate: [ { id: 'w_u_atk', description: '공격력 +60', effects: { attackPower: 60 } }, { id: 'w_u_crit_dmg', description: '치명타피해 +15%', effects: { critDamage: 0.15 } } ],
            eternal: [ { id: 'w_e_atk', description: '공격력 +100', effects: { attackPower: 100 } }, { id: 'w_e_all', description: '모든 능력치 +10%', effects: { attackPowerPercent: 0.1, maxHpPercent: 0.1, defensePercent: 0.1 } } ],
        },
        armor: {
            common: [ { id: 'a_c_hp', description: '최대 HP +15', effects: { maxHp: 15 } }, { id: 'a_c_def', description: '방어력 +2', effects: { defense: 2 } } ],
            uncommon: [ { id: 'a_u_hp', description: '최대 HP +30', effects: { maxHp: 30 } }, { id: 'a_u_def', description: '방어력 +4', effects: { defense: 4 } }, { id: 'a_u_evade', description: '회피 +1%', effects: { evadeChance: 0.01 } } ],
            rare: [ { id: 'a_r_hp', description: '최대 HP +50', effects: { maxHp: 50 } }, { id: 'a_r_def', description: '방어력 +7', effects: { defense: 7 } }, { id: 'a_r_evade', description: '회피 +2%', effects: { evadeChance: 0.02 } } ],
            legendary: [ { id: 'a_l_hp', description: '최대 HP +120', effects: { maxHp: 120 } }, { id: 'a_l_def', description: '방어력 +15', effects: { defense: 15 } }, { id: 'a_l_evade', description: '회피 +5%', effects: { evadeChance: 0.05 } } ],
            mythic: [ { id: 'a_m_hp', description: '최대 HP +200', effects: { maxHp: 200 } }, { id: 'a_m_def', description: '방어력 +25', effects: { defense: 25 } }, { id: 'a_m_all', description: '회피 +5%, 방어력 +15', effects: { evadeChance: 0.05, defense: 15 } } ],
            ultimate: [ { id: 'a_u_hp', description: '최대 HP +300', effects: { maxHp: 300 } }, { id: 'a_u_def', description: '방어력 +40', effects: { defense: 40 } } ],
            eternal: [ { id: 'a_e_hp_def', description: '최대 HP +500, 방어력 +50', effects: { maxHp: 500, defense: 50 } }, { id: 'a_e_evade_hp', description: '회피 +10%, 최대 HP +250', effects: { evadeChance: 0.1, maxHp: 250 } } ],
        },
        accessory: {
            rare: [ { id: 'ac_r_atk', description: '공격력 +8', effects: { attackPower: 8 } }, { id: 'ac_r_hp', description: '최대 HP +40', effects: { maxHp: 40 } } ],
            legendary: [ { id: 'ac_l_crit', description: '치명타 +3%', effects: { critChance: 0.03 } }, { id: 'ac_l_evade', description: '회피 +3%', effects: { evadeChance: 0.03 } }, { id: 'ac_l_all', description: '공격력 +5, 방어력 +5', effects: { attackPower: 5, defense: 5 } } ],
            mythic: [ { id: 'ac_m_all_stats', description: '모든 능력치 +10', effects: { attackPower: 10, defense: 10, maxHp: 50 }}, { id: 'ac_m_crit_evade', description: '치명타 +5%, 회피 +5%', effects: { critChance: 0.05, evadeChance: 0.05 }}],
            ultimate: [ { id: 'ac_u_all_stats', description: '모든 능력치 +20', effects: { attackPower: 20, defense: 20, maxHp: 100 }}, { id: 'ac_u_crit_dmg', description: '치명타피해 +10%', effects: { critDamage: 0.1 }} ],
        },
        relic: {
            legendary: [ { id: 're_l_atk', description: '공격력 +15', effects: { attackPower: 15 } }, { id: 're_l_hp', description: '최대 HP +120', effects: { maxHp: 120 } } ],
            mythic: [ { id: 're_m_crit_evade', description: '치명타 +4%, 회피 +4%', effects: { critChance: 0.04, evadeChance: 0.04 } }, { id: 're_m_def_hp', description: '방어력 +15, 최대 HP +100', effects: { defense: 15, maxHp: 100 } } ],
            ultimate: [ { id: 're_u_all_percent', description: '모든 능력치 +3%', effects: { allStatsPercent: 0.03 } }, { id: 're_u_crit_dmg', description: '치명타피해 +12%', effects: { critDamage: 0.12 } } ],
            eternal: [ { id: 're_e_all_flat', description: '공격력 +20, 방어력 +20, 최대 HP +200', effects: { attackPower: 20, defense: 20, maxHp: 200 } }, { id: 're_e_all_percent', description: '모든 능력치 +5%', effects: { allStatsPercent: 0.05 } } ],
        }
    };
    
    const PERMANENT_QUESTS_DATA = [
      { id: 'reach_level_10', type: 'REACH_LEVEL', description: '레벨 10 달성', target: 10, reward: { gold: 1000, stones: 10 } },
      { id: 'reach_level_20', type: 'REACH_LEVEL', description: '레벨 20 달성', target: 20, reward: { gold: 5000, stones: 25 } },
      { id: 'reach_level_30', type: 'REACH_LEVEL', description: '레벨 30 달성', target: 30, reward: { gold: 10000, dust: 50 } },
      { id: 'reach_level_50', type: 'REACH_LEVEL', description: '레벨 50 달성', target: 50, reward: { gold: 50000, stones: 100 } },
      { id: 'defeat_dragon', type: 'DEFEAT_BOSS', description: '드래곤 처치', targetName: '드래곤', target: 1, reward: { gold: 3000, potions: 5 } },
      { id: 'enhance_10', type: 'ENHANCE_SUCCESS', description: '장비 +10강 성공', target: 10, reward: { gold: 2000, dust: 100 } },
      { id: 'enhance_15', type: 'ENHANCE_SUCCESS', description: '장비 +15강 성공', target: 15, reward: { gold: 20000, stones: 150 } },
      { id: 'collect_gold_50k', type: 'COLLECT_GOLD', description: '총 50,000골드 수집', target: 50000, reward: { stones: 20, potions: 3 } },
      { id: 'collect_gold_250k', type: 'COLLECT_GOLD', description: '총 250,000골드 수집', target: 250000, reward: { gold: 10000, dust: 200 } },
      { id: 'first_rebirth', type: 'REBIRTH', description: '첫 환생 달성', target: 1, reward: { stones: 50, dust: 250 } },
      { id: 'rebirth_3', type: 'REBIRTH', description: '3회 환생 달성', target: 3, reward: { gold: 30000, stones: 100 } },
      { id: 'rebirth_5', type: 'REBIRTH', description: '5회 환생 달성', target: 5, reward: { gold: 100000, dust: 500 } },
      { id: 'transcend_1', type: 'TRANSCEND', description: '첫 초월 성공', target: 1, reward: { gold: 5000, stones: 20 } },
      { id: 'transcend_5', type: 'TRANSCEND', description: '초월 5단계 장비 제작', target: 5, reward: { gold: 50000, dust: 300 } },
      { id: 'liberation', type: 'LIBERATION', description: '해방 달성', target: 1, reward: { gold: 100000, stones: 200, dust: 500 } },
      { id: 'use_ultimate', type: 'USE_ULTIMATE', description: '궁극기 50회 사용', target: 50, reward: { gold: 10000, potions: 5 } },
    ];
    
    const REBIRTH_UPGRADES = {
        'gold_gain': { name: '골드 획득량 증가', description: level => `골드 획득량이 영구적으로 ${level * 5}% 증가합니다.`, cost: level => (level + 1) },
        'xp_gain': { name: '경험치 획득량 증가', description: level => `경험치 획득량이 영구적으로 ${level * 5}% 증가합니다.`, cost: level => (level + 1) },
        'base_atk': { name: '기본 공격력 증가', description: level => `모든 직업의 기본 공격력이 영구적으로 ${level * 2} 증가합니다.`, cost: level => (level + 1) * 2 },
        'base_hp': { name: '기본 생명력 증가', description: level => `모든 직업의 기본 생명력이 영구적으로 ${level * 10} 증가합니다.`, cost: level => (level + 1) * 2 },
        'ultimate_cooldown': { name: '궁극의 기술 연마', maxLevel: 4, description: level => `궁극기 재사용 대기시간이 영구적으로 ${level * 5}% 감소합니다. (현재: -${level*5}%)`, cost: level => (level + 1) * 3 }
    };


    let player;
    let monster;
    let messageLog;
    let currentScreen;
    let currentDifficulty;
    let dungeonLevel;
    let dungeonFloor;
    let shopFilterType = 'all';
    let shopFilterRarity = 'all';
    let blacksmithMode = 'enhance';
    let blacksmithSelection = {
        enhance: null,
        enchant: null,
        transcend: [null, null]
    };
    let batchDisenchantFilters = { common: false, uncommon: false, rare: false };
    let guideElementsRendered = false;
    
    let survivalWave = 0;


    const monsterList = [
        { name: '슬라임', emoji: '💧', baseHp: 20, baseAttack: 5, xp: 25, gold: 12, lootTable: [102, 105] },
        { name: '고블린', emoji: '👺', baseHp: 30, baseAttack: 7, xp: 40, gold: 25, lootTable: [101, 103, 105, 107, 108], onHitEffect: {type: 'weaken', chance: 0.2, duration: 2, potency: 0.1} },
        { name: '오크', emoji: '👹', baseHp: 45, baseAttack: 11, xp: 60, gold: 40, lootTable: [101, 106, 201] },
        { name: '독거미', emoji: '🕷️', baseHp: 55, baseAttack: 12, xp: 75, gold: 55, lootTable: [205, 203, 207, 208], onHitEffect: {type: 'poison', chance: 0.4, duration: 3, potency: 4} },
        { name: '스켈레톤', emoji: '💀', baseHp: 65, baseAttack: 14, xp: 85, gold: 70, lootTable: [201, 206] },
    ];

    const bossList = [
        { name: '동굴 트롤', emoji: '🗿', baseHp: 80, baseAttack: 15, xp: 200, gold: 250, lootTable: [201, 206, 205], onHitEffect: {type: 'stun', chance: 0.2, duration: 1, potency: 0} },
        { name: '거대 골렘', emoji: '🤖', baseHp: 120, baseAttack: 19, xp: 300, gold: 400, lootTable: [202, 204, 303], onHitEffect: {type: 'vulnerable', chance: 0.5, duration: 2, potency: 0.25} },
        { name: '흑기사', emoji: '♞', baseHp: 160, baseAttack: 24, xp: 450, gold: 600, lootTable: [301, 303, 307, 308], onHitEffect: {type: 'weaken', chance: 0.4, duration: 3, potency: 0.2} },
        { name: '드래곤', emoji: '🐲', baseHp: 220, baseAttack: 28, xp: 600, gold: 800, lootTable: [301, 302], onHitEffect: {type: 'burn', chance: 0.7, duration: 3, potency: 15} },
    ];
    
    // --- Helper Functions ---
    function isInventoryFull() {
        return player.inventory.length >= INVENTORY_LIMIT;
    }

    function canAddItem(count = 1) {
        return player.inventory.length + count <= INVENTORY_LIMIT;
    }

    function removeGuideElements() {
        document.getElementById('guide-button')?.remove();
        document.getElementById('guide-modal')?.remove();
        guideElementsRendered = false;
    }

    function removePermanentUI() {
        document.getElementById('game-reset-button')?.remove();
        document.getElementById('rank-display')?.remove();
    }

    function getPlayerRank() {
        if (!player) return { rank: 'C', colorClass: 'rank-C' };
        if (player.rebirths >= 3 && player.isLiberated) return { rank: 'SSS', colorClass: 'rank-SSS' };
        if (player.rebirths >= 3) return { rank: 'SS', colorClass: 'rank-SS' };
        if (player.rebirths >= 2) return { rank: 'S', colorClass: 'rank-S' };
        if (player.rebirths >= 1) return { rank: 'A', colorClass: 'rank-A' };
        if (player.level >= 15) return { rank: 'B', colorClass: 'rank-B' };
        return { rank: 'C', colorClass: 'rank-C' };
    }

    function renderPermanentUI() {
        let resetButton = document.getElementById('game-reset-button');
        if (!resetButton) {
            resetButton = document.createElement('button');
            resetButton.id = 'game-reset-button';
            resetButton.textContent = '게임 초기화';
            document.body.appendChild(resetButton);
            resetButton.addEventListener('click', () => {
                if (confirm('정말로 게임을 초기화하시겠습니까? 모든 진행 상황이 삭제되고 되돌릴 수 없습니다.')) {
                    removePermanentUI();
                    deleteSaveData(false);
                    createStartScreen();
                }
            });
        }

        let rankDisplay = document.getElementById('rank-display');
        if (!rankDisplay) {
            rankDisplay = document.createElement('div');
            rankDisplay.id = 'rank-display';
            document.body.appendChild(rankDisplay);
        }
        
        const { rank, colorClass } = getPlayerRank();
        rankDisplay.innerHTML = `
            <span>RANK</span>
            <span class="${colorClass}">${rank}</span>
        `;
    }

    function renderPlayerCard(inBattle) {
        if (!player) return '';

        const hpPercent = player.maxHp > 0 ? (player.currentHp / player.maxHp) * 100 : 0;
        const xpPercent = player.nextLevelXp > 0 ? (player.xp / player.nextLevelXp) * 100 : 0;
        
        if (inBattle) {
            const equipmentSlots = ['weapon', 'armor', 'accessory', 'relic'];
            const equipmentIcons = {'weapon': '⚔️', 'armor': '🛡️', 'accessory': '💍', 'relic': '📜'};
            let equipmentHtml = '';
            equipmentSlots.forEach(slot => {
                const item = getEquippedItem(slot);
                if (item) {
                    let name = item.name;
                    if (item.enhancementLevel > 0) name += `+${item.enhancementLevel}`;
                    equipmentHtml += `<span class="compact-equipment-item rarity-${item.rarity}">${equipmentIcons[slot]} ${name}</span>`;
                }
            });

            let buffsHtml = Object.entries(player.buffs).map(([name, buff]) => 
                `<span class="buff-icon">${name} (${buff.duration})</span>`
            ).join('');

            return `
                <div class="player-header">
                    <h2>${player.name} (Lv. ${player.level})</h2>
                    <div class="player-class">${CLASSES[player.className].emoji} ${player.className}</div>
                </div>
                <div class="hp-bar-container"><div class="hp-bar" style="width: ${hpPercent}%;"></div></div>
                <p>${player.currentHp.toLocaleString()} / ${player.maxHp.toLocaleString()}</p>
                <div class="compact-info-grid" style="grid-template-columns: repeat(3, 1fr); padding-top: 0.4rem; margin-top: 0.4rem; border: none; font-size: 0.8rem;">
                    <span>🗡️ ${player.attackPower.toLocaleString()}</span>
                    <span>🛡️ ${player.defense.toLocaleString()}</span>
                    <span>🎯 ${Math.round(player.critChance * 100)}%</span>
                    <span>💥 ${Math.round(player.critDamage * 100)}%</span>
                    <span>💨 ${Math.round(player.evadeChance * 100)}%</span>
                </div>
                ${buffsHtml ? `<div class="player-buffs">${buffsHtml}</div>` : ''}
                <div class="status-effects" id="player-status-effects"></div>
            `;
        } else {
            // Town UI (NEW CONCISE VERSION)
            const inventoryWarning = isInventoryFull() ? '<span class="inventory-warning" title="가방 꽉 참">🎒!</span>' : '';

            // Vitals with overlaid text
            const vitalsHtml = `
                <div class="bar-wrapper">
                    <div class="bar-container-overlay">
                        <div class="hp-bar" style="width: ${hpPercent}%;"></div>
                        <span class="bar-text">HP: ${player.currentHp.toLocaleString()} / ${player.maxHp.toLocaleString()}</span>
                    </div>
                </div>
                <div class="bar-wrapper">
                    <div class="bar-container-overlay">
                        <div class="xp-bar" style="width: ${xpPercent}%;"></div>
                        <span class="bar-text">XP: ${player.xp.toLocaleString()} / ${player.nextLevelXp.toLocaleString()}</span>
                    </div>
                </div>
            `;

            // Single line resources
            const resourcesHtml = `
                <div class="compact-info-grid" style="grid-template-columns: repeat(3, 1fr);">
                    <span title="골드">💰 ${player.gold.toLocaleString()}</span>
                    <span title="강화석">💎 ${player.enhancementStones.toLocaleString()}</span>
                    <span title="마법 부여 가루">✨ ${player.enchantmentDust.toLocaleString()}</span>
                </div>
            `;

            // Single line stats
            const statsHtml = `
                <div class="compact-info-grid" style="grid-template-columns: repeat(5, 1fr);">
                    <span title="공격력">🗡️ ${player.attackPower.toLocaleString()}</span>
                    <span title="방어력">🛡️ ${player.defense.toLocaleString()}</span>
                    <span title="치명타 확률">🎯 ${Math.round(player.critChance * 100)}%</span>
                    <span title="치명타 피해">💥 ${Math.round(player.critDamage * 100)}%</span>
                    <span title="회피 확률">💨 ${Math.round(player.evadeChance * 100)}%</span>
                </div>
            `;

            // Equipment and Ultimate
            const equipmentSlots = { 'weapon': '⚔️', 'armor': '🛡️', 'accessory': '💍', 'relic': '📜' };
            let equipmentHtml = Object.entries(equipmentSlots).map(([slot, icon]) => {
                const item = getEquippedItem(slot);
                let itemDisplay;
                if (item) {
                    let itemName = item.name;
                    if (item.enhancementLevel > 0) itemName += `+${item.enhancementLevel}`;
                    if (item.transcendenceLevel > 0) itemName += `(T${item.transcendenceLevel})`;
                    itemDisplay = `<span class="rarity-${item.rarity}" title="${item.name}">${itemName}</span>`;
                } else {
                    itemDisplay = `<span class="rarity-common">(없음)</span>`;
                }
                return `<div class="equipment-compact-item"><span>${icon}</span> ${itemDisplay}</div>`;
            }).join('');

            const u1 = ULTIMATE_SKILLS[player.className];
            const u2 = ULTIMATE_SKILLS_2[player.className];
            const u3 = ULTIMATE_SKILLS_3[player.className];
            let ultimateSkill;
            if (u1 && u1.id === player.selectedUltimateId) ultimateSkill = u1;
            else if (u2 && u2.id === player.selectedUltimateId) ultimateSkill = u2;
            else if (u3 && u3.id === player.selectedUltimateId) ultimateSkill = u3;
            const ultimateName = ultimateSkill ? ultimateSkill.name : "궁극기";

            const ultimateHtml = `
                <div class="equipment-compact-item">
                    <span>🌟</span> <span style="color: var(--rarity-legendary); font-weight: bold;">${ultimateName}</span>
                </div>
            `;

            return `
                <h2 class="dungeon-progress" style="cursor: pointer;" title="난이도 변경">${currentDifficulty} | 던전 ${dungeonLevel}층</h2>
                <div class="player-header">
                    <h2>${player.name} <span class="name-change-icon">✏️</span></h2>
                    <div class="player-class" style="cursor: pointer;" title="환생 후 직업 변경 가능">${CLASSES[player.className].emoji} ${player.className} (Lv. ${player.level}) ${inventoryWarning}</div>
                </div>
                
                ${vitalsHtml}
                
                <div class="info-section">
                    <h3>자원</h3>
                    ${resourcesHtml}
                </div>

                <div class="info-section">
                    <h3>능력치</h3>
                    ${statsHtml}
                </div>

                <div class="info-section">
                    <h3>장비 & 궁극기</h3>
                    <div class="equipment-ultimate-container">
                        ${equipmentHtml}
                        ${ultimateHtml}
                    </div>
                </div>
            `;
        }
    }

    function renderGuideElements() {
        if (guideElementsRendered) return;

        const guideButton = document.createElement('button');
        guideButton.id = 'guide-button';
        guideButton.textContent = '❓';
        guideButton.title = '초보자 가이드';

        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'guide-modal';
        modalOverlay.className = 'modal-overlay';
        modalOverlay.innerHTML = `
            <div class="modal-content">
                <h2>초보자 가이드</h2>
                <div class="modal-body">
                    <h3>게임 목표</h3>
                    <p>던전에 입장하여 몬스터를 처치하고, 더 좋은 장비를 획득하여 캐릭터를 성장시키세요. 최종 목표는 더 높은 레벨의 던전을 클리어하고, 환생을 통해 영구적으로 강해지는 것입니다.</p>
                    
                    <h3>전투</h3>
                    <ul>
                        <li><strong>공격:</strong> 기본 공격으로 몬스터에게 피해를 줍니다.</li>
                        <li><strong>물약:</strong> 체력을 회복합니다. 상점에서 구매할 수 있습니다.</li>
                        <li><strong>궁극기:</strong> 직업마다 고유의 강력한 기술을 사용합니다. 사용 후에는 재사용 대기시간이 있습니다.</li>
                        <li><strong>상태 이상:</strong> 독, 화상, 기절 등 다양한 효과가 전투에 영향을 줍니다. 몬스터와 플레이어 모두에게 적용될 수 있습니다.</li>
                    </ul>

                    <h3>성장과 장비</h3>
                    <ul>
                        <li><strong>레벨업:</strong> 몬스터를 처치하여 경험치(XP)를 얻고 레벨을 올립니다.</li>
                        <li><strong>장비 등급:</strong> 일반(흰색) &lt; 고급(초록색) &lt; 희귀(파란색) &lt; 전설(주황색) &lt; 신화(빨간색) &lt; 궁극(청록색) &lt; 영원(분홍색) 순으로 강력합니다.</li>
                        <li><strong>장비 관리:</strong> '장비' 메뉴에서 아이템을 장착하거나 잠글 수 있습니다. 잠긴 아이템은 분해가 불가능합니다. <strong>인벤토리는 ${INVENTORY_LIMIT}칸으로 제한됩니다.</strong></li>
                    </ul>

                    <h3>대장간</h3>
                    <ul>
                        <li><strong>강화:</strong> 골드와 강화석을 사용하여 장비의 기본 능력치를 올립니다. 강화 레벨이 높을수록 성공 확률이 감소하며, 실패 시 패널티가 있을 수 있습니다.</li>
                        <li><strong>분해:</strong> 필요 없는 장비를 분해하여 강화석과 마법 부여 가루를 얻습니다. '일괄 분해' 탭에서 여러 아이템을 한번에 분해할 수 있습니다.</li>
                        <li><strong>초월:</strong> 동일한 장비 2개(강화 및 마법 부여가 없어야 함)를 합쳐 더욱 강력한 장비로 만듭니다. 초월할 때마다 장비의 기본 능력치가 1.5배씩 강력해집니다. 초월에는 많은 골드와 재료가 필요합니다.</li>
                        <li><strong>마법 부여:</strong> 마법 부여 가루와 골드를 사용하여 장비에 무작위 추가 옵션을 부여합니다.</li>
                    </ul>

                    <h3>스킬과 환생</h3>
                    <ul>
                        <li><strong>스킬 트리:</strong> 골드를 사용하여 직업별 패시브 스킬을 배워 캐릭터를 특화할 수 있습니다.</li>
                        <li><strong>환생:</strong> 30레벨에 도달하면 환생이 가능합니다. 레벨, 골드 등이 초기화되지만, '환생 포인트(RP)'를 얻어 영구적인 능력치를 올릴 수 있습니다. 장비와 아이템은 유지됩니다.</li>
                        <li><strong>해방:</strong> 환생 3회 이상을 달성한 자를 위한 최종 시험입니다. 통과하면 궁극의 힘을 얻게 됩니다.</li>
                    </ul>

                    <h3>기타 콘텐츠</h3>
                    <ul>
                        <li><strong>업적:</strong> 영구적인 퀘스트를 완료하고 보상을 받으세요.</li>
                        <li><strong>서바이벌 던전:</strong> 끝없이 몰려오는 몬스터를 상대로 최대한 오래 버티고 골드를 획득하세요. 높은 웨이브를 달성할수록 더 많은 골드를 얻습니다.</li>
                        <li><strong>뽑기:</strong> 골드를 소모하여 무작위 장비 또는 강화석을 획득할 수 있습니다. 신화, 궁극, 영원 등급 장비는 오직 뽑기에서만 나옵니다.</li>
                    </ul>
                </div>
                <div class="modal-footer">
                    <button id="close-guide-button" class="button">닫기</button>
                </div>
            </div>
        `;

        document.body.appendChild(guideButton);
        document.body.appendChild(modalOverlay);

        guideButton.addEventListener('click', () => {
            modalOverlay.style.display = 'flex';
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.style.display = 'none';
            }
        });
        
        document.getElementById('close-guide-button')?.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });
        
        guideElementsRendered = true;
    }
    
    function createStartScreen() {
        currentScreen = 'START';
        removeGuideElements();
        removePermanentUI();
        const hasSaveData = !!localStorage.getItem('simpleRPG_saveData');
        
        root.innerHTML = `
            <div class="screen-container">
                <h1 class="logo">⚔️ 간단RPG 🛡️</h1>
                <div id="action-buttons" class="town-actions" style="grid-template-columns: 1fr; max-width: 250px; gap: 0.8rem;">
                    <button data-action="new-game" class="button">새 게임</button>
                    <button data-action="continue-game" class="button" style="${hasSaveData ? '' : 'display: none;'}">이어하기</button>
                    <button data-action="delete-save" class="button" style="${hasSaveData ? '' : 'display: none;'} background-color: var(--monster-hp-color);">데이터 삭제</button>
                </div>
            </div>
        `;

        document.getElementById('action-buttons')?.addEventListener('click', (e) => {
            const action = e.target.closest('button')?.dataset.action;
            if (action === 'new-game') {
                if (hasSaveData && !confirm('기존 저장 데이터가 있습니다. 정말로 새 게임을 시작하시겠습니까? 데이터가 삭제됩니다.')) {
                    return;
                }
                deleteSaveData(false); // Silently delete
                createDifficultySelectionScreen();
            } else if (action === 'continue-game') {
                if(loadGameState()) {
                    renderTownScreen();
                } else {
                    alert("저장된 데이터를 불러오는 데 실패했습니다. 새 게임을 시작합니다.");
                    createDifficultySelectionScreen();
                }
            } else if (action === 'delete-save') {
                if (confirm('정말로 저장된 데이터를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                    deleteSaveData(true);
                }
            }
        });
    }


    function createItemInstance(itemId) {
        const itemData = ITEM_DATABASE.find(i => i.id === itemId);
        if (!itemData) return null;

        const newItem = JSON.parse(JSON.stringify(itemData));
        newItem.enhancementLevel = 0;
        newItem.enchantment = null;
        newItem.isLocked = false;
        newItem.transcendenceLevel = 0;
        return newItem;
    }

    function createDifficultySelectionScreen() {
        currentScreen = 'DIFFICULTY_SELECTION';
        removeGuideElements();
        removePermanentUI();
        root.innerHTML = `
            <div class="screen-container">
                 <h1 class="logo">⚔️ 간단RPG 🛡️</h1>
                <h1>난이도 선택</h1>
                <p>모험의 난이도를 선택하세요.</p>
                <div class="difficulty-selection">
                    <button class="difficulty-card" data-difficulty="쉬움">
                        <h2>쉬움</h2>
                        <p>몬스터가 약해지고, 더 많은 자원으로 시작합니다. 편안한 플레이에 적합합니다.</p>
                    </button>
                    <button class="difficulty-card" data-difficulty="보통">
                        <h2>보통</h2>
                        <p>표준적인 RPG 경험을 제공합니다.</p>
                    </button>
                    <button class="difficulty-card" data-difficulty="어려움">
                        <h2>어려움</h2>
                        <p>몬스터가 매우 강력합니다. 보상이 크지만, 상당한 도전을 요구합니다.</p>
                    </button>
                    <button class="difficulty-card" data-difficulty="하드코어">
                        <h2 style="color: var(--monster-hp-color);">하드코어</h2>
                        <p>죽으면 모든 데이터가 삭제되는 궁극의 도전 모드입니다. 매우 높은 보상이 주어집니다.</p>
                    </button>
                </div>
            </div>
        `;

        document.querySelectorAll('.difficulty-card').forEach(card => {
            card.addEventListener('click', (e) => {
                currentDifficulty = e.currentTarget.dataset.difficulty;
                createClassSelectionScreen();
            });
        });
    }

    function renderDifficultyChangeScreen() {
      currentScreen = 'DIFFICULTY_CHANGE';
      renderPermanentUI();
      root.innerHTML = `
        <div class="screen-container">
          <h1>난이도 변경</h1>
          <p>변경할 난이도를 선택하세요. 다음 던전부터 적용됩니다. (현재: ${currentDifficulty})</p>
           <p style="font-size: 0.8rem; color: var(--rarity-legendary);">하드코어 모드로는 변경할 수 없으며, 하드코어 모드에서 다른 난이도로 변경할 수도 없습니다.</p>
          <div class="difficulty-selection">
            <button class="difficulty-card" data-difficulty="쉬움" ${currentDifficulty === '하드코어' ? 'disabled' : ''}><h2>쉬움</h2><p>편안한 플레이.</p></button>
            <button class="difficulty-card" data-difficulty="보통" ${currentDifficulty === '하드코어' ? 'disabled' : ''}><h2>보통</h2><p>표준적인 경험.</p></button>
            <button class="difficulty-card" data-difficulty="어려움" ${currentDifficulty === '하드코어' ? 'disabled' : ''}><h2>어려움</h2><p>더 큰 도전과 보상.</p></button>
          </div>
          <button id="back-to-town" class="button" style="margin-top: 1rem; width: 100%;">마을로 돌아가기</button>
        </div>
      `;
      document.querySelectorAll('.difficulty-card:not([disabled])').forEach(card => {
        card.addEventListener('click', (e) => {
          const newDifficulty = e.currentTarget.dataset.difficulty;
          if (newDifficulty !== currentDifficulty) {
            currentDifficulty = newDifficulty;
            saveGameState();
            alert(`난이도가 ${newDifficulty}(으)로 변경되었습니다.`);
          }
          renderTownScreen();
        });
      });
      document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }


    function createClassSelectionScreen() {
        currentScreen = 'CLASS_SELECTION';
        removePermanentUI();
        root.innerHTML = `
            <div class="screen-container">
                <h1>직업 선택</h1>
                <p>모험을 함께할 당신의 직업을 선택하세요.</p>
                <div class="class-selection">
                    <button class="class-card" data-class="전사">
                        <h2>전사 🛡️</h2>
                        <p>높은 체력과 방어력. 적을 약화시키고 버티는 전투를 이끌어갑니다.</p>
                    </button>
                    <button class="class-card" data-class="마법사">
                        <h2>마법사 🔥</h2>
                        <p>강력한 원소 마법으로 적을 불태우거나 얼립니다.</p>
                    </button>
                    <button class="class-card" data-class="암살자">
                        <h2>암살자 💨</h2>
                        <p>치명적인 공격과 높은 회피율로 적을 순식간에 제압합니다.</p>
                    </button>
                    <button class="class-card" data-class="궁수">
                        <h2>궁수 🏹</h2>
                        <p>날카로운 화살로 원거리에서 적의 약점을 노립니다. 치명타 공격에 특화되어 있습니다.</p>
                    </button>
                </div>
            </div>
        `;

        document.querySelectorAll('.class-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const selectedClass = e.currentTarget.dataset.class;
                const playerName = prompt("용사님의 이름은 무엇입니까?", "용사") || "용사";
                 if (selectedClass) {
                    initializeGame(selectedClass, playerName);
                }
            });
        });
    }

    function createClassChangeScreen() {
        currentScreen = 'CLASS_SELECTION';
        renderPermanentUI();
        root.innerHTML = `
            <div class="screen-container">
                <h1>직업 변경</h1>
                <p>새로운 직업을 선택하세요. 기존 직업과 다른 직업을 선택해야 합니다.</p>
                <div class="class-selection">
                    <button class="class-card" data-class="전사" ${player.className === '전사' ? 'disabled' : ''}>
                        <h2>전사 🛡️</h2>
                        <p>높은 체력과 방어력. 적을 약화시키고 버티는 전투를 이끌어갑니다.</p>
                    </button>
                    <button class="class-card" data-class="마법사" ${player.className === '마법사' ? 'disabled' : ''}>
                        <h2>마법사 🔥</h2>
                        <p>강력한 원소 마법으로 적을 불태우거나 얼립니다.</p>
                    </button>
                    <button class="class-card" data-class="암살자" ${player.className === '암살자' ? 'disabled' : ''}>
                        <h2>암살자 💨</h2>
                        <p>치명적인 공격과 높은 회피율로 적을 순식간에 제압합니다.</p>
                    </button>
                    <button class="class-card" data-class="궁수" ${player.className === '궁수' ? 'disabled' : ''}>
                        <h2>궁수 🏹</h2>
                        <p>날카로운 화살로 원거리에서 적의 약점을 노립니다. 치명타 공격에 특화되어 있습니다.</p>
                    </button>
                </div>
                <button id="back-to-town" class="button" style="margin-top: 1rem; width: 100%;">마을로 돌아가기</button>
            </div>
        `;

        document.querySelectorAll('.class-card:not([disabled])').forEach(card => {
            card.addEventListener('click', (e) => {
                const newClass = e.currentTarget.dataset.class;
                if (confirm(`정말로 직업을 ${newClass}(으)로 변경하시겠습니까? (비용: ${CLASS_CHANGE_COST}골드)`)) {
                    if (player.gold >= CLASS_CHANGE_COST) {
                        player.gold -= CLASS_CHANGE_COST;
                        player.className = newClass;
                        player.level = 1;
                        player.xp = 0;
                        player.nextLevelXp = 50;
                        player.skills = {}; // Reset skills
                        player.ultimateSkill.level = 1; // Reset ultimate level
                        player.ultimateSkill.cooldownLeft = 0;
                        player.selectedUltimateId = ULTIMATE_SKILLS[newClass].id;
                        player.unlockedUltimates = [ULTIMATE_SKILLS[newClass].id];
                        updatePlayerStats();
                        saveGameState();
                        alert(`${newClass}(으)로 전직했습니다!`);
                        renderTownScreen();
                    } else {
                        alert('골드가 부족합니다.');
                    }
                }
            });
        });
        document.getElementById('back-to-town')?.addEventListener('click', renderTownScreen);
    }
    
    function initializeGame(className, playerName) {
        const classData = CLASSES[className];
        const difficultyData = DIFFICULTY_SETTINGS[currentDifficulty];

        player = {
            name: playerName,
            level: 1,
            xp: 0,
            nextLevelXp: 50,
            className: className,
            maxHp: classData.baseHp,
            currentHp: classData.baseHp,
            attackPower: classData.baseAtk,
            defense: classData.baseDef,
            critChance: classData.crit,
            critDamage: CRIT_MULTIPLIER,
            evadeChance: classData.evade,
            gold: difficultyData.startGold,
            potions: difficultyData.startPotions,
            attackPotions: difficultyData.startAttackPotions,
            enhancementStones: 0,
            enchantmentDust: 0,
            inventory: [],
            equipment: {
                weapon: null,
                armor: null,
                accessory: null,
                relic: null,
            },
            skills: {},
            ultimateSkill: {
              id: ULTIMATE_SKILLS[className].id,
              name: ULTIMATE_SKILLS[className].name,
              cooldown: ULTIMATE_SKILLS[className].cooldown,
              cooldownLeft: 0,
              level: 1,
            },
            selectedUltimateId: ULTIMATE_SKILLS[className].id,
            unlockedUltimates: [ULTIMATE_SKILLS[className].id],
            statusEffects: {},
            buffs: {},
            rebirths: 0,
            rebirthPoints: 0,
            rebirthUpgrades: {},
            permanentQuests: PERMANENT_QUESTS_DATA.map(q => ({...q, progress: 0, completed: false})),
            isLiberated: false,
        };
        
        dungeonLevel = 1;
        dungeonFloor = 1;

        updatePlayerStats();
        saveGameState();
        renderTownScreen();
    }
    
    function getEquippedItem(slot) {
        const itemInstance = player.equipment[slot];
        return itemInstance ? getItemWithStats(itemInstance) : null;
    }

    function getItemWithStats(itemInstance) {
        if (!itemInstance) return null;

        const baseItem = ITEM_DATABASE.find(i => i.id === itemInstance.id);
        if (!baseItem) return null;

        const item = JSON.parse(JSON.stringify(itemInstance)); // Deep copy to avoid mutation
        item.stats = JSON.parse(JSON.stringify(baseItem.stats));
        
        // Transcendence multiplier
        const transcendenceMultiplier = Math.pow(1.5, item.transcendenceLevel);

        // Apply transcendence bonus
        for (const stat in item.stats) {
            item.stats[stat] = Math.round(item.stats[stat] * transcendenceMultiplier);
        }

        // Apply enhancement bonus
        if (item.enhancementLevel > 0) {
            const enhancementBonus = getEnhancementBonus(item, item.enhancementLevel);
            for (const stat in enhancementBonus) {
                if (item.stats[stat]) {
                    item.stats[stat] += enhancementBonus[stat];
                } else {
                    item.stats[stat] = enhancementBonus[stat];
                }
            }
        }
        
        // Apply enchantment bonus
        if (item.enchantment) {
            for (const stat in item.enchantment.effects) {
                if (stat.includes('Percent')) {
                    // Handle percentage stats separately during total stat calculation
                } else {
                    item.stats[stat] = (item.stats[stat] || 0) + item.enchantment.effects[stat];
                }
            }
        }

        return item;
    }

    function getEnhancementBonus(item, level) {
        const bonus = {};
        if (!item.stats) return bonus;

        const primaryStat = Object.keys(item.stats)[0];
        const baseValue = ITEM_DATABASE.find(i => i.id === item.id).stats[primaryStat];
        let multiplier = 0;

        if (item.type === 'weapon') {
            multiplier = 0.2;
        } else if (item.type === 'armor') {
            multiplier = 0.15;
        } else {
            multiplier = 0.1;
        }

        const rarityMultipliers = { common: 1, uncommon: 1.2, rare: 1.5, legendary: 2, mythic: 2.5, ultimate: 3.5, eternal: 5 };
        multiplier *= rarityMultipliers[item.rarity] || 1;

        bonus[primaryStat] = (bonus[primaryStat] || 0) + Math.ceil(baseValue * multiplier * level);
        
        const baseDef = ITEM_DATABASE.find(i => i.id === item.id).stats.defense;
        if (item.type === 'armor' && baseDef) {
             bonus.defense = (bonus.defense || 0) + Math.ceil(baseDef * 0.2 * level * rarityMultipliers[item.rarity]);
        }

        return bonus;
    }


    function updatePlayerStats() {
        if (!player) return;

        const baseClass = CLASSES[player.className];
        let newStats = {
            maxHp: baseClass.baseHp,
            attackPower: baseClass.baseAtk,
            defense: baseClass.baseDef,
            critChance: baseClass.crit,
            critDamage: CRIT_MULTIPLIER,
            evadeChance: baseClass.evade,
        };

        // Rebirth Upgrades (Flat)
        const rebirthAtk = player.rebirthUpgrades.base_atk ? (player.rebirthUpgrades.base_atk * 2) : 0;
        const rebirthHp = player.rebirthUpgrades.base_hp ? (player.rebirthUpgrades.base_hp * 10) : 0;
        newStats.attackPower += rebirthAtk;
        newStats.maxHp += rebirthHp;

        // Skill Tree Bonuses (Flat)
        for (const skillId in player.skills) {
            const skillLevel = player.skills[skillId];
            if (skillLevel > 0) {
                const skillInfo = SKILL_DATA[player.className][skillId];
                if (skillInfo && skillInfo.effects) {
                    skillInfo.effects(skillLevel).forEach(effect => {
                        if (effect.stat && !effect.stat.includes('Percent')) {
                            newStats[effect.stat] = (newStats[effect.stat] || 0) + effect.value;
                        }
                    });
                }
            }
        }
        
        // Equipment Bonuses (Flat)
        let equipmentPercentBonuses = {};
        for (const slot in player.equipment) {
            const item = getEquippedItem(slot);
            if (item) {
                for (const stat in item.stats) {
                    newStats[stat] = (newStats[stat] || 0) + item.stats[stat];
                }
                if (item.enchantment) {
                    for (const effectStat in item.enchantment.effects) {
                        if (effectStat.includes('Percent')) {
                             equipmentPercentBonuses[effectStat] = (equipmentPercentBonuses[effectStat] || 0) + item.enchantment.effects[effectStat];
                        }
                    }
                }
            }
        }

        // Handle 'allStatsPercent' from relics or enchantments
        let totalAllStatsPercent = 0;
        const relic = getEquippedItem('relic');
        if (relic && relic.stats.allStatsPercent) {
            totalAllStatsPercent += relic.stats.allStatsPercent;
        }
        if (relic && relic.enchantment && relic.enchantment.effects.allStatsPercent) {
            totalAllStatsPercent += relic.enchantment.effects.allStatsPercent;
        }

        // Apply Buffs and Debuffs (that are stat modifications)
        for (const buffName in player.buffs) {
            const buff = player.buffs[buffName];
            if(buff.stat && !buff.isPercent){
                 newStats[buff.stat] += buff.value;
            }
        }

        // Apply Percentage-based bonuses
        const baseStatsForPercentCalc = { ...newStats };

        // Apply allStatsPercent
        if (totalAllStatsPercent > 0) {
            newStats.maxHp += Math.round(baseStatsForPercentCalc.maxHp * totalAllStatsPercent);
            newStats.attackPower += Math.round(baseStatsForPercentCalc.attackPower * totalAllStatsPercent);
            newStats.defense += Math.round(baseStatsForPercentCalc.defense * totalAllStatsPercent);
        }

        // Apply specific percent bonuses from enchantments
        for (const stat in equipmentPercentBonuses) {
            const baseStatName = stat.replace('Percent', '');
            if (newStats[baseStatName]) {
                newStats[baseStatName] += Math.round(baseStatsForPercentCalc[baseStatName] * equipmentPercentBonuses[stat]);
            }
        }

        // Apply Percentage Buffs and Debuffs
        for (const buffName in player.buffs) {
            const buff = player.buffs[buffName];
            if (buff.stat && buff.isPercent) {
                newStats[buff.stat] *= (1 + buff.value);
            }
        }
        
        // Final assignment, ensuring HP integrity
        const hpRatio = player.maxHp > 0 ? (player.currentHp / player.maxHp) : 1;
        player.maxHp = Math.round(newStats.maxHp);
        player.attackPower = Math.round(newStats.attackPower);
        player.defense = Math.round(newStats.defense);
        player.critChance = newStats.critChance;
        player.critDamage = newStats.critDamage;
        player.evadeChance = newStats.evadeChance;

        player.currentHp = Math.round(player.maxHp * hpRatio);
        if (player.currentHp <= 0 && currentScreen !== 'BATTLE' && currentScreen !== 'SURVIVAL' && currentScreen !== 'LIBERATION_BATTLE') {
            player.currentHp = 1;
        }
        if (player.currentHp > player.maxHp) player.currentHp = player.maxHp;

        saveGameState();
    }


    function createMonster() {
        const difficultyMods = DIFFICULTY_SETTINGS[currentDifficulty];
        const isBoss = dungeonFloor % 5 === 0;
        const monsterPool = isBoss ? bossList : monsterList;
        
        const baseMonster = { ...monsterPool[Math.floor(Math.random() * monsterPool.length)] };
        
        const levelMultiplier = 1 + (dungeonLevel - 1) * 0.2 + (dungeonFloor - 1) * 0.05;
        const bossMultiplier = isBoss ? 1.5 + (dungeonLevel * 0.1) : 1;

        monster = {
            ...baseMonster,
            maxHp: Math.ceil(baseMonster.baseHp * levelMultiplier * bossMultiplier * difficultyMods.monsterHpMod),
            currentHp: Math.ceil(baseMonster.baseHp * levelMultiplier * bossMultiplier * difficultyMods.monsterHpMod),
            attack: Math.ceil(baseMonster.baseAttack * levelMultiplier * bossMultiplier * difficultyMods.monsterAtkMod),
            xp: Math.ceil(baseMonster.xp * levelMultiplier * bossMultiplier * difficultyMods.rewardMod * (player.rebirthUpgrades.xp_gain ? (1 + player.rebirthUpgrades.xp_gain * 0.05) : 1)),
            gold: Math.ceil(baseMonster.gold * levelMultiplier * bossMultiplier * difficultyMods.rewardMod * (player.rebirthUpgrades.gold_gain ? (1 + player.rebirthUpgrades.gold_gain * 0.05) : 1)),
            isBoss: isBoss,
            statusEffects: {},
        };
    }
    
    function createSurvivalMonster(wave) {
        const difficultyMods = DIFFICULTY_SETTINGS[currentDifficulty];
        const isBossWave = wave % 10 === 0;
        const monsterPool = isBossWave ? bossList : monsterList;
        const baseMonster = { ...monsterPool[Math.floor(Math.random() * monsterPool.length)] };

        const waveMultiplier = 1 + (wave * 0.15);
        const bossMultiplier = isBossWave ? 2 : 1;

        return {
            ...baseMonster,
            maxHp: Math.ceil(baseMonster.baseHp * waveMultiplier * bossMultiplier * difficultyMods.monsterHpMod),
            currentHp: Math.ceil(baseMonster.baseHp * waveMultiplier * bossMultiplier * difficultyMods.monsterHpMod),
            attack: Math.ceil(baseMonster.baseAttack * waveMultiplier * bossMultiplier * difficultyMods.monsterAtkMod),
            xp: 0, // No XP in survival
            gold: Math.ceil(baseMonster.gold * waveMultiplier * difficultyMods.rewardMod * (player.rebirthUpgrades.gold_gain ? (1 + player.rebirthUpgrades.gold_gain * 0.05) : 1)),
            isBoss: isBossWave,
            statusEffects: {},
        };
    }


    function addMessage(text, className = '') {
        if (!messageLog) return;
        const message = `<p class="${className}">${text}</p>`;
        messageLog.insertAdjacentHTML('afterbegin', message);
        if (messageLog.children.length > 50) {
            messageLog.lastElementChild.remove();
        }
    }
    
    // --- Gacha Logic ---
    function performGachaDraw() {
        const rand = Math.random();
        let rarity;
        
        if (rand < 0.0005) rarity = 'eternal';    // 0.05%
        else if (rand < 0.005) rarity = 'ultimate';   // 0.45%
        else if (rand < 0.02) rarity = 'mythic';     // 1.5%
        else if (rand < 0.10) rarity = 'legendary';  // 8%
        else if (rand < 0.30) rarity = 'rare';       // 20%
        else if (rand < 0.60) rarity = 'uncommon';   // 30%
        else rarity = 'common'; // 40%
        
        const gachaPool = ITEM_DATABASE.filter(item => item.rarity); // All items with rarity are potential gacha items
        const itemsOfRarity = gachaPool.filter(item => item.rarity === rarity);
        
        const stonePool = {
            common: { name: '하급 강화석', count: Math.floor(Math.random() * 3) + 1, rarity: 'common' },
            uncommon: { name: '중급 강화석', count: Math.floor(Math.random() * 5) + 3, rarity: 'uncommon' },
            rare: { name: '상급 강화석', count: Math.floor(Math.random() * 8) + 5, rarity: 'rare' },
        };
        
        const possiblePrizes = [...itemsOfRarity];
        if (stonePool[rarity]) {
            possiblePrizes.push(stonePool[rarity]);
        }
        
        if (possiblePrizes.length === 0) {
            // Default to enhancement stones if no items of that rarity are available
            return stonePool.uncommon;
        }

        const prize = possiblePrizes[Math.floor(Math.random() * possiblePrizes.length)];
        
        if (prize.id) { // It's an item
            return createItemInstance(prize.id);
        } else { // It's a stone pack
            return prize;
        }
    }

    // --- Game Screens ---
    function renderTownScreen() {
        currentScreen = 'TOWN';
        player.currentHp = player.maxHp; // Heal player on entering town
        renderPermanentUI();
        renderGuideElements();

        const permanentQuestBadge = player.permanentQuests.some(q => !q.completed && q.progress >= q.target) ? `<span class="notification-badge">!</span>` : '';

        const isClassChangeUnlocked = player.rebirths > 0;
        const isRebirthUnlocked = player.level >= REBIRTH_LEVEL_REQ;
        const isLiberationUnlocked = player.rebirths >= 3;
        const isLiberationAvailable = isLiberationUnlocked && !player.isLiberated;

        root.innerHTML = `
            <div class="screen-container town-screen">
                <h1>마을</h1>
                <div class="character-card player-card">
                    ${renderPlayerCard(false)}
                </div>
                <div id="action-buttons" class="town-actions" style="grid-template-columns: 1fr 1fr; gap: 0.4rem;">
                    <button data-action="enter-dungeon" class="button">던전 입장</button>
                    <button data-action="enter-survival" class="button" style="background-color: var(--survival-color);">서바이벌</button>
                    <button data-action="shop" class="button">상점</button>
                    <button data-action="equipment" class="button">장비</button>
                    <button data-action="blacksmith" class="button">대장간</button>
                    <button data-action="skill-tree" class="button">스킬</button>
                    <button data-action="quests" class="button">업적 ${permanentQuestBadge}</button>
                    <button data-action="gacha" class="button">뽑기</button>
                </div>
                
                <div id="growth-buttons" class="town-actions" style="margin-top: 0.6rem; width: 100%;">
                    <h3 style="grid-column: 1 / -1; margin: 0 0 0.4rem 0; font-size: 1rem; color: var(--border-color); text-align: center;">캐릭터 성장</h3>
                    <button data-action="change-difficulty" class="button">난이도 변경</button>
                    <button data-action="change-class" class="button" ${!isClassChangeUnlocked ? 'disabled' : ''} title="${isClassChangeUnlocked ? '' : '환생 1회 이상 필요'}">직업 변경</button>
                    <button data-action="rebirth" class="button" ${!isRebirthUnlocked ? 'disabled' : ''} title="${isRebirthUnlocked ? '' : `레벨 ${REBIRTH_LEVEL_REQ} 이상 필요`}" style="background-color: var(--rebirth-color);">환생</button>
                    <button data-action="liberation" class="button" ${!isLiberationAvailable ? 'disabled' : ''} title="${isLiberationAvailable ? '해방의 시험 도전' : (player.isLiberated ? '이미 해방됨' : '환생 3회 이상 필요')}" style="background-color: var(--rarity-eternal);">해방</button>
                </div>

                <div id="message-log" style="height: 60px;"></div>
            </div>
        `;

        messageLog = document.getElementById('message-log');
        
        document.getElementById('action-buttons')?.addEventListener('click', (e) => {
            const action = e.target.closest('button')?.dataset.action;
            if (!action) return;

            switch (action) {
                case 'enter-dungeon':
                    if (isInventoryFull()) {
                        alert('인벤토리가 가득 찼습니다. 장비를 비우고 다시 시도하세요.');
                        return;
                    }
                    createMonster();
                    renderBattleScreen();
                    break;
                case 'enter-survival':
                    if (player.gold < SURVIVAL_ENTRY_COST) {
                        alert(`입장료가 부족합니다. (필요: ${SURVIVAL_ENTRY_COST} 골드)`);
                        return;
                    }
                    if (confirm(`서바이벌 던전에 입장하시겠습니까? (입장료: ${SURVIVAL_ENTRY_COST} 골드)\n죽을 때까지 몬스터와 싸우며, 처치한 웨이브에 따라 골드를 획득합니다. 물약은 사용할 수 없습니다.`)) {
                        player.gold -= SURVIVAL_ENTRY_COST;
                        startSurvivalMode();
                    }
                    break;
                case 'shop': renderShopScreen(); break;
                case 'equipment': renderEquipmentScreen(); break;
                case 'blacksmith': renderBlacksmithScreen(); break;
                case 'skill-tree': renderSkillTreeScreen(); break;
                case 'quests': renderQuestScreen(); break;
                case 'gacha': renderGachaScreen(); break;
            }
        });

        document.getElementById('growth-buttons')?.addEventListener('click', (e) => {
            const action = e.target.closest('button')?.dataset.action;
            if (!action || e.target.closest('button').disabled) return;
            
            switch(action) {
                case 'change-difficulty': renderDifficultyChangeScreen(); break;
                case 'change-class': createClassChangeScreen(); break;
                case 'rebirth':
                case 'liberation':
                    renderRebirthScreen();
                    break;
            }
        });

        document.querySelector('.name-change-icon')?.addEventListener('click', changePlayerName);
        document.querySelector('.player-class')?.addEventListener('click', () => {
             if (player.rebirths > 0) {
                createClassChangeScreen();
            } else {
                alert('직업 변경은 환생 후에 가능합니다.');
            }
        });
         document.querySelector('.dungeon-progress')?.addEventListener('click', () => {
             renderDifficultyChangeScreen();
         });
    }

    function changePlayerName() {
        const newName = prompt("새로운 이름을 입력하세요:", player.name);
        if (newName && newName.trim().length > 0) {
            player.name = newName.trim();
            saveGameState();
            renderTownScreen(); // Re-render to show the new name
        }
    }
    
    function startSurvivalMode() {
        currentScreen = 'SURVIVAL';
        survivalWave = 1;
        player.currentHp = player.maxHp; // Full heal before starting
        monster = createSurvivalMonster(survivalWave);
        renderBattleScreen(true);
    }
    
    function renderGachaScreen() {
        currentScreen = 'GACHA';
        root.innerHTML = `
            <div class="screen-container shop-container">
                <h1>뽑기</h1>
                <div class="gold-sp-display top-display">
                    <p>💰 골드: ${player.gold.toLocaleString()}</p>
                </div>
                <div class="shop-items">
                    <div class="shop-item">
                        <span>일반 뽑기 (1회)</span>
                        <button class="button" data-gacha-type="single">💰 ${GACHA_COST_SINGLE.toLocaleString()}</button>
                    </div>
                    <div class="shop-item">
                        <span>일반 뽑기 (10회)</span>
                        <button class="button" data-gacha-type="ten">💰 ${GACHA_COST_TEN.toLocaleString()}</button>
                    </div>
                    <p style="font-size: 0.7rem; color: var(--border-color); margin-top: 1rem;">
                        신화, 궁극, 영원 등급 장비와 일부 유물은 뽑기에서만 획득할 수 있습니다.
                    </p>
                </div>
                <div id="message-log" style="height: 200px; margin-top: 1rem;"></div>
                <button id="back-to-town" class="button">마을로 돌아가기</button>
            </div>
        `;

        messageLog = document.getElementById('message-log');

        document.querySelectorAll('[data-gacha-type]').forEach(button => {
            button.addEventListener('click', (e) => handleGacha(e.currentTarget.dataset.gachaType));
        });

        document.getElementById('back-to-town').addEventListener('click', renderTownScreen);
    }
    
    function handleGacha(type) {
        let cost = 0;
        let numDraws = 1;

        switch(type) {
            case 'single':
                cost = GACHA_COST_SINGLE;
                break;
            case 'ten':
                cost = GACHA_COST_TEN;
                numDraws = 10;
                break;
        }

        if (player.gold < cost) {
            alert('골드가 부족합니다.');
            return;
        }

        if (!canAddItem(numDraws)) {
            alert(`인벤토리에 최소 ${numDraws}칸의 여유 공간이 필요합니다.`);
            return;
        }

        player.gold -= cost;
        
        const results = [];
        let logMessage = `${numDraws}회 뽑기 결과:<br>`;
        
        for (let i = 0; i < numDraws; i++) {
            const result = performGachaDraw();
            results.push(result);
        }

        let totalStonesGained = 0;
        let highestRarity = 'common';
        const rarityOrder = ['common', 'uncommon', 'rare', 'legendary', 'mythic', 'ultimate', 'eternal'];

        results.forEach(result => {
            if (result.id) { // It's an item
                player.inventory.push(result);
                logMessage += `<span class="rarity-${result.rarity}">${result.name}</span>, `;
                if (rarityOrder.indexOf(result.rarity) > rarityOrder.indexOf(highestRarity)) {
                    highestRarity = result.rarity;
                }
            } else { // It's stones
                player.enhancementStones += result.count;
                totalStonesGained += result.count;
                logMessage += `<span class="rarity-${result.rarity}">${result.name} x${result.count}</span>, `;
            }
        });

        addMessage(logMessage.slice(0, -2));
        
        if (numDraws > 1) {
            alert(`획득한 최고 등급 아이템: ${highestRarity.charAt(0).toUpperCase() + highestRarity.slice(1)}`);
        }

        // Re-render to update gold display
        renderGachaScreen();
    }


    // --- IMPLEMENTED MISSING SCREENS & LOGIC ---

    function renderShopScreen() {
        currentScreen = 'SHOP';

        const renderItems = () => {
            const itemsContainer = document.getElementById('shop-items-container');
            if (!itemsContainer) return;
            
            const filteredItems = ITEM_DATABASE.filter(item => {
                if (item.isGachaOnly) return false;
                const typeMatch = shopFilterType === 'all' || item.type === shopFilterType;
                const rarityMatch = shopFilterRarity === 'all' || item.rarity === shopFilterRarity;
                return typeMatch && rarityMatch;
            });
            
            itemsContainer.innerHTML = filteredItems.map(item => `
                <div class="shop-item">
                    <span>
                        <span class="rarity-${item.rarity}">${item.name}</span>
                        <span class="item-class">(${item.type})</span>
                    </span>
                    <button class="button buy-btn" data-item-id="${item.id}">💰 ${item.cost.toLocaleString()}</button>
                </div>
            `).join('') || '<p>표시할 아이템이 없습니다.</p>';

            document.querySelectorAll('.buy-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    const itemId = parseInt(e.target.dataset.itemId, 10);
                    const itemData = ITEM_DATABASE.find(i => i.id === itemId);
                    if (!itemData) return;

                    if (isInventoryFull()) {
                        alert('인벤토리가 가득 찼습니다.');
                        return;
                    }

                    if (player.gold >= itemData.cost) {
                        player.gold -= itemData.cost;
                        player.inventory.push(createItemInstance(itemId));
                        alert(`${itemData.name}을(를) 구매했습니다.`);
                        renderShopScreen(); // Re-render to update gold
                    } else {
                        alert('골드가 부족합니다.');
                    }
                });
            });
        };
        
        root.innerHTML = `
            <div class="screen-container shop-container">
                <h1>상점</h1>
                <div class="gold-sp-display top-display">
                    <p>💰 골드: ${player.gold.toLocaleString()}</p>
                    <p>🎒 가방: ${player.inventory.length} / ${INVENTORY_LIMIT}</p>
                </div>

                <div class="shop-items" style="flex-grow: 0; margin-bottom: 1rem;">
                    <h3 style="margin: 0 0 0.5rem 0; font-size: 1rem;">소모품</h3>
                    <div class="shop-item">
                        <span>🧪 HP 물약 (HP 60% 회복)</span>
                        <button class="button buy-potion-btn" data-potion-type="hp">💰 ${POTION_COST}</button>
                    </div>
                    <div class="shop-item">
                        <span>🗡️ 공격 물약 (3턴간 공격력 +30%)</span>
                        <button class="button buy-potion-btn" data-potion-type="attack">💰 ${ATTACK_POTION_COST}</button>
                    </div>
                </div>

                <h3 style="margin: 0 0 0.5rem 0; font-size: 1rem;">장비</h3>
                <div class="shop-filters">
                    <div class="filter-group" id="type-filters">
                        <button class="filter-btn ${shopFilterType === 'all' ? 'active' : ''}" data-type="all">전체</button>
                        <button class="filter-btn ${shopFilterType === 'weapon' ? 'active' : ''}" data-type="weapon">무기</button>
                        <button class="filter-btn ${shopFilterType === 'armor' ? 'active' : ''}" data-type="armor">방어구</button>
                        <button class="filter-btn ${shopFilterType === 'accessory' ? 'active' : ''}" data-type="accessory">장신구</button>
                        <button class="filter-btn ${shopFilterType === 'relic' ? 'active' : ''}" data-type="relic">유물</button>
                    </div>
                    <div class="filter-group" id="rarity-filters">
                         <button class="filter-btn ${shopFilterRarity === 'all' ? 'active' : ''}" data-rarity="all">전체</button>
                         <button class="filter-btn ${shopFilterRarity === 'common' ? 'active' : ''}" data-rarity="common">일반</button>
                         <button class="filter-btn ${shopFilterRarity === 'uncommon' ? 'active' : ''}" data-rarity="uncommon">고급</button>
                         <button class="filter-btn ${shopFilterRarity === 'rare' ? 'active' : ''}" data-rarity="rare">희귀</button>
                         <button class="filter-btn ${shopFilterRarity === 'legendary' ? 'active' : ''}" data-rarity="legendary">전설</button>
                    </div>
                </div>
                <div class="shop-items" id="shop-items-container"></div>
                <button id="back-to-town" class="button">마을로 돌아가기</button>
            </div>
        `;
        
        document.getElementById('type-filters').addEventListener('click', e => {
            if (e.target.matches('.filter-btn')) {
                shopFilterType = e.target.dataset.type;
                renderShopScreen();
            }
        });

        document.getElementById('rarity-filters').addEventListener('click', e => {
            if (e.target.matches('.filter-btn')) {
                shopFilterRarity = e.target.dataset.rarity;
                renderShopScreen();
            }
        });

        document.querySelectorAll('.buy-potion-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                const type = e.target.dataset.potionType;
                if (type === 'hp') {
                    if (player.gold >= POTION_COST) {
                        player.gold -= POTION_COST;
                        player.potions++;
                        alert('HP 물약을 구매했습니다.');
                        renderShopScreen();
                    } else {
                        alert('골드가 부족합니다.');
                    }
                } else if (type === 'attack') {
                    if (player.gold >= ATTACK_POTION_COST) {
                        player.gold -= ATTACK_POTION_COST;
                        player.attackPotions++;
                        alert('공격 물약을 구매했습니다.');
                        renderShopScreen();
                    } else {
                        alert('골드가 부족합니다.');
                    }
                }
            });
        });

        renderItems();
        document.getElementById('back-to-town').addEventListener('click', renderTownScreen);
    }
    
    function renderEquipmentScreen() {
        currentScreen = 'EQUIPMENT';

        const getItemCardHTML = (item, index = -1, isEquipped = false) => {
            if (!item) {
                return '<div class="item-card empty">(비어있음)</div>';
            }
            const itemWithStats = getItemWithStats(item);
            const isRestricted = !item.classRestriction.includes(player.className);

            let statsText = Object.entries(itemWithStats.stats)
                .map(([stat, value]) => {
                     const keyMap = { maxHp: 'HP', attackPower: '공격', defense: '방어', critChance: '치명', evadeChance: '회피', critDamage: '치피' };
                     return `${keyMap[stat] || stat}: ${stat.includes('Chance') || stat.includes('Damage') ? (value*100).toFixed(0)+'%' : value}`;
                })
                .join(', ');
            let enhancementText = item.enhancementLevel > 0 ? `+${item.enhancementLevel}` : '';
            if (item.transcendenceLevel > 0) enhancementText += ` (T${item.transcendenceLevel})`;
            
            return `
                <div class="item-card ${isRestricted ? 'restricted' : ''} ${item.isLocked ? 'locked' : ''}" 
                     data-index="${index}" data-type="${item.type}" ${isEquipped ? 'data-equipped="true"' : ''}>
                    ${isRestricted ? '<div class="restricted-overlay">직업 제한</div>' : ''}
                    ${index !== -1 ? `<div class="lock-icon" data-lock-index="${index}">${item.isLocked ? '🔒' : '🔓'}</div>` : ''}
                    <p class="item-name rarity-${item.rarity}">${item.name} ${enhancementText}</p>
                    <p class="item-class">${item.type}</p>
                    <p class="item-stats">${statsText}</p>
                    ${item.enchantment ? `<p class="item-enchantment">${item.enchantment.description}</p>` : ''}
                </div>`;
        };
        
        root.innerHTML = `
            <div class="screen-container equipment-screen">
                <h1>장비</h1>
                <div class="equipment-slots">
                    ${['weapon', 'armor', 'accessory', 'relic'].map(slot => `
                        <div class="slot-container">
                            <h3>${{'weapon':'무기', 'armor':'방어구', 'accessory':'장신구', 'relic':'유물'}[slot]}</h3>
                            <div class="equipment-slot" data-slot-type="${slot}">
                                ${getItemCardHTML(player.equipment[slot], -1, true)}
                            </div>
                        </div>
                    `).join('')}
                </div>
                <h2 class="inventory-full" style="${isInventoryFull() ? '' : 'display: none;'}">인벤토리 가득 참!</h2>
                <h2 style="${isInventoryFull() ? 'display: none;' : ''}">인벤토리 (${player.inventory.length}/${INVENTORY_LIMIT})</h2>
                <div class="inventory-grid" id="inventory-grid">
                    ${player.inventory.map((item, index) => getItemCardHTML(item, index)).join('') || '<p style="grid-column: 1 / -1;">비어있음</p>'}
                </div>
                <div class="equipment-screen-footer">
                    <button id="back-to-town" class="button">마을로 돌아가기</button>
                </div>
            </div>
        `;

        document.getElementById('inventory-grid').addEventListener('click', e => {
            const lockIcon = e.target.closest('.lock-icon');
            if (lockIcon) {
                const index = parseInt(lockIcon.dataset.lockIndex, 10);
                player.inventory[index].isLocked = !player.inventory[index].isLocked;
                saveGameState();
                renderEquipmentScreen();
                return;
            }
            
            const card = e.target.closest('.item-card');
            if (card && !card.classList.contains('empty') && !card.classList.contains('restricted')) {
                const index = parseInt(card.dataset.index, 10);
                const item = player.inventory[index];
                if (!item) return;

                const equippedItem = player.equipment[item.type];
                player.equipment[item.type] = item;
                player.inventory.splice(index, 1);
                if (equippedItem) {
                    player.inventory.push(equippedItem);
                }
                updatePlayerStats();
                renderEquipmentScreen();
            }
        });

        document.querySelectorAll('.equipment-slot').forEach(slot => {
            slot.addEventListener('click', e => {
                const card = e.target.closest('.item-card');
                if (card && !card.classList.contains('empty')) {
                    if (isInventoryFull()) {
                        alert('인벤토리가 가득 찼습니다.');
                        return;
                    }
                    const slotType = slot.dataset.slotType;
                    const item = player.equipment[slotType];
                    player.equipment[slotType] = null;
                    player.inventory.push(item);
                    updatePlayerStats();
                    renderEquipmentScreen();
                }
            });
        });

        document.getElementById('back-to-town').addEventListener('click', renderTownScreen);
    }
    
    function renderBlacksmithScreen() {
        currentScreen = 'BLACKSMITH';

        const getItemCardHTML = (item, index = -1, mode = '') => {
            if (!item) {
                return `<div class="item-card empty" ${mode === 'transcend' ? 'style="height: 120px"' : ''}>(비어있음)</div>`;
            }
            const itemWithStats = getItemWithStats(item);

            let statsText = Object.entries(itemWithStats.stats)
                .map(([stat, value]) => `${stat}: ${value}`)
                .join(', ');
            let enhancementText = item.enhancementLevel > 0 ? `+${item.enhancementLevel}` : '';
            if (item.transcendenceLevel > 0) enhancementText += ` (T${item.transcendenceLevel})`;

            let cardClasses = 'item-card';
            let unselectable = false;
            if (mode === 'transcend') {
                const s0 = blacksmithSelection.transcend[0];
                if (s0 && (item.id !== s0.item.id || item.enhancementLevel > 0 || item.enchantment || s0.index === index)) {
                    unselectable = true;
                }
                if (item.enhancementLevel > 0 || item.enchantment) unselectable = true;
                if(s0 && s0.index === index) cardClasses += ' selected';
                 if(blacksmithSelection.transcend[1] && blacksmithSelection.transcend[1].index === index) cardClasses += ' selected';
                if(unselectable) cardClasses += ' unselectable';
            }
            
            return `
                <div class="${cardClasses}" data-index="${index}" data-type="${item.type}">
                    <p class="item-name rarity-${item.rarity}">${item.name} ${enhancementText}</p>
                    <p class="item-class">${item.type}</p>
                    <p class="item-stats">${statsText}</p>
                    ${item.enchantment ? `<p class="item-enchantment">${item.enchantment.description}</p>` : ''}
                </div>`;
        };

        const renderEnhanceTab = () => {
            const content = document.getElementById('blacksmith-content');
            if (!content) return;
            
            const selected = blacksmithSelection.enhance;
            let detailsHtml = '<h3>강화할 아이템을 선택하세요.</h3>';
            
            if (selected) {
                const item = selected.item;
                const level = item.enhancementLevel;
                const successChance = Math.max(0.05, 1 - (level * 0.045));
                const costGold = Math.round(100 * (level + 1) * Math.pow(1.2, level));
                const costStones = Math.round(5 * (level + 1) * Math.pow(1.1, level));
                const nextBonus = getEnhancementBonus(item, level + 1);
                const currentBonus = getEnhancementBonus(item, level);
                const bonusDiff = {};
                Object.keys(nextBonus).forEach(stat => {
                    bonusDiff[stat] = nextBonus[stat] - (currentBonus[stat] || 0);
                });

                detailsHtml = `
                    <h3>${item.name} +${level} 강화</h3>
                    <div class="enhancement-info">
                        <div class="info-row">
                            <span>성공 확률:</span>
                            <span>${(successChance * 100).toFixed(1)}%</span>
                        </div>
                        <div class="info-row">
                            <span>다음 능력치:</span>
                            <span class="next-stats">${Object.entries(bonusDiff).map(([s,v]) => `${s.slice(0,3)} +${v}`).join(', ')}</span>
                        </div>
                        <div class="info-row">
                            <span>비용:</span>
                            <span class="cost-display">💰${costGold.toLocaleString()} / 💎${costStones.toLocaleString()}</span>
                        </div>
                    </div>
                    <p class="penalty-info">${level >= 7 ? `실패 시 ${level >= 10 ? '30% 확률로' : ''} 강화 단계가 하락할 수 있습니다.` : '실패 페널티 없음'}</p>
                    <button id="enhance-button" class="button">강화하기</button>
                `;
            }

            content.innerHTML = `
                <div class="gold-sp-display top-display">
                    <p>💰 골드: ${player.gold.toLocaleString()}</p>
                    <p>💎 강화석: ${player.enhancementStones.toLocaleString()}</p>
                </div>
                <div class="enhancement-slots">
                    <div class="enhancement-slot">
                        ${selected ? getItemCardHTML(selected.item) : '<div class="item-card empty">(아이템을 선택하세요)</div>'}
                    </div>
                </div>
                <div id="enhancement-details">${detailsHtml}</div>
                <h2 style="margin-top:0.8rem;">인벤토리</h2>
                <div class="inventory-grid" id="blacksmith-inventory-grid">
                     ${player.inventory.map((item, index) => getItemCardHTML(item, index)).join('')}
                </div>
            `;

            if (selected) {
                document.getElementById('enhance-button')?.addEventListener('click', handleEnhance);
            }
        };

        const renderDisenchantTab = () => {
             const content = document.getElementById('blacksmith-content');
            if (!content) return;
            
            const updateSummary = () => {
                const summaryEl = document.getElementById('batch-disenchant-summary');
                if (!summaryEl) return;

                let itemsToDisenchant = [];
                let stonesGained = 0;
                let dustGained = 0;
                const rarityValues = { common: 1, uncommon: 2, rare: 5, legendary: 20, mythic: 50, ultimate: 150, eternal: 500 };

                player.inventory.forEach(item => {
                    if (!item.isLocked && batchDisenchantFilters[item.rarity]) {
                        itemsToDisenchant.push(item);
                        const baseValue = rarityValues[item.rarity] || 0;
                        stonesGained += Math.ceil(baseValue * (1 + item.enhancementLevel * 0.1));
                        dustGained += Math.ceil(baseValue * (1 + item.enhancementLevel * 0.05));
                    }
                });

                summaryEl.innerHTML = `
                    <p>선택된 아이템: <strong>${itemsToDisenchant.length}</strong>개</p>
                    <p>예상 획득 재료:</p>
                    <p>💎 강화석: <strong>${stonesGained.toLocaleString()}</strong></p>
                    <p>✨ 마법 부여 가루: <strong>${dustGained.toLocaleString()}</strong></p>
                `;
            };

            content.innerHTML = `
                <div class="gold-sp-display top-display">
                    <p>💎 강화석: ${player.enhancementStones.toLocaleString()}</p>
                    <p>✨ 마법 부여 가루: ${player.enchantmentDust.toLocaleString()}</p>
                </div>
                <div class="batch-disenchant-container">
                    <div class="batch-disenchant-filters">
                        <h3>일괄 분해 선택</h3>
                        <div class="filter-checkbox-group">
                            <label><input type="checkbox" data-rarity="common" ${batchDisenchantFilters.common ? 'checked' : ''}><span>일반</span></label>
                            <label><input type="checkbox" data-rarity="uncommon" ${batchDisenchantFilters.uncommon ? 'checked' : ''}><span>고급</span></label>
                            <label><input type="checkbox" data-rarity="rare" ${batchDisenchantFilters.rare ? 'checked' : ''}><span>희귀</span></label>
                        </div>
                         <p style="font-size:0.7rem; color: var(--border-color)">잠기지 않은 아이템만 분해됩니다.</p>
                    </div>
                    <div class="batch-disenchant-summary" id="batch-disenchant-summary"></div>
                    <button id="batch-disenchant-button" class="button">선택한 아이템 분해</button>
                </div>
            `;
            updateSummary();

            document.querySelectorAll('.filter-checkbox-group input').forEach(checkbox => {
                checkbox.addEventListener('change', e => {
                    batchDisenchantFilters[e.target.dataset.rarity] = e.target.checked;
                    updateSummary();
                });
            });

            document.getElementById('batch-disenchant-button')?.addEventListener('click', handleBatchDisenchant);
        };

        const renderTranscendTab = () => {
            const content = document.getElementById('blacksmith-content');
            if (!content) return;

            const [s0, s1] = blacksmithSelection.transcend;
            let resultItem = null;
            if(s0 && s1) {
                resultItem = createItemInstance(s0.item.id);
                resultItem.transcendenceLevel = s0.item.transcendenceLevel + 1;
            }
            const transcendCost = s0 ? Math.round(1000 * Math.pow(5, s0.item.transcendenceLevel + 1)) : 0;

            content.innerHTML = `
                 <div class="gold-sp-display top-display">
                    <p>💰 골드: ${player.gold.toLocaleString()}</p>
                </div>
                <div class="transcendence-container">
                    <div class="transcendence-main">
                        <div class="transcendence-slots">
                            <div class="transcendence-slot">${getItemCardHTML(s0?.item, s0?.index, 'transcend')}</div>
                            <span class="transcendence-symbol">+</span>
                            <div class="transcendence-slot">${getItemCardHTML(s1?.item, s1?.index, 'transcend')}</div>
                        </div>
                         <span class="transcendence-symbol">→</span>
                        <div class="transcendence-result-area">
                           ${resultItem ? getItemCardHTML(resultItem, -1, 'transcend') : '<div class="item-card empty" style="height: 120px;">(결과)</div>'}
                           ${resultItem ? `<p>💰 ${transcendCost.toLocaleString()}</p>` : ''}
                           <button id="transcend-button" class="button" ${!resultItem ? 'disabled' : ''}>초월</button>
                        </div>
                    </div>
                    <p style="font-size: 0.7rem; color: var(--border-color);">동일한 종류의 강화 및 마법 부여가 되지 않은 장비 2개를 합쳐 초월할 수 있습니다.</p>
                     <h2 style="margin-top:0.8rem;">인벤토리</h2>
                    <div class="inventory-grid transcendence-mode" id="blacksmith-inventory-grid">
                        ${player.inventory.map((item, index) => getItemCardHTML(item, index, 'transcend')).join('')}
                    </div>
                </div>
            `;
            if (resultItem) {
                document.getElementById('transcend-button')?.addEventListener('click', handleTranscend);
            }
        };

        const renderEnchantTab = () => {
             const content = document.getElementById('blacksmith-content');
            if (!content) return;
            
            const selected = blacksmithSelection.enchant;
            let detailsHtml = '<h3>마법 부여할 아이템을 선택하세요.</h3>';

            if (selected) {
                const item = selected.item;
                const pool = ENCHANTMENT_POOL[item.type]?.[item.rarity];
                const costGold = pool ? Math.round(500 * Math.pow(2.5, Object.keys(ENCHANTMENT_POOL[item.type]).indexOf(item.rarity))) : 0;
                const costDust = pool ? Math.round(50 * Math.pow(2, Object.keys(ENCHANTMENT_POOL[item.type]).indexOf(item.rarity))) : 0;
                
                detailsHtml = `
                    <h3>${item.name} 마법부여</h3>
                    <div class="enhancement-info">
                         ${item.enchantment ? `<p class="current-enchantment">현재 옵션: ${item.enchantment.description}</p>` : '<p>현재 옵션 없음</p>'}
                         <p class="enchant-warning">마법 부여 시 옵션이 무작위로 변경됩니다.</p>
                        <div class="info-row">
                            <span>비용:</span>
                            <span class="cost-display">💰${costGold.toLocaleString()} / ✨${costDust.toLocaleString()}</span>
                        </div>
                    </div>
                    <button id="enchant-button" class="button" ${!pool ? 'disabled' : ''}>마법 부여</button>
                `;
            }

             content.innerHTML = `
                <div class="gold-sp-display top-display">
                    <p>💰 골드: ${player.gold.toLocaleString()}</p>
                    <p>✨ 가루: ${player.enchantmentDust.toLocaleString()}</p>
                </div>
                <div class="enhancement-slots">
                     <div class="enhancement-slot">
                        ${selected ? getItemCardHTML(selected.item) : '<div class="item-card empty">(아이템을 선택하세요)</div>'}
                    </div>
                </div>
                <div id="enhancement-details">${detailsHtml}</div>
                 <h2 style="margin-top:0.8rem;">인벤토리</h2>
                <div class="inventory-grid" id="blacksmith-inventory-grid">
                     ${player.inventory.map((item, index) => getItemCardHTML(item, index)).join('')}
                </div>
            `;
            if (selected) {
                 document.getElementById('enchant-button')?.addEventListener('click', handleEnchant);
            }
        };
        
        const handleEnhance = () => {
            const selected = blacksmithSelection.enhance;
            if(!selected) return;

            const item = selected.item;
            const level = item.enhancementLevel;
            const successChance = Math.max(0.05, 1 - (level * 0.045));
            const costGold = Math.round(100 * (level + 1) * Math.pow(1.2, level));
            const costStones = Math.round(5 * (level + 1) * Math.pow(1.1, level));

            if (player.gold < costGold || player.enhancementStones < costStones) {
                alert('재료가 부족합니다.');
                return;
            }

            player.gold -= costGold;
            player.enhancementStones -= costStones;

            if (Math.random() < successChance) {
                item.enhancementLevel++;
                alert(`강화 성공! ${item.name}이(가) +${item.enhancementLevel}이 되었습니다.`);
                updateQuestProgress('ENHANCE_SUCCESS', item.enhancementLevel);
            } else {
                let message = '강화 실패...';
                if (level >= 10 && Math.random() < 0.3) {
                    item.enhancementLevel = Math.max(0, item.enhancementLevel - 1);
                    message += ` 강화 단계가 +${item.enhancementLevel}(으)로 하락했습니다.`;
                } else if (level >= 7 && level < 10) {
                     item.enhancementLevel = Math.max(0, item.enhancementLevel - 1);
                     message += ` 강화 단계가 +${item.enhancementLevel}(으)로 하락했습니다.`;
                }
                alert(message);
            }
            updatePlayerStats();
            renderBlacksmithScreen();
        };

        const handleBatchDisenchant = () => {
             const rarityValues = { common: 1, uncommon: 2, rare: 5, legendary: 20, mythic: 50, ultimate: 150, eternal: 500 };
             let itemsToDisenchantIndices = [];
             let stonesGained = 0;
             let dustGained = 0;

            player.inventory.forEach((item, index) => {
                if (!item.isLocked && batchDisenchantFilters[item.rarity]) {
                    itemsToDisenchantIndices.push(index);
                    const baseValue = rarityValues[item.rarity] || 0;
                    stonesGained += Math.ceil(baseValue * (1 + item.enhancementLevel * 0.1));
                    dustGained += Math.ceil(baseValue * (1 + item.enhancementLevel * 0.05));
                }
            });

            if (itemsToDisenchantIndices.length === 0) {
                alert('분해할 아이템이 없습니다.');
                return;
            }

            if(confirm(`${itemsToDisenchantIndices.length}개의 아이템을 분해하시겠습니까?`)) {
                // Remove items from inventory, iterating backwards to avoid index shifting issues
                for (let i = itemsToDisenchantIndices.length - 1; i >= 0; i--) {
                    player.inventory.splice(itemsToDisenchantIndices[i], 1);
                }

                player.enhancementStones += stonesGained;
                player.enchantmentDust += dustGained;
                alert(`분해 완료! 💎+${stonesGained}, ✨+${dustGained}`);
                renderBlacksmithScreen();
            }
        };

        const handleTranscend = () => {
            const [s0, s1] = blacksmithSelection.transcend;
            if (!s0 || !s1) return;

            const cost = Math.round(1000 * Math.pow(5, s0.item.transcendenceLevel + 1));
            if (player.gold < cost) {
                alert('골드가 부족합니다.');
                return;
            }

            player.gold -= cost;
            const newItem = createItemInstance(s0.item.id);
            newItem.transcendenceLevel = s0.item.transcendenceLevel + 1;

            const indicesToRemove = [s0.index, s1.index].sort((a,b) => b-a);
            indicesToRemove.forEach(index => player.inventory.splice(index, 1));
            
            player.inventory.push(newItem);
            
            blacksmithSelection.transcend = [null, null];
            updateQuestProgress('TRANSCEND', newItem.transcendenceLevel);
            if (newItem.transcendenceLevel === 1) updateQuestProgress('TRANSCEND', 1); // For the "first transcend" quest
            alert(`${newItem.name}(T${newItem.transcendenceLevel}) 초월에 성공했습니다!`);
            renderBlacksmithScreen();
        };

        const handleEnchant = () => {
            const selected = blacksmithSelection.enchant;
            if(!selected) return;

            const item = selected.item;
            const pool = ENCHANTMENT_POOL[item.type]?.[item.rarity];
            if (!pool) {
                alert('이 아이템은 마법 부여를 할 수 없습니다.');
                return;
            }
            
            const costGold = Math.round(500 * Math.pow(2.5, Object.keys(ENCHANTMENT_POOL[item.type]).indexOf(item.rarity)));
            const costDust = Math.round(50 * Math.pow(2, Object.keys(ENCHANTMENT_POOL[item.type]).indexOf(item.rarity)));
            
             if (player.gold < costGold || player.enchantmentDust < costDust) {
                alert('재료가 부족합니다.');
                return;
            }
            
            player.gold -= costGold;
            player.enchantmentDust -= costDust;

            const newEnchantment = pool[Math.floor(Math.random() * pool.length)];
            item.enchantment = newEnchantment;
            
            alert(`마법 부여 성공! 새로운 옵션: ${newEnchantment.description}`);
            updatePlayerStats();
            renderBlacksmithScreen();
        };

        root.innerHTML = `
            <div class="screen-container blacksmith-screen">
                <h1>대장간</h1>
                 <div class="blacksmith-tabs">
                    <button class="tab-button ${blacksmithMode === 'enhance' ? 'active' : ''}" data-mode="enhance">강화</button>
                    <button class="tab-button ${blacksmithMode === 'disenchant' ? 'active' : ''}" data-mode="disenchant">분해</button>
                    <button class="tab-button ${blacksmithMode === 'transcend' ? 'active' : ''}" data-mode="transcend">초월</button>
                    <button class="tab-button ${blacksmithMode === 'enchant' ? 'active' : ''}" data-mode="enchant">마법부여</button>
                </div>
                <div id="blacksmith-content"></div>
                <button id="back-to-town" class="button">마을로 돌아가기</button>
            </div>
        `;

        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.addEventListener('click', e => {
                blacksmithMode = e.target.dataset.mode;
                blacksmithSelection = { enhance: null, enchant: null, transcend: [null, null] }; // Reset selections on tab change
                renderBlacksmithScreen();
            });
        });
        
        switch(blacksmithMode) {
            case 'enhance': renderEnhanceTab(); break;
            case 'disenchant': renderDisenchantTab(); break;
            case 'transcend': renderTranscendTab(); break;
            case 'enchant': renderEnchantTab(); break;
        }

        const inventoryGrid = document.getElementById('blacksmith-inventory-grid');
        if (inventoryGrid) {
            inventoryGrid.addEventListener('click', e => {
                const card = e.target.closest('.item-card');
                if (card && card.dataset.index) {
                    const index = parseInt(card.dataset.index, 10);
                    const item = player.inventory[index];
                    if (blacksmithMode === 'enhance') {
                        blacksmithSelection.enhance = { item, index };
                    } else if (blacksmithMode === 'enchant') {
                         blacksmithSelection.enchant = { item, index };
                    } else if (blacksmithMode === 'transcend' && !card.classList.contains('unselectable')) {
                        const [s0, s1] = blacksmithSelection.transcend;
                        if (s0 && s0.index === index) {
                            blacksmithSelection.transcend[0] = s1;
                            blacksmithSelection.transcend[1] = null;
                        } else if (s1 && s1.index === index) {
                            blacksmithSelection.transcend[1] = null;
                        } else if (!s0) {
                            blacksmithSelection.transcend[0] = { item, index };
                        } else if (!s1) {
                             blacksmithSelection.transcend[1] = { item, index };
                        }
                    }
                    renderBlacksmithScreen();
                }
            });
        }

        document.getElementById('back-to-town').addEventListener('click', renderTownScreen);
    }

    function renderSkillTreeScreen() {
        currentScreen = 'SKILL_TREE';
        const classSkills = SKILL_DATA[player.className];
        
        root.innerHTML = `
             <div class="screen-container skill-tree-screen">
                <h1>스킬 트리</h1>
                <div class="gold-sp-display top-display">
                    <p>💰 골드: ${player.gold.toLocaleString()}</p>
                </div>
                <div class="skill-list">
                    ${Object.values(classSkills).map(skill => {
                        const currentLevel = player.skills[skill.id] || 0;
                        const maxLevel = skill.maxLevel || 5;
                        const cost = skill.cost(currentLevel);
                        let status = 'locked';
                        let canLearn = true;

                        if (currentLevel >= maxLevel) {
                            status = 'maxed';
                        } else {
                            for (const pre of skill.prerequisites) {
                                if ((player.skills[pre.id] || 0) < pre.level) {
                                    canLearn = false;
                                    break;
                                }
                            }
                            if (canLearn && player.gold >= cost) status = 'learnable';
                            else if(canLearn) status = 'learned'; // Not enough gold, but prerequisites met
                        }

                        return `
                        <div class="skill-node ${status} ${!canLearn ? 'locked' : ''}">
                            <div class="skill-info">
                                <h3>${skill.name} (${currentLevel}/${maxLevel})</h3>
                                <p>${skill.description(currentLevel)}</p>
                                <small>요구사항: ${skill.prerequisites.map(p => `${SKILL_DATA[player.className][p.id].name} ${p.level}레벨`).join(', ') || '없음'}</small>
                            </div>
                            <button class="learn-skill-btn button" data-skill-id="${skill.id}" ${status !== 'learnable' ? 'disabled' : ''}>
                                ${currentLevel > 0 ? '레벨업' : '배우기'} (💰${cost.toLocaleString()})
                            </button>
                        </div>`
                    }).join('')}
                </div>
                <button id="back-to-town" class="button">마을로 돌아가기</button>
            </div>
        `;
        
        document.querySelectorAll('.learn-skill-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                const skillId = e.target.dataset.skillId;
                const skill = classSkills[skillId];
                if (skill) {
                    const currentLevel = player.skills[skillId] || 0;
                    const cost = skill.cost(currentLevel);
                    if (player.gold >= cost) {
                        player.gold -= cost;
                        player.skills[skillId] = currentLevel + 1;
                        updatePlayerStats();
                        renderSkillTreeScreen();
                    } else {
                        alert('골드가 부족합니다.');
                    }
                }
            });
        });

        document.getElementById('back-to-town').addEventListener('click', renderTownScreen);
    }
    
    function renderQuestScreen() {
        currentScreen = 'QUESTS';
        root.innerHTML = `
            <div class="screen-container quest-screen">
                <h1>업적</h1>
                <div class="quest-list">
                    ${player.permanentQuests.map(q => {
                        const progressPercent = Math.min(100, (q.progress / q.target) * 100);
                        const canClaim = !q.completed && q.progress >= q.target;
                        let rewardText = Object.entries(q.reward).map(([key, value]) => {
                             const keyMap = { gold: '💰', stones: '💎', dust: '✨', potions: '🧪' };
                             return `${keyMap[key] || key} ${value}`;
                        }).join(', ');

                        return `
                        <div class="quest-item">
                            <div class="quest-info">
                                <p class="quest-description">${q.description}</p>
                                <div class="quest-progress-bar-container"><div class="quest-progress-bar" style="width: ${progressPercent}%"></div></div>
                                <p class="quest-progress-text">${q.progress.toLocaleString()} / ${q.target.toLocaleString()}</p>
                                <p class="quest-reward">보상: ${rewardText}</p>
                            </div>
                            <div class="quest-action">
                                ${q.completed 
                                    ? `<button class="button" disabled>완료</button>` 
                                    : `<button class="button" data-quest-id="${q.id}" ${!canClaim ? 'disabled' : ''}>받기</button>`}
                            </div>
                        </div>`
                    }).join('')}
                </div>
                <button id="back-to-town" class="button">마을로 돌아가기</button>
            </div>
        `;

        document.querySelectorAll('[data-quest-id]').forEach(btn => {
            btn.addEventListener('click', e => {
                const questId = e.target.dataset.questId;
                const quest = player.permanentQuests.find(q => q.id === questId);
                if (quest && !quest.completed && quest.progress >= quest.target) {
                    quest.completed = true;
                    if(quest.reward.gold) player.gold += quest.reward.gold;
                    if(quest.reward.stones) player.enhancementStones += quest.reward.stones;
                    if(quest.reward.dust) player.enchantmentDust += quest.reward.dust;
                    if(quest.reward.potions) player.potions += quest.reward.potions;
                    alert('보상을 받았습니다!');
                    renderQuestScreen();
                }
            });
        });
        document.getElementById('back-to-town').addEventListener('click', renderTownScreen);
    }
    
    function renderRebirthScreen() {
        currentScreen = 'REBIRTH';
        const pointsToGain = Math.floor(player.level / 10);
        
        let liberationHtml = '';
        if(player.rebirths >= 3 && !player.isLiberated) {
            liberationHtml = `
                <div class="rebirth-info" style="border: 2px solid var(--rarity-eternal); margin-top: 1rem;">
                    <h2 style="color: var(--rarity-eternal);">해방의 시험</h2>
                    <p>당신은 환생을 거듭하여 강력해졌습니다. 이제 마지막 시험을 통해 진정한 '해방'을 이룰 때입니다.</p>
                    <p>시험에 통과하면 SSS랭크를 달성하고, 궁극의 힘을 얻게 됩니다.</p>
                    <button id="liberation-challenge-button" class="button" style="background-color: var(--rarity-eternal); width:100%;">시험에 도전하기</button>
                </div>
            `;
        }
        
        root.innerHTML = `
            <div class="screen-container rebirth-screen">
                <h1>환생</h1>
                <div class="rebirth-info">
                    <p>현재 환생 횟수: ${player.rebirths}</p>
                    <p>현재 환생 포인트(RP): <span class="rebirth-points">${player.rebirthPoints}</span></p>
                    <p>환생 시 획득할 RP: <span class="rebirth-points">${pointsToGain}</span></p>
                    <p style="font-size:0.7rem; color: var(--border-color)">환생하면 레벨, 골드, 스킬이 초기화됩니다. 장비, 재료, 업적, 환생 업그레이드는 유지됩니다.</p>
                    <button class="button" id="rebirth-button" style="background-color: var(--rebirth-color); width: 100%;" ${player.level < REBIRTH_LEVEL_REQ ? 'disabled' : ''}>환생하기 (Lv. ${REBIRTH_LEVEL_REQ} 이상)</button>
                </div>

                <h2>영구 업그레이드</h2>
                <div class="rebirth-upgrades">
                    ${Object.entries(REBIRTH_UPGRADES).map(([id, upgrade]) => {
                        const currentLevel = player.rebirthUpgrades[id] || 0;
                        const maxLevel = upgrade.maxLevel || 10;
                        const cost = upgrade.cost(currentLevel);
                        const canUpgrade = player.rebirthPoints >= cost && currentLevel < maxLevel;

                        return `
                        <div class="rebirth-upgrade-item">
                            <div class="rebirth-upgrade-info">
                                <h3>${upgrade.name} (${currentLevel}/${maxLevel})</h3>
                                <p>${upgrade.description(currentLevel)}</p>
                            </div>
                            <button class="button" data-upgrade-id="${id}" ${!canUpgrade ? 'disabled' : ''}>RP ${cost}</button>
                        </div>`;
                    }).join('')}
                </div>
                ${liberationHtml}
                <button id="back-to-town" class="button">마을로 돌아가기</button>
            </div>
        `;

        document.getElementById('rebirth-button')?.addEventListener('click', () => {
            if (confirm(`정말로 환생하시겠습니까? 레벨 ${player.level} -> 1, 골드가 초기화됩니다.`)) {
                player.level = 1;
                player.xp = 0;
                player.nextLevelXp = 50;
                player.gold = 0;
                player.skills = {};
                player.rebirths++;
                player.rebirthPoints += pointsToGain;
                player.currentHp = player.maxHp;
                updateQuestProgress('REBIRTH', player.rebirths);
                updatePlayerStats();
                alert('환생했습니다! 더욱 강력해졌습니다.');
                renderTownScreen();
            }
        });
        
        document.querySelectorAll('[data-upgrade-id]').forEach(btn => {
            btn.addEventListener('click', e => {
                const id = e.target.dataset.upgradeId;
                const upgrade = REBIRTH_UPGRADES[id];
                const level = player.rebirthUpgrades[id] || 0;
                const cost = upgrade.cost(level);
                if (player.rebirthPoints >= cost) {
                    player.rebirthPoints -= cost;
                    player.rebirthUpgrades[id] = level + 1;
                    updatePlayerStats();
                    renderRebirthScreen();
                }
            });
        });

        document.getElementById('liberation-challenge-button')?.addEventListener('click', startLiberationChallenge);
        document.getElementById('back-to-town').addEventListener('click', renderTownScreen);
    }

    function renderDungeonMap() {
        let mapHtml = '<div class="dungeon-map">';
        const totalFloors = 5;
        for (let i = 1; i <= totalFloors; i++) {
            let nodeClass = 'map-node';
            const isBoss = i % 5 === 0;

            if (i < dungeonFloor) {
                nodeClass += ' cleared';
            } else if (i === dungeonFloor) {
                nodeClass += ' current';
            }
            
            if (isBoss) {
                nodeClass += ' boss';
            }
            
            const icon = isBoss ? '💀' : '';
            mapHtml += `<div class="${nodeClass}" title="${i}층">${icon}</div>`;
        }
        mapHtml += '</div>';
        return mapHtml;
    }

    function renderBattleScreen(isSurvival = false, isLiberation = false) {
        currentScreen = isLiberation ? 'LIBERATION_BATTLE' : isSurvival ? 'SURVIVAL' : 'BATTLE';
        removeGuideElements();
        
        const skillCollection = [ULTIMATE_SKILLS, ULTIMATE_SKILLS_2, ULTIMATE_SKILLS_3];
        const ultimateSkill = skillCollection
            .map(sc => sc[player.className])
            .filter(Boolean)
            .find(s => s.id === player.selectedUltimateId);
            
        let headerHtml = '';
        if (isLiberation) {
            headerHtml = `<h2 class="dungeon-progress" style="color: var(--rarity-eternal);">해방의 시험</h2>`;
        } else if (isSurvival) {
            headerHtml = `<h2 class="dungeon-progress" style="color: var(--survival-color);">서바이벌 - ${survivalWave} 웨이브</h2>`;
        } else {
            headerHtml = renderDungeonMap();
        }

        root.innerHTML = `
            <div id="game-world">
                ${headerHtml}
                <div class="character-card monster-card">
                    <h2>${monster.emoji} ${monster.name} ${monster.isBoss ? ' (보스)' : ''}</h2>
                    <div class="hp-bar-container">
                        <div class="hp-bar" style="width: ${monster.currentHp / monster.maxHp * 100}%;"></div>
                    </div>
                    <p>${monster.currentHp.toLocaleString()} / ${monster.maxHp.toLocaleString()}</p>
                    <div class="status-effects" id="monster-status-effects"></div>
                </div>

                <div class="character-card player-card">
                    ${renderPlayerCard(true)}
                </div>

                <div id="message-log" style="height: 100px; margin: 0.4rem 0;"></div>

                <div id="action-buttons">
                    <button data-action="attack" class="button">공격</button>
                    <button data-action="use-potion" class="button" ${isSurvival || isLiberation ? 'disabled' : ''}>물약 (${player.potions})</button>
                    <button data-action="use-attack-potion" class="button" ${isSurvival || isLiberation ? 'disabled' : ''}>공격 물약 (${player.attackPotions})</button>
                    <button data-action="ultimate-skill" class="button" ${player.ultimateSkill.cooldownLeft > 0 ? 'disabled' : ''}>
                       ${ultimateSkill ? ultimateSkill.name : '궁극기'} ${player.ultimateSkill.cooldownLeft > 0 ? `(${Math.ceil(player.ultimateSkill.cooldownLeft)})` : ''}
                    </button>
                    ${!isSurvival && !isLiberation ? `<button data-action="escape" class="button">마을로 돌아가기</button>` : ''}
                </div>
            </div>
        `;
        messageLog = document.getElementById('message-log');
        updateStatusEffectIcons('player-status-effects', player.statusEffects);
        updateStatusEffectIcons('monster-status-effects', monster.statusEffects);

        document.getElementById('action-buttons')?.addEventListener('click', (e) => {
            const action = e.target.closest('button')?.dataset.action;
            if (!action || e.target.closest('button').disabled) return;
            handleBattleAction(action, isSurvival, isLiberation);
        });

        if (player.statusEffects.stun) {
            document.getElementById('action-buttons').querySelectorAll('button').forEach(b => b.disabled = true);
            setTimeout(() => {
                if (currentScreen !== 'BATTLE' && currentScreen !== 'SURVIVAL' && currentScreen !== 'LIBERATION_BATTLE') return;
                addMessage(`${player.name}님은 기절해서 움직일 수 없습니다!`, 'rarity-mythic');
                
                applyStatusEffects(player, 'player');
                
                if (player.currentHp <= 0) {
                    handleDefeat(isSurvival, isLiberation);
                } else {
                    monsterTurn(isSurvival, isLiberation);
                }
            }, 500);
        }
    }

    // --- Data Management ---
    function saveGameState() {
        if (!player) return;
        const gameState = {
            player,
            currentDifficulty,
            dungeonLevel,
            dungeonFloor,
        };
        try {
            localStorage.setItem('simpleRPG_saveData', JSON.stringify(gameState));
        } catch (e) {
            console.error("Failed to save game state:", e);
        }
    }
    
    function loadGameState() {
        try {
            const savedData = localStorage.getItem('simpleRPG_saveData');
            if (savedData) {
                const gameState = JSON.parse(savedData);
                player = gameState.player;
                currentDifficulty = gameState.currentDifficulty || '보통';
                dungeonLevel = gameState.dungeonLevel || 1;
                dungeonFloor = gameState.dungeonFloor || 1;

                // Data migration for new features
                if (player.skillPoints !== undefined) delete player.skillPoints; // Remove old data
                if (!player.rebirths) player.rebirths = 0;
                if (!player.rebirthPoints) player.rebirthPoints = 0;
                if (!player.rebirthUpgrades) player.rebirthUpgrades = {};
                if (!player.enhancementStones) player.enhancementStones = 0;
                if (!player.enchantmentDust) player.enchantmentDust = 0;
                if (!player.equipment.accessory) player.equipment.accessory = null;
                if (!player.equipment.relic) player.equipment.relic = null;
                if (!player.permanentQuests || !Array.isArray(player.permanentQuests) || player.permanentQuests.length < PERMANENT_QUESTS_DATA.length) {
                     player.permanentQuests = PERMANENT_QUESTS_DATA.map(q => {
                        const existingQuest = player.permanentQuests?.find(pq => pq.id === q.id);
                        return existingQuest || {...q, progress: 0, completed: false};
                     });
                }
                if (player.isLiberated === undefined) player.isLiberated = false;
                if (!player.selectedUltimateId) player.selectedUltimateId = ULTIMATE_SKILLS[player.className].id;
                if (!player.unlockedUltimates) player.unlockedUltimates = [ULTIMATE_SKILLS[player.className].id];
                player.inventory.forEach(item => {
                    if (item.isLocked === undefined) item.isLocked = false;
                    if (item.transcendenceLevel === undefined) item.transcendenceLevel = 0;
                });

                updatePlayerStats();
                return true;
            }
            return false;
        } catch (e) {
            console.error("Failed to load game state:", e);
            return false;
        }
    }

    function deleteSaveData(showConfirmation = true) {
        localStorage.removeItem('simpleRPG_saveData');
        if (showConfirmation) {
            alert('저장된 데이터가 삭제되었습니다.');
            createStartScreen();
        }
    }


    // --- Game Logic & Battle Flow ---
    function handleBattleAction(action, isSurvival = false, isLiberation = false) {
        if (player.currentHp <= 0 || player.statusEffects.stun) return;

        let playerTurnHandled = false;
        switch(action) {
            case 'attack':
                playerAttack();
                playerTurnHandled = true;
                break;
            case 'use-potion':
                if (player.potions > 0) {
                    const healAmount = Math.round(player.maxHp * POTION_HEAL_PERCENT);
                    player.currentHp = Math.min(player.maxHp, player.currentHp + healAmount);
                    player.potions--;
                    addMessage(`물약을 사용해 ${healAmount}의 HP를 회복했습니다.`, 'rarity-uncommon');
                    playerTurnHandled = true;
                } else {
                    addMessage('물약이 없습니다!', 'rarity-mythic');
                }
                break;
            case 'use-attack-potion':
                 if (player.attackPotions > 0) {
                    player.attackPotions--;
                    applyBuff(player, '공격 강화', { stat: 'attackPower', value: 0.3, duration: 3, isPercent: true });
                    addMessage(`공격 물약을 사용해 3턴간 공격력이 30% 증가합니다!`, 'rarity-rare');
                    playerTurnHandled = true;
                } else {
                    addMessage('공격 물약이 없습니다!', 'rarity-mythic');
                }
                break;
            case 'ultimate-skill':
                if (player.ultimateSkill.cooldownLeft <= 0) {
                    useUltimateSkill();
                    playerTurnHandled = true;
                    updateQuestProgress('USE_ULTIMATE', 1);
                }
                break;
            case 'escape':
                handleEscape();
                return;
        }

        if (playerTurnHandled) {
            renderBattleScreen(isSurvival, isLiberation);
            
            if (monster.currentHp > 0) {
                applyStatusEffects(player, 'player');
                if (player.currentHp <= 0) {
                    setTimeout(() => handleDefeat(isSurvival, isLiberation), 300);
                } else {
                    if (!player.statusEffects.stun) {
                         setTimeout(() => monsterTurn(isSurvival, isLiberation), 300);
                    } else {
                         setTimeout(() => renderBattleScreen(isSurvival, isLiberation), 300);
                    }
                }
            } else {
                setTimeout(() => handleVictory(isSurvival, isLiberation), 300);
            }
        }
    }

    function playerAttack() {
        const guaranteedCritBuff = player.buffs['확정 치명타'];
        const isCrit = guaranteedCritBuff || Math.random() < player.critChance;
        let damage = player.attackPower;

        if (isCrit) {
            damage *= player.critDamage;
            if (guaranteedCritBuff) {
                delete player.buffs['확정 치명타'];
            }
        }
        
        const executeSkill = player.skills['r_execute_1'];
        if (executeSkill && monster.currentHp / monster.maxHp <= 0.25) {
            damage *= 1.2;
        }

        if (monster.statusEffects.vulnerable) {
            damage *= (1 + monster.statusEffects.vulnerable.potency);
        }

        const finalDamage = Math.max(1, Math.round(damage - (monster.defense || 0)));
        monster.currentHp = Math.max(0, monster.currentHp - finalDamage);
        
        let message = `${player.name}의 공격! ${monster.name}에게 ${finalDamage}의 피해.`;
        if (isCrit) message = `💥 치명타! ${message}`;
        addMessage(message);
    }

     function useUltimateSkill() {
        const skillCollection = [ULTIMATE_SKILLS, ULTIMATE_SKILLS_2, ULTIMATE_SKILLS_3];
        const skillData = skillCollection
            .map(sc => sc[player.className])
            .filter(Boolean)
            .find(s => s.id === player.selectedUltimateId);
        
        if (!skillData) return;

        const skillLevel = (player.skills[skillData.id] || 0) + 1;
        const effect = skillData.effect(skillLevel);

        addMessage(effect.message, 'rarity-legendary');

        if (effect.damageMultiplier || effect.initialDamageMultiplier) {
            const hits = effect.hits || 1;
            for (let i = 0; i < hits; i++) {
                if (monster.currentHp <= 0) break;
                let damage = player.attackPower * (effect.initialDamageMultiplier || effect.damageMultiplier);
                if(effect.damageFalloff) damage *= Math.pow(effect.damageFalloff, i);
                
                if (effect.executeMultiplier) {
                    const missingHpPercent = (1 - (monster.currentHp / monster.maxHp)) * 100;
                    damage += damage * (missingHpPercent * effect.executeMultiplier);
                }
                
                let monsterDef = monster.defense || 0;
                if(effect.defensePenetration) {
                    monsterDef *= (1 - effect.defensePenetration);
                }
                
                const finalDamage = Math.max(1, Math.round(damage - monsterDef));
                monster.currentHp -= finalDamage;
                addMessage(`[${skillData.name}] 효과로 ${finalDamage}의 피해!`);
            }
        }
        
        if (effect.buff) applyBuff(player, effect.buff.name, effect.buff);
        if (effect.buff2) applyBuff(player, effect.buff2.name, effect.buff2);
        if (effect.debuff) applyBuff(player, effect.debuff.name, effect.debuff);
        if (effect.statusEffect) applyStatusEffect(monster, effect.statusEffect);
        
        player.ultimateSkill.cooldownLeft = skillData.cooldown;
    }
    
    function monsterTurn(isSurvival, isLiberation) {
        if (currentScreen !== 'BATTLE' && currentScreen !== 'SURVIVAL' && currentScreen !== 'LIBERATION_BATTLE') return;
        
        applyStatusEffects(monster, 'monster');
        
        if (monster.currentHp <= 0) {
            handleVictory(isSurvival, isLiberation);
            return;
        }

        if (monster.statusEffects.stun) {
            addMessage(`${monster.name}이 기절해서 움직일 수 없습니다.`, 'rarity-legendary');
        } else {
            monsterAttack();
            if (player.currentHp <= 0) {
                handleDefeat(isSurvival, isLiberation);
                return;
            }
        }
        
        endTurn(isSurvival, isLiberation);
    }
    
    function monsterAttack() {
        if (Math.random() < player.evadeChance) {
            addMessage(`${player.name}님이 ${monster.name}의 공격을 회피했습니다!`, 'rarity-uncommon');
            return;
        }

        let damage = monster.attack;
        if(player.statusEffects.weaken) {
            damage *= (1 - player.statusEffects.weaken.potency);
        }
        
        const finalDamage = Math.max(1, Math.round(damage - player.defense));
        player.currentHp = Math.max(0, player.currentHp - finalDamage);
        
        addMessage(`${monster.name}의 공격! ${player.name}님은 ${finalDamage}의 피해를 입었습니다.`, 'rarity-mythic');

        if (monster.onHitEffect && Math.random() < monster.onHitEffect.chance) {
            applyStatusEffect(player, monster.onHitEffect);
        }
    }

    function handleEscape() {
        alert(`마을로 안전하게 돌아갑니다.`);
        dungeonFloor = 1; // Reset floor progress on escape
        renderTownScreen();
    }

    function handleVictory(isSurvival, isLiberation) {
        if (isLiberation) {
            player.isLiberated = true;
            updateQuestProgress('LIBERATION', 1);
            alert('축하합니다! 해방의 시험을 통과했습니다! 당신은 이제 진정한 경지에 올랐습니다.');
            player.gold += monster.gold;
            updateQuestProgress('COLLECT_GOLD', monster.gold);
            saveGameState();
            setTimeout(renderTownScreen, 1200);
            return;
        }
        
        addMessage(`승리! ${monster.name}을(를) 처치했습니다!`, 'rarity-uncommon');

        if(isSurvival){
            survivalWave++;
            addMessage(`${survivalWave} 웨이브 시작!`, 'rarity-legendary');
            player.currentHp = Math.min(player.maxHp, player.currentHp + Math.round(player.maxHp * 0.1));
            monster = createSurvivalMonster(survivalWave);
            setTimeout(() => renderBattleScreen(true, false), 1000);
            return;
        }

        player.xp += monster.xp;
        player.gold += monster.gold;
        updateQuestProgress('COLLECT_GOLD', monster.gold);
        if(monster.isBoss) updateQuestProgress('DEFEAT_BOSS', 1, monster.name);
        addMessage(`${monster.xp} XP와 ${monster.gold} 골드를 획득했습니다.`, 'rarity-rare');

        if (monster.lootTable && Math.random() < 0.3) {
            if (!isInventoryFull()) {
                const itemId = monster.lootTable[Math.floor(Math.random() * monster.lootTable.length)];
                const item = createItemInstance(itemId);
                if (item) {
                    player.inventory.push(item);
                    addMessage(`아이템 획득: <span class="rarity-${item.rarity}">${item.name}</span>`);
                }
            } else {
                addMessage('인벤토리가 가득 차 아이템을 획득할 수 없습니다!', 'rarity-mythic');
            }
        }
        
        while (player.xp >= player.nextLevelXp) {
            player.level++;
            player.xp -= player.nextLevelXp;
            player.nextLevelXp = Math.round(player.nextLevelXp * 1.15);
            addMessage(`레벨 업! ${player.level} 레벨!`, 'rarity-legendary');
            player.currentHp = player.maxHp;
            updateQuestProgress('REACH_LEVEL', player.level);
        }
        
        dungeonFloor++;
        if (dungeonFloor > 5) {
            dungeonFloor = 1;
            dungeonLevel++;
            addMessage(`던전 ${dungeonLevel}층에 도달했습니다!`, 'rarity-rare');
        }

        saveGameState();
        addMessage(`${dungeonFloor}층으로 이동합니다...`, 'rarity-uncommon');
        setTimeout(() => {
            createMonster();
            renderBattleScreen();
        }, 1000);
    }

    function handleDefeat(isSurvival, isLiberation) {
        if (DIFFICULTY_SETTINGS[currentDifficulty].isHardcore) {
            alert('사망했습니다. 하드코어 모드에서는 모든 진행 상황이 초기화됩니다.');
            deleteSaveData(false);
            createStartScreen();
            return;
        }

        addMessage('패배했습니다...', 'rarity-mythic');
        if (isLiberation) {
            alert('해방의 시험에 실패했습니다... 더욱 강해져서 돌아오십시오.');
            renderTownScreen();
            return;
        }

        if (isSurvival) {
            const finalWave = survivalWave - 1;
            const rewardGold = finalWave * SURVIVAL_REWARD_MULTIPLIER;
            player.gold += rewardGold;
            updateQuestProgress('COLLECT_GOLD', rewardGold);
            alert(`서바이벌 종료! 최종 웨이브: ${finalWave}\n획득 골드: ${rewardGold.toLocaleString()}`);
            renderTownScreen();
            return;
        }

        const goldPenalty = Math.round(player.gold * DEFEAT_GOLD_PENALTY);
        player.gold = Math.max(0, player.gold - goldPenalty);
        addMessage(`${goldPenalty} 골드를 잃었습니다.`);
        dungeonLevel = 1;
        dungeonFloor = 1;
        addMessage('던전 진행 상황이 처음으로 초기화됩니다.');
        
        saveGameState();
        setTimeout(renderTownScreen, 1200);
    }
    
    function endTurn(isSurvival, isLiberation) {
        updateBuffs(player);
        updateStatusEffectsDuration(player);
        updateStatusEffectsDuration(monster);

        if(player.ultimateSkill.cooldownLeft > 0) {
            const cooldownReduction = 1 + (player.rebirthUpgrades.ultimate_cooldown ? (player.rebirthUpgrades.ultimate_cooldown * 0.05) : 0);
            player.ultimateSkill.cooldownLeft = Math.max(0, player.ultimateSkill.cooldownLeft - cooldownReduction);
        }
        
        renderBattleScreen(isSurvival, isLiberation);
    }

    function applyStatusEffect(target, effect) {
        if (Math.random() >= (effect.chance || 1.0)) return;
        const effectInfo = STATUS_EFFECT_DEFINITIONS[effect.type];
        if(!effectInfo) return;
        
        const existingEffect = target.statusEffects[effect.type];
        if(existingEffect) {
            existingEffect.duration = Math.max(existingEffect.duration, effect.duration);
            existingEffect.potency = Math.max(existingEffect.potency || 0, effect.potency || 0);
        } else {
             target.statusEffects[effect.type] = { ...effect };
        }
        
        addMessage(`${target.name || target.emoji}이(가) [${effectInfo.name}] 상태이상에 걸렸습니다!`);
    }

    function applyStatusEffects(character, charType) {
        let totalDamage = 0;
        if (character.statusEffects.poison) {
            const damage = character.statusEffects.poison.potency;
            character.currentHp -= damage;
            totalDamage += damage;
        }
        if (character.statusEffects.burn) {
            let damage = character.statusEffects.burn.potency;
            if (charType === 'player' && player.skills['m_burn_1']) {
                damage *= (1 + (player.skills['m_burn_1'] * 0.1));
            }
            damage = Math.round(damage);
            character.currentHp -= damage;
            totalDamage += damage;
        }
        if (totalDamage > 0) {
             addMessage(`지속 피해로 ${character.name || character.emoji}이(가) ${totalDamage}의 피해를 입었습니다.`);
        }
        character.currentHp = Math.max(0, character.currentHp);
    }
    
    function updateStatusEffectIcons(elementId, effects) {
        const container = document.getElementById(elementId);
        if(!container) return;
        container.innerHTML = Object.entries(effects).map(([type, effect]) => {
            const def = STATUS_EFFECT_DEFINITIONS[type];
            return `<span class="status-effect-icon" title="${def.name}">${def.icon} (${effect.duration})</span>`;
        }).join('');
    }

    function updateStatusEffectsDuration(character) {
        for (const type in character.statusEffects) {
            character.statusEffects[type].duration--;
            if (character.statusEffects[type].duration <= 0) {
                delete character.statusEffects[type];
                addMessage(`${character.name || character.emoji}의 [${STATUS_EFFECT_DEFINITIONS[type].name}] 효과가 사라졌습니다.`);
            }
        }
    }
    
    function applyBuff(character, buffName, buffData) {
        character.buffs[buffName] = { ...buffData };
        if(character === player) {
            updatePlayerStats();
        }
    }
    
    function updateBuffs(character) {
        let statsChanged = false;
        for (const buffName in character.buffs) {
            character.buffs[buffName].duration--;
            if (character.buffs[buffName].duration <= 0) {
                delete character.buffs[buffName];
                addMessage(`${character.name}의 [${buffName}] 효과가 사라졌습니다.`);
                statsChanged = true;
            }
        }
        if (statsChanged && character === player) {
            updatePlayerStats();
        }
    }

    function startLiberationChallenge() {
        if(confirm("해방의 시험은 매우 어렵습니다. 모든 물약을 사용할 수 없으며, 패배 시 마을로 돌아갑니다. 도전하시겠습니까?")) {
            currentScreen = 'LIBERATION_BATTLE';
            monster = {
                name: '해방의 수호자',
                emoji: '👑',
                maxHp: 5000 + 1000 * player.rebirths,
                currentHp: 5000 + 1000 * player.rebirths,
                attack: 200 + 50 * player.rebirths,
                defense: 100 + 20 * player.rebirths,
                xp: 50000,
                gold: 100000,
                isBoss: true,
                isLiberationBoss: true,
                statusEffects: {},
                onHitEffect: { type: 'vulnerable', chance: 0.5, duration: 2, potency: 0.3 }
            };
            player.currentHp = player.maxHp;
            renderBattleScreen(false, true);
        }
    }

    function updateQuestProgress(type, value, name = '') {
        player.permanentQuests.forEach(quest => {
            if (!quest.completed && quest.type === type) {
                switch(type) {
                    case 'REACH_LEVEL':
                        quest.progress = Math.max(quest.progress, value);
                        break;
                    case 'DEFEAT_BOSS':
                        if (quest.targetName === name) quest.progress++;
                        break;
                    case 'ENHANCE_SUCCESS':
                        quest.progress = Math.max(quest.progress, value);
                        break;
                    case 'COLLECT_GOLD':
                    case 'USE_ULTIMATE':
                        quest.progress += value;
                        break;
                    case 'REBIRTH':
                    case 'TRANSCEND':
                         quest.progress = Math.max(quest.progress, value);
                         break;
                    case 'LIBERATION':
                        quest.progress = 1;
                        break;
                }
            }
        });
    }

    window.onload = () => {
        createStartScreen();
    };
  </script>
</body>
</html>
